we can clean up to make modern BT remember our styles

can we follow this but more lightly and efficiently not overload or use unnecessary data, you please review and fix all, something like Reddit tyle, like mdl mydramalist.com with emojis, mentions, save reactions, replies, likes, edit, delete, 

// public/scripts/comments.js

const getDebugState = () => {
  const config = window.TINKBYTE_CONFIG;
  // âœ… BETTER ENVIRONMENT DETECTION
  const isDev = config?.isDevelopment || 
                window.location.hostname === 'localhost' || 
                window.location.hostname === '127.0.0.1' ||
                window.location.hostname.includes('dev') ||
                window.location.protocol === 'http:';
  
  return config?.logging?.enabled && isDev;
};


function debugLog(...args) {
  if (getDebugState()) {
    console.log(...args);
  }
}

// Add these missing utility functions
function showUserError(message) {
  console.error('âŒ User Error:', message);
  
  // Create a toast/notification
  const toast = document.createElement('div');
  toast.style.cssText = `
    position: fixed;
    top: 20px;
    right: 20px;
    background: #fee2e2;
    border: 1px solid #fecaca;
    color: #dc2626;
    padding: 12px 16px;
    border-radius: 0px;
    box-shadow: 0 4px 2px rgba(0, 0, 0, 0.15);
    z-index: 10000;
    max-width: 300px;
    font-size: 14px;
  `;
  toast.textContent = message;
  
  document.body.appendChild(toast);
  
  // Remove after 5 seconds
  setTimeout(() => {
    if (toast.parentNode) {
      toast.parentNode.removeChild(toast);
    }
  }, 5000);
}

function showUserSuccess(message) {
  console.log('âœ… User Success:', message);
  
  // Create a success toast
  const toast = document.createElement('div');
  toast.style.cssText = `
    position: fixed;
    top: 20px;
    right: 20px;
    background: #d1fae5;
    border: 1px solid #a7f3d0;
    color: #065f46;
    padding: 12px 16px;
    border-radius: 0px;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
    z-index: 10000;
    max-width: 300px;
    font-size: 14px;
  `;
  toast.textContent = message;
  
  document.body.appendChild(toast);
  
  // Remove after 3 seconds
  setTimeout(() => {
    if (toast.parentNode) {
      toast.parentNode.removeChild(toast);
    }
  }, 3000);
}

function handleError(error, userMessage = "Something went wrong") {
  // Only log in development with your config
  if (getDebugState()) {
    console.error(error);
  }
  
  showUserError(userMessage);
}

// âœ… IMPORT YOUR SINGLETON DIRECTLY
async function getSupabaseSingleton() {
  try {
    const { supabase } = await import('/src/lib/supabase.js');
    return supabase;
  } catch (error) {
    console.error('âŒ Failed to import Supabase singleton:', error);
    return window.supabase;
  }
}

async function getRequiredModules() {
  try {
    // For static sites, modules should be available globally
    if (window.supabase && window.authManager) {
      return {
        supabase: window.supabase,
        authManager: window.authManager,
        TinkByteAPI: window.TinkByteAPI
      };
    }

    // Try to wait for them to be available
    let attempts = 0;
    const maxAttempts = 50; // 5 seconds max
    
    while (attempts < maxAttempts) {
      if (window.supabase && window.authManager) {
        return {
          supabase: window.supabase,
          authManager: window.authManager,
          TinkByteAPI: window.TinkByteAPI
        };
      }
      
      await new Promise(resolve => setTimeout(resolve, 100));
      attempts++;
    }
    
    throw new Error('Required modules not available');
  } catch (error) {
    debugLog('âŒ Failed to get required modules:', error);
    throw error;
  }
}

// Wait for auth modules to be ready
function waitForAuth() {
  return new Promise((resolve, reject) => {
    if (window.authManager && window.supabase) {
      resolve({
        authManager: window.authManager,
        supabase: window.supabase
      });
      return;
    }

    const authReadyHandler = (event) => {
      window.removeEventListener('authReady', authReadyHandler);
      resolve({
        authManager: event.detail.authManager,
        supabase: event.detail.supabase
      });
    };

    window.addEventListener('authReady', authReadyHandler);

    setTimeout(() => {
      window.removeEventListener('authReady', authReadyHandler);
      
      if (window.authManager && window.supabase) {
        resolve({
          authManager: window.authManager,
          supabase: window.supabase
        });
      } else {
        reject(new Error('Auth modules not available'));
      }
    }, 10000);
  });
}

function showInitializationError() {
  const commentSection = document.getElementById('comments-section');
  if (commentSection) {
    commentSection.innerHTML = `
      <div class="comment-error-state" style="
        display: flex;
        flex-direction: column;
        align-items: center;
        padding: 2rem;
        text-align: center;
        background: var(--secondary-bg);
        border-radius: 0px;
        margin: 1rem 0;
      ">
        <div class="error-icon" style="font-size: 3rem; margin-bottom: 1rem;">âš ï¸</div>
        <h3 style="margin-bottom: 0.5rem; color: var(--text-primary);">Comments temporarily unavailable</h3>
        <p style="margin-bottom: 1.5rem; color: var(--text-secondary);">Please refresh the page or try again later.</p>
        <button onclick="window.location.reload()" class="retry-btn" style="
          background: var(--primary-color);
          color: white;
          border: none;
          padding: 0.75rem 1.5rem;
          border-radius: 0px;
          cursor: pointer;
          font-weight: 500;
        ">
          Retry
        </button>
      </div>
    `;
  }
}

// Initialize comments when DOM and auth are ready
document.addEventListener('DOMContentLoaded', async () => {
  try {
    const { authManager, supabase } = await waitForAuth();
    const commentSystem = new TinkByteCommentSystem(authManager, supabase);

    window.tinkbyteComments = commentSystem;

    setTimeout(() => {
      if (window.tinkbyteComments) {
        window.tinkbyteComments.updateAllCommentPermissions();
      }
    }, 1500);

  } catch (error) {
    handleError(error, "Comments are temporarily unavailable");
    showInitializationError();
  }
});

class TinkByteCommentSystem {
constructor(authManager, supabase) {
  debugLog('ğŸ—ï¸ Creating TinkByteCommentSystem...');
  
  this.authManager = authManager;
  this.supabase = supabase;
  
  // âœ… SIMPLE STATE MANAGEMENT (like original)
  this.currentUser = null;
  this.profile = null;
  this.articleId = null;
  this.isAuthenticated = false;
  this.authInitialized = false;
  this.authPromise = null;
  this.config = window.TINKBYTE_CONFIG;
  this.environment = this.config?.environment || 'production';    
  this.isDevelopment = this.config?.isDevelopment || false;
  
  // Form state
  this.replyingTo = null;
  this.editingComment = null;
  this.isSubmitting = false;
  
  // UI state
  this.currentSort = 'newest';
  this.currentPage = 1;
  this.commentsPerPage = 5;
  this.totalComments = 0;
  this.loadedComments = 0;
  this.isLoadingMore = false;
  
  // Emoji and mention state
  this.draftTimeout = null;
  this.currentEmojiForm = null;
  this.currentEmojiTextarea = null;
  this.emojiPickerVisible = false;
  this.currentMentionDropdown = null;
  this.currentMentionTextarea = null;
  this.currentMentionStart = -1;
  this.selectedMentionIndex = 0;
  this.mentionInputHandler = null;
  this.mentionKeyHandler = null;
  this.permissionUpdateTimeout = null;
  
  debugLog('âœ… TinkByteCommentSystem created, environment:', this.environment);
  this.init();
}

fixMissingDataAttributes() {
  debugLog('ğŸ”§ Fixing missing data attributes...');
  
  // Get comment data from page
  const commentSection = document.getElementById('comments-section');
  const allCommentsData = commentSection?.dataset.allComments;
  
  if (!allCommentsData) return;
  
  try {
    const commentTree = JSON.parse(allCommentsData);
    const allComments = this.flattenCommentTree(commentTree);
    
    debugLog('ğŸ“‹ Found comment data for', allComments.length, 'comments');
    
    // Fix each comment card
    allComments.forEach(comment => {
      const commentCards = document.querySelectorAll(`[data-comment-id="${comment.id}"]`);
      
      commentCards.forEach(card => {
        // Set missing attributes
        if (!card.dataset.userId) {
          card.setAttribute('data-user-id', comment.user_id || '');
          card.dataset.userId = comment.user_id || '';
        }
        
        if (!card.dataset.createdAt) {
          card.setAttribute('data-created-at', comment.created_at || '');
          card.dataset.createdAt = comment.created_at || '';
        }
        
        if (!card.dataset.threadLevel) {
          const level = comment.thread_level || 0;
          card.setAttribute('data-thread-level', level.toString());
          card.dataset.threadLevel = level.toString();
        }
        
        debugLog('âœ… Fixed attributes for comment:', comment.id.slice(-6), {
          userId: card.dataset.userId,
          createdAt: card.dataset.createdAt,
          threadLevel: card.dataset.threadLevel
        });
      });
    });
    
  } catch (error) {
    console.error('âŒ Error fixing data attributes:', error);
  }
}

// ADD THIS HELPER METHOD:
flattenCommentTree(commentTree) {
  const allComments = [];
  
  function addCommentsRecursively(comments) {
    comments.forEach(comment => {
      allComments.push(comment);
      if (comment.replies && comment.replies.length > 0) {
        addCommentsRecursively(comment.replies);
      }
    });
  }
  
  addCommentsRecursively(commentTree);
  return allComments;
}

preserveExistingComments() {
  const commentSection = document.getElementById('comments-section');
  if (!commentSection) return;

  let serverTree = [];
  
  // âœ… FIRST TRY TO READ FROM JSON SCRIPT TAG
  const jsonScript = document.getElementById('tink-comments-data');
  if (jsonScript) {
    try {
      const jsonContent = jsonScript.textContent || jsonScript.innerHTML;
      if (jsonContent && jsonContent.trim() !== '') {
        serverTree = JSON.parse(jsonContent);
        debugLog('ğŸ“‹ Loaded comments from JSON script:', serverTree.length);
        
        // âœ… UPDATE DATASET FOR OTHER CODE THAT EXPECTS IT THERE
        commentSection.dataset.allComments = JSON.stringify(serverTree);
      }
    } catch (e) {
      console.error('âŒ Failed to parse JSON script:', e);
    }
  }
  
  // âœ… FALLBACK TO DATASET (for backward compatibility)
  if (serverTree.length === 0) {
    try {
      serverTree = JSON.parse(commentSection.dataset.allComments || '[]');
    } catch (e) {
      console.error('âŒ Failed to parse dataset comments:', e);
      return;
    }
  }


  const cachedKey = `comments_${this.articleId}_cache`;
  let clientTree = [];
  try {
    const cached = localStorage.getItem(cachedKey);
    if (cached) clientTree = JSON.parse(cached);
  } catch (e) {
    console.warn('âŒ Failed to parse localStorage:', e);
  }

  if (clientTree.length === 0) {
    this.fullCommentTree = serverTree;
    return;
  }

  const merged = [...serverTree];
  const existingIds = new Set(merged.map(c => c.id));

  clientTree.forEach(comment => {
    if (!existingIds.has(comment.id)) {
      if (comment.parent_id) {
        this.addReplyToTree(merged, comment, comment.parent_id);
      } else {
        merged.unshift(comment);
      }
      existingIds.add(comment.id);
    }
  });

  this.fullCommentTree = merged;
  commentSection.dataset.allComments = JSON.stringify(merged);

  const totalCount = merged.length;
  commentSection.dataset.totalComments = totalCount.toString();
  const counter = document.getElementById('total-comments');
  if (counter) counter.textContent = totalCount;
}

refreshCommentsUI(commentTree) {
  const commentsContainer = document.getElementById('comments-items');
  if (!commentsContainer) return;
  
  // âœ… CLEAR EXISTING COMMENTS
  commentsContainer.innerHTML = '';
  
  // âœ… RE-RENDER WITH MERGED COMMENTS
  const firstFive = commentTree.slice(0, 5); // Show first 5 like original
  
  firstFive.forEach(comment => {
    const commentElement = this.createCommentElementFromData(comment);
    if (commentElement) {
      commentsContainer.appendChild(commentElement);
    }
  });
  
  // âœ… UPDATE COUNTS
  const totalComments = this.countAllComments(commentTree);
  const commentSection = document.getElementById('comments-section');
  if (commentSection) {
    commentSection.dataset.totalComments = totalComments.toString();
    commentSection.dataset.loadedComments = Math.min(5, commentTree.length).toString();
  }
  
  debugLog('ğŸ”„ UI refreshed with merged comments');
}

countAllComments(commentTree) {
  let total = 0;
  
  function count(comments) {
    total += comments.length;
    comments.forEach(comment => {
      if (comment.replies && comment.replies.length > 0) {
        count(comment.replies);
      }
    });
  }
  
  count(commentTree);
  return total;
}

mergeCommentTrees(serverComments, clientComments) {
  const merged = [...serverComments];
  const serverCommentIds = new Set();
  
  // âœ… COLLECT ALL SERVER COMMENT IDS (INCLUDING NESTED)
  function collectIds(comments) {
    comments.forEach(comment => {
      serverCommentIds.add(comment.id);
      if (comment.replies && comment.replies.length > 0) {
        collectIds(comment.replies);
      }
    });
  }
  collectIds(serverComments);
  
  // âœ… ADD CLIENT COMMENTS THAT AREN'T ON SERVER YET
  clientComments.forEach(clientComment => {
    if (!serverCommentIds.has(clientComment.id)) {
      debugLog('â• Adding client-only comment:', clientComment.id);
      
      if (clientComment.parent_id) {
        // âœ… THIS IS A REPLY - FIND PARENT AND ADD IT
        this.addReplyToTree(merged, clientComment, clientComment.parent_id);
      } else {
        // âœ… THIS IS A ROOT COMMENT - ADD TO BEGINNING
        merged.unshift(clientComment);
      }
    }
  });
  
  return merged;
}

  // âœ… ADD THESE NEW METHODS ANYWHERE IN THE CLASS
updateCachedCommentTree(newComment, parentId = null) {
  try {
    const commentSection = document.getElementById('comments-section');
    if (!commentSection) return;
    
    // âœ… UPDATE PAGE DATA
    let allCommentTree = [];
    try {
      allCommentTree = JSON.parse(commentSection.dataset.allComments || '[]');
    } catch (e) {
      debugLog('âŒ Error parsing cached comments:', e);
      return;
    }
    
    if (parentId) {
      this.addReplyToTree(allCommentTree, newComment, parentId);
    } else {
      allCommentTree.unshift(newComment);
    }
    
    // âœ… UPDATE PAGE DATA
    commentSection.dataset.allComments = JSON.stringify(allCommentTree);
    
    // âœ… ALSO SAVE TO LOCALSTORAGE FOR PERSISTENCE ACROSS REFRESHES
    const cachedKey = `comments_${this.articleId}_cache`;
    const clientOnlyComments = this.extractClientOnlyComments(allCommentTree);
    localStorage.setItem(cachedKey, JSON.stringify(clientOnlyComments));
    
    // Update counts
    const totalComments = parseInt(commentSection.dataset.totalComments || '0');
    commentSection.dataset.totalComments = (totalComments + 1).toString();
    
    debugLog('âœ… Updated cached comment tree and localStorage');
    
  } catch (error) {
    debugLog('âŒ Error updating cached comment tree:', error);
  }
}

extractClientOnlyComments(allComments) {
  // âœ… EXTRACT COMMENTS THAT WERE ADDED CLIENT-SIDE (RECENT ONES)
  const now = new Date();
  const oneHourAgo = new Date(now.getTime() - 60 * 60 * 1000);
  
  const clientComments = [];
  
  function extractRecent(comments) {
    comments.forEach(comment => {
      const commentDate = new Date(comment.created_at);
      if (commentDate > oneHourAgo) {
        clientComments.push(comment);
      }
      
      if (comment.replies && comment.replies.length > 0) {
        extractRecent(comment.replies);
      }
    });
  }
  
  extractRecent(allComments);
  return clientComments;
}




  // Helper method to add reply to the tree recursively
  addReplyToTree(commentTree, newReply, parentId) {
    for (let comment of commentTree) {
      if (comment.id === parentId) {
        // Found the parent - add reply
        if (!comment.replies) {
          comment.replies = [];
        }
        comment.replies.push(newReply);
        return true;
      }
      
      // Check in nested replies
      if (comment.replies && comment.replies.length > 0) {
        if (this.addReplyToTree(comment.replies, newReply, parentId)) {
          return true;
        }
      }
    }
    return false;
  }

  // Debug method
  debugCachedComments() {
    const commentSection = document.getElementById('comments-section');
    if (commentSection) {
      try {
        const cached = JSON.parse(commentSection.dataset.allComments || '[]');
        console.log('ğŸ“‹ Cached comments:', cached);
        console.log('ğŸ“Š Total cached:', cached.length);
        
        // Count all comments including replies
        let totalWithReplies = 0;
        function countComments(comments) {
          totalWithReplies += comments.length;
          comments.forEach(comment => {
            if (comment.replies && comment.replies.length > 0) {
              countComments(comment.replies);
            }
          });
        }
        countComments(cached);
        console.log('ğŸ“Š Total with replies:', totalWithReplies);
        
      } catch (e) {
        console.error('âŒ Error parsing cached comments:', e);
      }
    }
  }

// ADD THIS METHOD:
updateAllExistingCommentPermissions() {
  debugLog('ğŸ”§ Updating permissions for all comments...');
  
  // Get all comment cards currently in the DOM
  const allCommentCards = document.querySelectorAll('[data-comment-id]');
  
  allCommentCards.forEach(card => {
    const commentId = card.dataset.commentId;
    if (commentId) {
      debugLog('Updating permissions for comment:', commentId);
      this.updateCommentPermissions(commentId);
    }
  });
  
  debugLog(`âœ… Updated permissions for ${allCommentCards.length} comments`);
}

preserveCommentTree() {
  // Get all comments from the page data
  const commentSection = document.getElementById('comments-section');
  if (!commentSection) return;
  
  const allCommentsData = commentSection.dataset.allComments;
  if (allCommentsData) {
    try {
      const commentTree = JSON.parse(allCommentsData);
      debugLog('ğŸ“‹ Preserving comment tree:', commentTree.length, 'root comments');
      
      // Store in memory for reference
      this.commentTree = commentTree;
      
      // Update permissions for all existing comments
      setTimeout(() => {
        this.updateAllCommentPermissions();
      }, 1000);
      
    } catch (error) {
      console.error('âŒ Error parsing comment tree:', error);
    }
  }
}

async init() {
  try {
    const commentSection = document.getElementById('comments-section');
    if (!commentSection) return;
    
    this.articleId = commentSection.dataset.articleId;
    this.environment = this.getEnvironment();
    
    debugLog('ğŸ”§ Environment detected:', this.environment);
    
    // âœ… FIXED: Proper JSON script reading with error handling (ADD THIS)
    const jsonScript = document.getElementById('tink-comments-data');
    let allCommentsData = [];
    let jsonContent = '';
    
    if (jsonScript) {
      try {
        jsonContent = jsonScript.textContent || jsonScript.innerHTML || '';
        jsonContent = jsonContent.trim();
        
        debugLog('ğŸ“„ Raw JSON content length:', jsonContent.length);
        
        if (jsonContent && jsonContent !== '' && jsonContent !== '[]') {
          // Clean up any potential HTML entities or extra whitespace
          jsonContent = jsonContent.replace(/&lt;/g, '<').replace(/&gt;/g, '>').replace(/&amp;/g, '&');
          allCommentsData = JSON.parse(jsonContent);
          debugLog('âœ… Successfully parsed JSON:', allCommentsData.length, 'comments');
        } else {
          debugLog('âš ï¸ JSON script is empty or contains empty array');
        }
      } catch (parseError) {
        console.error('âŒ Error parsing comments JSON:', parseError);
        debugLog('âŒ Problematic JSON content:', jsonContent);
        allCommentsData = [];
      }
    } else {
      debugLog('âš ï¸ JSON script element not found');
    }

    // âœ… DEBUG: Check if data is available on refresh
    console.log('ğŸ” Comment section data on init:', {
      articleId: commentSection.dataset.articleId,
      totalComments: commentSection.dataset.totalComments,
      allComments: allCommentsData.length > 0 ? `Found ${allCommentsData.length} comments` : 'Missing',
      environment: commentSection.dataset.environment,
      jsonScriptExists: !!jsonScript,
      jsonContentLength: jsonContent.length
    });
    
    // âœ… Update dataset if we found data
    if (allCommentsData.length > 0) {
      commentSection.dataset.allComments = JSON.stringify(allCommentsData);
    }
    
    // âœ… PRESERVE EXISTING COMMENTS FIRST
    this.preserveExistingComments();
    
    // Initialize auth silently
    await this.initializeAuth();

    this.fixMissingDataAttributes();
    
    // Then initialize UI and event listeners
    this.initializeUI();
    this.setupEventListeners();
    this.setupModalHandlers();
    this.setupKeyboardShortcuts();
    this.setupFormResponsiveness();
    this.setupMentionSystem(); 
    this.setupLoadMore();
    this.preventFormRefresh();

    // Load drafts if authenticated
    if (this.isAuthenticated) {
      await this.loadDrafts();
    }
    
  } catch (error) {
    console.error('âŒ Init error:', error);
  }
}

cleanupOldCache() {
  try {
    const cachedKey = `comments_${this.articleId}_cache`;
    const clientCachedData = localStorage.getItem(cachedKey);
    
    if (clientCachedData) {
      const clientComments = JSON.parse(clientCachedData);
      const now = new Date();
      const sixHoursAgo = new Date(now.getTime() - 6 * 60 * 60 * 1000);
      
      // âœ… REMOVE COMMENTS OLDER THAN 6 HOURS (THEY SHOULD BE ON SERVER BY NOW)
      const recentComments = clientComments.filter(comment => {
        const commentDate = new Date(comment.created_at);
        return commentDate > sixHoursAgo;
      });
      
      if (recentComments.length !== clientComments.length) {
        localStorage.setItem(cachedKey, JSON.stringify(recentComments));
        debugLog('ğŸ§¹ Cleaned up old cached comments');
      }
    }
  } catch (error) {
    debugLog('âŒ Error cleaning cache:', error);
  }
}

  getEnvironment() {
    // âœ… USE CONFIG WITH FALLBACK
    if (this.config?.environment) {
      return this.config.environment;
    }
    
    // Fallback detection
    if (typeof window !== 'undefined') {
      const hostname = window.location.hostname;
      const isDev = hostname === 'localhost' || 
                   hostname === '127.0.0.1' || 
                   hostname.includes('dev') ||
                   window.location.protocol === 'http:';
      return isDev ? 'development' : 'production';
    }
    
    return 'production';
  }


preventFormRefresh() {
    document.addEventListener('submit', (e) => {
      if (e.target.closest('#comments-section')) {
        e.preventDefault();
        e.stopPropagation();
      }
    });
    
    document.addEventListener('click', (e) => {
      const target = e.target.closest('button');
      if (target && target.closest('#comments-section')) {
        if (!target.getAttribute('type')) {
          target.setAttribute('type', 'button');
        }
      }
    });
  }

  // âœ… SILENT AUTH INITIALIZATION
  async initializeAuth() {
    if (!this.authPromise) {
      this.authPromise = this._doAuthInitialization();
    }
    return this.authPromise;
  }



async _doAuthInitialization() {
  try {
    debugLog('ğŸ”„ Starting auth initialization...');
    debugLog('ğŸŒ Environment:', this.environment);
    
    const { data: { session }, error: sessionError } = await this.supabase.auth.getSession();
    
    if (sessionError) {
      debugLog('âš ï¸ Session error:', sessionError);
    }
    
    if (session?.user) {
      debugLog('âœ… User found:', session.user.email);
      debugLog('ğŸ‘¤ User metadata:', session.user.user_metadata);
      
      this.currentUser = { 
        id: session.user.id, 
        email: session.user.email,
        user_metadata: session.user.user_metadata
      };
      this.isAuthenticated = true;
      
      await this.loadUserProfile();
    } else {
      debugLog('â„¹ï¸ No active session');
      this.currentUser = null;
      this.isAuthenticated = false;
    }
    
    this.authInitialized = true;
    this.updateUI();
    
    // âœ… SIMPLE AUTH LISTENER (like original)
    this.supabase.auth.onAuthStateChange(async (event, session) => {
      debugLog('ğŸ”„ Auth state changed:', event);
      debugLog('ğŸ‘¤ Session user:', session?.user?.email);
      
      if (event === 'SIGNED_IN' && session?.user) {
        this.currentUser = { 
          id: session.user.id, 
          email: session.user.email,
          user_metadata: session.user.user_metadata
        };
        this.isAuthenticated = true;
        await this.loadUserProfile();
        this.updateUI();
      } else if (event === 'SIGNED_OUT') {
        this.currentUser = null;
        this.profile = null;
        this.isAuthenticated = false;
        this.updateUI();
      }
      
      setTimeout(() => {
        this.updateAllCommentPermissions();
      }, 500);
    });
    
    debugLog('âœ… Auth initialization complete:', {
      authenticated: this.isAuthenticated,
      user: this.currentUser?.email,
      profile: this.profile?.display_name
    });
    
  } catch (error) {
    handleError(error, 'Authentication initialization failed');
    this.authInitialized = true;
    this.currentUser = null;
    this.isAuthenticated = false;
    this.updateUI();
  }
}

  async callAPI(method, args = []) {
  try {
    // Check if TinkByteAPI exists and has the method
    if (window.TinkByteAPI && typeof window.TinkByteAPI[method] === 'function') {
      return await window.TinkByteAPI[method](...args);
    }
    
    // Fallback for missing API
    throw new Error(`API method ${method} not available`);
  } catch (error) {
    debugLog(`âŒ API call failed for ${method}:`, error);
    return { success: false, error: error.message };
  }
}


  // Method to wait for comments to render
  waitForCommentsToRender(callback, maxAttempts = 10, attempt = 1) {
    const commentCards = document.querySelectorAll('.comment-card[data-comment-id], .reply-card[data-comment-id]');
    
    if (commentCards.length > 0) {
      callback();
      return;
    }
    
    if (attempt >= maxAttempts) {
      return;
    }
    
    setTimeout(() => {
      this.waitForCommentsToRender(callback, maxAttempts, attempt + 1);
    }, 200);
  }

  updateAllCommentPermissions() {
  if (!this.authInitialized) {
    return;
  }

  // Clear any existing timeout to prevent multiple calls
  clearTimeout(this.permissionUpdateTimeout);
  
  this.permissionUpdateTimeout = setTimeout(() => {
    // Use Set to avoid duplicates
    const processedComments = new Set();
    const commentCards = document.querySelectorAll('.comment-card[data-comment-id], .reply-card[data-comment-id]');
    
    commentCards.forEach(card => {
      const commentId = card.dataset.commentId;
      if (commentId && !processedComments.has(commentId)) {
        processedComments.add(commentId);
        this.updateCommentPermissions(commentId);
      }
    });
    
    debugLog(`âœ… Updated permissions for ${processedComments.size} unique comments`);
  }, 100);
}

updateCommentPermissions(commentId) {
  const dropdown = document.getElementById(`dropdown-${commentId}`);
  const commentCard = document.querySelector(`[data-comment-id="${commentId}"]`);
  
  if (!dropdown || !commentCard) {
    return;
  }
  
  const editBtn = dropdown.querySelector('.edit-comment-btn');
  const deleteBtn = dropdown.querySelector('.delete-comment-btn');
  const reportBtn = dropdown.querySelector('.report-btn');
  const replyBtn = commentCard.querySelector('.reply-btn');

  // Show reply button if authenticated
  if (replyBtn) {
    replyBtn.style.display = this.isAuthenticated ? 'inline-flex' : 'none';
  }

  // Show report button always
  if (reportBtn) {
    reportBtn.style.display = 'flex';
  }

  // Handle edit/delete for authenticated users
  if (this.isAuthenticated && this.currentUser) {
    const commentUserId = commentCard.dataset.userId;
    const currentUserId = this.currentUser.id;
    const isOwner = commentUserId === currentUserId;
    const canEdit = this.canStillEdit(commentCard.dataset.createdAt);
    
    debugLog('Permission check:', {
      commentId,
      commentUserId,
      currentUserId,
      isOwner,
      canEdit,
      createdAt: commentCard.dataset.createdAt
    });
    
    if (editBtn) {
      editBtn.style.display = (isOwner && canEdit) ? 'inline-flex' : 'none';
    }
    
    if (deleteBtn) {
      deleteBtn.style.display = isOwner ? 'inline-flex' : 'none';
    }
  } else {
    // Not authenticated - hide edit/delete
    if (editBtn) editBtn.style.display = 'none';
    if (deleteBtn) deleteBtn.style.display = 'none';
  }
}

canStillEdit(createdAtString) {
  if (!createdAtString) return false;
  
  const createdAt = new Date(createdAtString);
  const now = new Date();
  const diffInMinutes = (now - createdAt) / (1000 * 60);
  
  return diffInMinutes <= 15;
}

// ALSO ADD/UPDATE this method:
isCommentOwner(commentCard) {
  if (!this.currentUser || !commentCard) {
    debugLog('No current user or comment card');
    return false;
  }
  
  const commentUserId = commentCard.dataset.userId;
  const currentUserId = this.currentUser.id;
  
  debugLog('Ownership check:', {
    commentUserId,
    currentUserId,
    match: commentUserId === currentUserId
  });
  
  return commentUserId === currentUserId;
}

// AND UPDATE this method:
canStillEdit(createdAtString) {
  if (!createdAtString) {
    debugLog('No created date provided');
    return false;
  }
  
  const createdAt = new Date(createdAtString);
  const now = new Date();
  const diffInMinutes = (now - createdAt) / (1000 * 60);
  
  debugLog('Edit time check:', {
    createdAt: createdAt.toISOString(),
    now: now.toISOString(),
    diffInMinutes: Math.round(diffInMinutes),
    canEdit: diffInMinutes <= 15
  });
  
  return diffInMinutes <= 15;
}

  updateCommentDataAttributes() {
    if (!this.currentUser) {
      return;
    }
    
    const commentCards = document.querySelectorAll('.comment-card[data-comment-id], .reply-card[data-comment-id]');
    
    commentCards.forEach(card => {
      const commentId = card.dataset.commentId;
      const currentUserId = card.dataset.userId;
      
      if (!currentUserId || currentUserId.trim() === '' || currentUserId === 'null' || currentUserId === 'undefined') {
        this.fixCommentDataAttribute(commentId, card);
      }
    });
  }

  async fixCommentDataAttribute(commentId, commentCard) {
    try {
      const { data, error } = await this.supabase
        .from('comments')
        .select('user_id, created_at')
        .eq('id', commentId)
        .eq('environment', this.environment)
        .single();
      
      if (error || !data) return;
      
      if (data.user_id) {
        commentCard.setAttribute('data-user-id', data.user_id);
        commentCard.dataset.userId = data.user_id;
      }
      
      if (data.created_at) {
        commentCard.setAttribute('data-created-at', data.created_at);
        commentCard.dataset.createdAt = data.created_at;
      }
      
      setTimeout(() => {
        this.updateCommentPermissions(commentId);
      }, 100);
      
    } catch (error) {
      debugLog('âŒ Error fixing comment data:', error);
    }
  }

  // Ultra-fast auth check - instant after first load
  async ensureAuth() {
    if (this.authInitialized) return;
    await this.authPromise;
  }

async loadUserProfile() {
  if (!this.currentUser) return;
  
  try {
    debugLog('ğŸ”„ Loading profile for:', this.currentUser.email);
    
    // âœ… SIMPLIFIED PROFILE QUERY - Remove environment filter for now
    let { data, error } = await this.supabase
      .from('profiles')
      .select('*')
      .eq('id', this.currentUser.id)
      .single();
    
    if (error) {
      debugLog('âš ï¸ Profile load failed:', error.message);
      
      // âœ… CREATE DEFAULT PROFILE FROM USER METADATA
      this.profile = {
        id: this.currentUser.id,
        display_name: this.currentUser.user_metadata?.full_name || 
                     this.currentUser.user_metadata?.name || 
                     this.currentUser.email?.split('@')[0] || 'User',
        avatar_type: this.currentUser.user_metadata?.avatar_url ? 'google' : 'preset',
        avatar_preset_id: 1,
        avatar_url: this.currentUser.user_metadata?.avatar_url || 
                   this.currentUser.user_metadata?.picture || null,
        reputation_score: 0,
        is_admin: false,
        membership_type: 'free',
        environment: this.environment
      };
      debugLog('âš ï¸ Using default profile from user metadata');
      return;
    }
    
    if (data) {
      this.profile = data;
      debugLog('âœ… Profile loaded:', {
        name: this.profile.display_name,
        avatar_type: this.profile.avatar_type,
        avatar_url: this.profile.avatar_url
      });
    }
  } catch (error) {
    debugLog('âŒ Profile loading error:', error);
    // Fallback profile
    this.profile = {
      id: this.currentUser.id,
      display_name: this.currentUser.email?.split('@')[0] || 'User',
      avatar_type: 'preset',
      avatar_preset_id: 1,
      avatar_url: null,
      reputation_score: 0,
      is_admin: false,
      membership_type: 'free'
    };
  }
}


initializeUI() {
  this.updateUI();
  
  // Wait for comments to render, then update permissions
  setTimeout(() => {
    this.updateAllCommentPermissions();
    this.initializePagination();
  }, 1000);
  
  // Also update permissions after auth changes
  setTimeout(() => {
    this.updateAllCommentPermissions();
  }, 2000);
}


  initializePagination() {
    const commentSection = document.getElementById('comments-section');
    if (!commentSection) return;

    this.totalComments = parseInt(commentSection.dataset.totalComments || '0');
    this.loadedComments = parseInt(commentSection.dataset.loadedComments || '0');
    this.commentsPerPage = parseInt(commentSection.dataset.commentsPerPage || '5');
    
    this.updateLoadMoreUI();
  }

  updateLoadMoreUI() {
    const showingCount = document.getElementById('showing-count');
    const totalCount = document.getElementById('total-count');
    const loadMoreSection = document.getElementById('load-more-section');
    
    if (showingCount) {
      showingCount.textContent = this.loadedComments.toString();
    }
    
    if (totalCount) {
      totalCount.textContent = this.totalComments.toString();
    }
    
    if (loadMoreSection) {
      if (this.loadedComments >= this.totalComments) {
        loadMoreSection.style.display = 'none';
      } else {
        loadMoreSection.style.display = 'block';
      }
    }
  }

updateUI() {
  debugLog('ğŸ¨ Updating UI, authenticated:', this.isAuthenticated);
  
  const guestPrompt = document.getElementById('guest-comment-prompt');
  const userForm = document.getElementById('user-comment-form');
  
  if (this.isAuthenticated) {
    debugLog('ğŸ‘¤ Showing authenticated UI');
    if (guestPrompt) {
      guestPrompt.style.display = 'none';
      debugLog('ğŸ‘» Guest prompt hidden');
    }
    if (userForm) {
      userForm.style.display = 'block';
      debugLog('ğŸ“ User form shown');
    }
    this.updateUserInfo();
  } else {
    debugLog('ğŸš« Showing guest UI');
    if (guestPrompt) {
      guestPrompt.style.display = 'flex';
      debugLog('ğŸ‘» Guest prompt shown');
    }
    if (userForm) {
      userForm.style.display = 'none';
      debugLog('ğŸ“ User form hidden');
    }
  }
}

  updateUserInfo() {
    if (!this.profile) {
      debugLog('âš ï¸ No profile for user info update');
      return;
    }

    debugLog('ğŸ‘¤ Updating user info:', this.profile.display_name);

    const userAvatar = document.getElementById('user-avatar');
    const userName = document.getElementById('user-name');
    
    if (userAvatar) {
      const avatarUrl = this.getUserAvatar(this.profile);
      userAvatar.innerHTML = `<img src="${avatarUrl}" alt="${this.profile.display_name}" />`;
      debugLog('ğŸ–¼ï¸ Avatar updated:', avatarUrl);
    }
    
    if (userName) {
      userName.textContent = this.profile.display_name || 'User';
      debugLog('ğŸ‘¤ Name updated:', this.profile.display_name);
    }
  }

  getUserAvatar(profile) {
  // âœ… USE YOUR ACTUAL AUTH MANAGER'S AVATAR METHOD
  if (window.authManager && window.authManager.getAvatarUrl) {
    return window.authManager.getAvatarUrl();
  }
  
  // âœ… FALLBACK TO YOUR ORIGINAL LOGIC
  if (!profile) return "/images/avatars/preset-1.svg";
  
  if (profile.avatar_type === "google" && profile.avatar_url) {
    return profile.avatar_url;
  }
  
  if (profile.avatar_type === "uploaded" && profile.avatar_url) {
    return profile.avatar_url;
  }
  
  // Fallback to user metadata
  if (this.currentUser?.user_metadata?.avatar_url) {
    return this.currentUser.user_metadata.avatar_url;
  }
  
  if (this.currentUser?.user_metadata?.picture) {
    return this.currentUser.user_metadata.picture;
  }
  
  const presetId = profile.avatar_preset_id || 1;
  return `/images/avatars/preset-${presetId}.svg`;
}


  setupEventListeners() {
    // Main comment form
    const commentForm = document.getElementById('comment-form');
    if (commentForm) {
      commentForm.addEventListener('submit', this.handleCommentSubmit.bind(this));
    }

    // Character count and draft saving
    const textarea = document.getElementById('comment-textarea');
    if (textarea) {
      textarea.addEventListener('input', this.updateCharacterCount.bind(this));
      textarea.addEventListener('input', this.saveDraft.bind(this));
    }

    // Setup other handlers
    this.setupFormattingButtons();
    this.setupEmojiPicker();
    this.setupCommentActions();
    this.setupSorting();
    this.setupLoadMore();
    this.setupInlineHandlers();

    // Cancel reply
    const cancelReplyBtn = document.getElementById('cancel-reply');
    if (cancelReplyBtn) {
      cancelReplyBtn.addEventListener('click', this.cancelReply.bind(this));
    }

    // Account management
    const accountBtn = document.getElementById('tinkbyte-account-btn');
    if (accountBtn) {
      accountBtn.addEventListener('click', () => window.location.href = '/auth/signin');
    }
  }

  setupKeyboardShortcuts() {
    document.addEventListener('keydown', (e) => {
      // Ctrl/Cmd + Enter to submit
      if ((e.ctrlKey || e.metaKey) && e.key === 'Enter') {
        const activeElement = document.activeElement;
        
        if (activeElement?.tagName === 'TEXTAREA') {
          const form = activeElement.closest('form');
          if (form) {
            e.preventDefault();
            e.stopPropagation();
            
            const submitEvent = new Event('submit', { 
              bubbles: true, 
              cancelable: true 
            });
            form.dispatchEvent(submitEvent);
          }
        }
      }
      
      // Escape to close
      if (e.key === 'Escape') {
        this.handleEscapeKey();
      }
    });
  }

  handleEscapeKey() {
    this.closeAllModals();
    this.closeAllInlineForms();
    this.closeAllEmojiPickers();
    document.querySelectorAll('.dropdown-menu.show').forEach(menu => {
      menu.classList.remove('show');
    });
  }

  setupModalHandlers() {
    // Delete modal
    ['close-delete-modal', 'cancel-delete'].forEach(id => {
      const btn = document.getElementById(id);
      if (btn) btn.addEventListener('click', () => this.hideModal('delete-modal'));
    });
    
    const confirmDelete = document.getElementById('confirm-delete');
    if (confirmDelete) {
      confirmDelete.addEventListener('click', this.confirmDelete.bind(this));
    }

    // Report modal
    ['close-report-modal', 'cancel-report'].forEach(id => {
      const btn = document.getElementById(id);
      if (btn) btn.addEventListener('click', () => this.hideModal('report-modal'));
    });
    
    const confirmReport = document.getElementById('confirm-report');
    if (confirmReport) {
      confirmReport.addEventListener('click', this.confirmReport.bind(this));
    }

    // Close modals on overlay click
    document.addEventListener('click', (e) => {
      if (e.target.classList.contains('modal-overlay')) {
        this.hideModal(e.target.id);
      }
    });
  }

  setupInlineHandlers() {
    // Inline reply cancel handlers
    document.addEventListener('click', (e) => {
      if (e.target.closest('.cancel-inline-reply')) {
        e.preventDefault();
        e.stopPropagation();
        
        const container = e.target.closest('.inline-reply-container');
        if (container) {
          container.style.display = 'none';
          container.innerHTML = '';
        }
      }
    });

    // Inline edit handlers
    document.addEventListener('click', (e) => {
      if (e.target.closest('.cancel-edit-inline')) {
        e.preventDefault();
        e.stopPropagation();
        
        const container = e.target.closest('.inline-edit-container');
        if (container) {
          container.style.display = 'none';
          container.innerHTML = '';
        }
      }
    });

    // Main form cancel button
    document.addEventListener('click', (e) => {
      if (e.target.closest('.cancel-btn')) {
        e.preventDefault();
        e.stopPropagation();
        
        const form = e.target.closest('form');
        if (form) {
          this.resetForm(form);
          this.resetFormState(form);
        }
      }
    });

    // Inline form submissions
    document.addEventListener('submit', (e) => {
      if (e.target.classList.contains('inline-comment-form')) {
        e.preventDefault();
        e.stopPropagation();
        this.handleInlineReply(e.target);
      }
      
      if (e.target.classList.contains('edit-comment-form-inline')) {
        e.preventDefault();
        e.stopPropagation();
        this.handleInlineEdit(e.target);
      }
    });
  }

  setupFormResponsiveness() {
    // Re-initialize forms periodically
    setInterval(() => {
      this.refreshFormEventListeners();
    }, 60000);
  }

  refreshFormEventListeners() {
    // Re-check auth state
    this.updateUI();
    
    // Re-setup character counters
    const textareas = document.querySelectorAll('textarea');
    textareas.forEach(textarea => {
      textarea.removeEventListener('input', this.updateCharacterCount);
      textarea.addEventListener('input', this.updateCharacterCount.bind(this));
    });
    
    // Re-setup form submissions
    const forms = document.querySelectorAll('form');
    forms.forEach(form => {
      if (form.id === 'comment-form') {
        form.removeEventListener('submit', this.handleCommentSubmit);
        form.addEventListener('submit', this.handleCommentSubmit.bind(this));
      }
    });
  }

  setupFormattingButtons() {
    document.addEventListener('click', (e) => {
      // Existing format buttons
      if (e.target.closest('.format-btn, .inline-format-btn, .edit-format-btn')) {
        e.preventDefault();
        const btn = e.target.closest('.format-btn, .inline-format-btn, .edit-format-btn');
        const format = btn.dataset.format;
        const form = btn.closest('form');
        const textarea = form.querySelector('textarea');
        this.applyFormatting(format, textarea);
      }

      // Mention button handler
      if (e.target.closest('.mention-btn')) {
        e.preventDefault();
        e.stopPropagation();
        
        const btn = e.target.closest('.mention-btn');
        const form = btn.closest('form') || btn.closest('.comment-form-container');
        const textarea = form.querySelector('textarea');
        
        if (textarea) {
          const cursorPos = textarea.selectionStart;
          const textBefore = textarea.value.substring(0, cursorPos);
          const textAfter = textarea.value.substring(cursorPos);
          
          textarea.value = textBefore + '@' + textAfter;
          textarea.focus();
          textarea.setSelectionRange(cursorPos + 1, cursorPos + 1);
          
          this.handleMentionInput(textarea);
        }
      }
    });
  }

  setupEmojiPicker() {
    this.createGlobalEmojiPicker();
    
    document.addEventListener('click', (e) => {
      // Handle emoji button clicks
      if (e.target.closest('.emoji-btn, .inline-emoji-btn')) {
        e.preventDefault();
        e.stopPropagation();
        
        const btn = e.target.closest('.emoji-btn, .inline-emoji-btn');
        const form = btn.closest('form') || btn.closest('.comment-form-container');
        
        if (form) {
          this.currentEmojiForm = form;
          this.currentEmojiTextarea = form.querySelector('textarea');
          this.showGlobalEmojiPicker(btn);
        }
        return;
      }

      // Handle emoji category clicks
      if (e.target.closest('.emoji-category')) {
        e.preventDefault();
        e.stopPropagation();
        
        const category = e.target.closest('.emoji-category');
        const categoryName = category.dataset.category;
        this.switchEmojiCategory(categoryName);
        return;
      }

      // Handle emoji option clicks
      if (e.target.closest('.emoji-option')) {
        e.preventDefault();
        e.stopPropagation();
        
        const option = e.target.closest('.emoji-option');
        const emoji = option.dataset.emoji;
        
        if (this.currentEmojiTextarea) {
          this.insertEmoji(emoji, this.currentEmojiTextarea);
        }
        
        this.hideGlobalEmojiPicker();
        return;
      }

      // Close emoji picker when clicking outside
      if (!e.target.closest('.global-emoji-picker, .emoji-btn, .inline-emoji-btn')) {
        this.hideGlobalEmojiPicker();
      }
    });
    
    window.addEventListener('resize', () => {
      this.hideGlobalEmojiPicker();
    });
    
    window.addEventListener('scroll', () => {
      this.hideGlobalEmojiPicker();
    });
  }

  createGlobalEmojiPicker() {
    const existingPicker = document.getElementById('global-emoji-picker');
    if (existingPicker) {
      existingPicker.remove();
    }
    
    const picker = document.createElement('div');
    picker.id = 'global-emoji-picker';
    picker.className = 'global-emoji-picker';
    picker.style.cssText = `
      position: fixed;
      z-index: 99999;
      width: 320px;
      max-width: 90vw;
      max-height: 300px;
      background: var(--secondary-bg);
      border: 1px solid var(--border-color);
      border-radius: 0px;
      padding: 0.75rem;
      overflow-y: auto;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
      display: none;
      box-sizing: border-box;
    `;
    
    picker.innerHTML = `
      <div class="emoji-categories">
        <button class="emoji-category active" data-category="recent">Recent</button>
        <button class="emoji-category" data-category="smileys">ğŸ˜€</button>
        <button class="emoji-category" data-category="people">ğŸ‘¤</button>
        <button class="emoji-category" data-category="nature">ğŸŒ±</button>
        <button class="emoji-category" data-category="food">ğŸ</button>
        <button class="emoji-category" data-category="activities">âš½</button>
        <button class="emoji-category" data-category="travel">ğŸš—</button>
        <button class="emoji-category" data-category="objects">ğŸ’¡</button>
        <button class="emoji-category" data-category="symbols">â¤ï¸</button>
        <button class="emoji-category" data-category="flags">ğŸ‡³ğŸ‡¬</button>
        <button class="emoji-category" data-category="coding">ğŸ’»</button>
      </div>
      <div class="emoji-grid" id="emoji-grid-container">
        <!-- Emojis will be populated based on category -->
      </div>
    `;
    
    document.body.appendChild(picker);
    
    // Initialize with recent emojis
    this.switchEmojiCategory('recent');
  }

  switchEmojiCategory(categoryName) {
    const categories = document.querySelectorAll('.emoji-category');
    categories.forEach(cat => cat.classList.remove('active'));
    
    const activeCategory = document.querySelector(`[data-category="${categoryName}"]`);
    if (activeCategory) {
      activeCategory.classList.add('active');
    }
    
    const grid = document.getElementById('emoji-grid-container');
    if (!grid) return;
    
    const emojiSets = {
      recent: ['ğŸ˜€', 'ğŸ˜Š', 'ğŸ˜‚', 'â¤ï¸', 'ğŸ‘', 'ğŸ‘', 'ğŸ‰', 'ğŸ”¥', 'ğŸ’¯', 'âœ¨', 'ğŸš€', 'ğŸ’ª', 'ğŸ™', 'ğŸ‘', 'ğŸŠ', 'ğŸˆ'],
      
      smileys: [
        'ğŸ˜€', 'ğŸ˜ƒ', 'ğŸ˜„', 'ğŸ˜', 'ğŸ˜†', 'ğŸ˜…', 'ğŸ˜‚', 'ğŸ¤£', 'ğŸ˜Š', 'ğŸ˜‡', 'ğŸ™‚', 'ğŸ™ƒ', 'ğŸ˜‰', 'ğŸ˜Œ', 'ğŸ˜', 'ğŸ¥°',
        'ğŸ˜˜', 'ğŸ˜—', 'ğŸ˜™', 'ğŸ˜š', 'ğŸ˜‹', 'ğŸ˜›', 'ğŸ˜', 'ğŸ˜œ', 'ğŸ¤ª', 'ğŸ¤¨', 'ğŸ§', 'ğŸ¤“', 'ğŸ˜', 'ğŸ¤©', 'ğŸ¥³', 'ğŸ˜',
        'ğŸ˜’', 'ğŸ˜', 'ğŸ˜”', 'ğŸ˜Ÿ', 'ğŸ˜•', 'ğŸ™', 'â˜¹ï¸', 'ğŸ˜£', 'ğŸ˜–', 'ğŸ˜«', 'ğŸ˜©', 'ğŸ¥º', 'ğŸ˜¢', 'ğŸ˜­', 'ğŸ˜¤', 'ğŸ˜ ',
        'ğŸ˜¡', 'ğŸ¤¬', 'ğŸ¤¯', 'ğŸ˜³', 'ğŸ¥µ', 'ğŸ¥¶', 'ğŸ˜±', 'ğŸ˜¨', 'ğŸ˜°', 'ğŸ˜¥', 'ğŸ˜“', 'ğŸ¤—', 'ğŸ¤”', 'ğŸ¤­', 'ğŸ¤«', 'ğŸ¤¥'
      ],
      
      people: [
        'ğŸ‘‹', 'ğŸ¤š', 'ğŸ–ï¸', 'âœ‹', 'ğŸ––', 'ğŸ‘Œ', 'ğŸ¤', 'âœŒï¸', 'ğŸ¤', 'ğŸ¤Ÿ', 'ğŸ¤˜', 'ğŸ¤™', 'ğŸ‘ˆ', 'ğŸ‘‰', 'ğŸ‘†', 'ğŸ–•',
        'ğŸ‘‡', 'â˜ï¸', 'ğŸ‘', 'ğŸ‘', 'âœŠ', 'ğŸ‘Š', 'ğŸ¤›', 'ğŸ¤œ', 'ğŸ‘', 'ğŸ™Œ', 'ğŸ‘', 'ğŸ¤²', 'ğŸ¤', 'ğŸ™', 'âœï¸', 'ğŸ’…',
        'ğŸ¤³', 'ğŸ’ª', 'ğŸ¦¾', 'ğŸ¦¿', 'ğŸ¦µ', 'ğŸ¦¶', 'ğŸ‘‚', 'ğŸ¦»', 'ğŸ‘ƒ', 'ğŸ§ ', 'ğŸ¦·', 'ğŸ¦´', 'ğŸ‘€', 'ğŸ‘ï¸', 'ğŸ‘…', 'ğŸ‘„'
      ],
      
      nature: [
        'ğŸµ', 'ğŸ’', 'ğŸ¦', 'ğŸ¦§', 'ğŸ¶', 'ğŸ•', 'ğŸ¦®', 'ğŸ©', 'ğŸº', 'ğŸ¦Š', 'ğŸ¦', 'ğŸ±', 'ğŸˆ', 'ğŸ¦', 'ğŸ¯', 'ğŸ…',
        'ğŸ†', 'ğŸ´', 'ğŸ', 'ğŸ¦„', 'ğŸ¦“', 'ğŸ¦Œ', 'ğŸ®', 'ğŸ‚', 'ğŸƒ', 'ğŸ„', 'ğŸ·', 'ğŸ–', 'ğŸ—', 'ğŸ½', 'ğŸ', 'ğŸ‘',
        'ğŸŒ±', 'ğŸŒ¿', 'ğŸ€', 'ğŸƒ', 'ğŸŒ³', 'ğŸŒ²', 'ğŸŒ´', 'ğŸŒµ', 'ğŸŒ¾', 'ğŸŒ»', 'ğŸŒº', 'ğŸŒ¸', 'ğŸŒ¼', 'ğŸŒ·', 'ğŸ¥€', 'ğŸŒ¹'
      ],
      
      food: [
        'ğŸ', 'ğŸ', 'ğŸ', 'ğŸŠ', 'ğŸ‹', 'ğŸŒ', 'ğŸ‰', 'ğŸ‡', 'ğŸ“', 'ğŸ«', 'ğŸˆ', 'ğŸ’', 'ğŸ‘', 'ğŸ¥­', 'ğŸ', 'ğŸ¥¥',
        'ğŸ¥', 'ğŸ…', 'ğŸ†', 'ğŸ¥‘', 'ğŸ¥¦', 'ğŸ¥¬', 'ğŸ¥’', 'ğŸŒ¶ï¸', 'ğŸ«‘', 'ğŸŒ½', 'ğŸ¥•', 'ğŸ«’', 'ğŸ§„', 'ğŸ§…', 'ğŸ¥”', 'ğŸ ',
        'ğŸ¥', 'ğŸ¥–', 'ğŸ', 'ğŸ¥¨', 'ğŸ¥¯', 'ğŸ§€', 'ğŸ¥š', 'ğŸ³', 'ğŸ§ˆ', 'ğŸ¥', 'ğŸ§‡', 'ğŸ¥“', 'ğŸ¥©', 'ğŸ—', 'ğŸ–', 'ğŸ¦´'
      ],
      
      activities: [
        'âš½', 'ğŸ€', 'ğŸˆ', 'âš¾', 'ğŸ¥', 'ğŸ¾', 'ğŸ', 'ğŸ‰', 'ğŸ¥', 'ğŸ±', 'ğŸª€', 'ğŸ“', 'ğŸ¸', 'ğŸ’', 'ğŸ‘', 'ğŸ¥',
        'ğŸ', 'ğŸªƒ', 'ğŸ¥…', 'â›³', 'ğŸª', 'ğŸ¹', 'ğŸ£', 'ğŸ¤¿', 'ğŸ¥Š', 'ğŸ¥‹', 'ğŸ½', 'ğŸ›¹', 'ğŸ›¼', 'ğŸ›·', 'â›¸ï¸', 'ğŸ¥Œ'
      ],
      
      travel: [
        'ğŸš—', 'ğŸš•', 'ğŸš™', 'ğŸšŒ', 'ğŸš', 'ğŸï¸', 'ğŸš“', 'ğŸš‘', 'ğŸš’', 'ğŸš', 'ğŸ›»', 'ğŸšš', 'ğŸš›', 'ğŸšœ', 'ğŸï¸', 'ğŸ›µ',
        'ğŸš²', 'ğŸ›´', 'ğŸ›¹', 'ğŸ›¼', 'ğŸš', 'ğŸ›¸', 'âœˆï¸', 'ğŸ›©ï¸', 'ğŸ›«', 'ğŸ›¬', 'ğŸª‚', 'ğŸ’º', 'ğŸš€', 'ğŸ›°ï¸', 'ğŸš‰', 'ğŸšŠ'
      ],
      
      objects: [
        'âŒš', 'ğŸ“±', 'ğŸ“²', 'ğŸ’»', 'âŒ¨ï¸', 'ğŸ–¥ï¸', 'ğŸ–¨ï¸', 'ğŸ–±ï¸', 'ğŸ–²ï¸', 'ğŸ•¹ï¸', 'ğŸ—œï¸', 'ğŸ’½', 'ğŸ’¾', 'ğŸ’¿', 'ğŸ“€', 'ğŸ“¼',
        'ğŸ“·', 'ğŸ“¸', 'ğŸ“¹', 'ğŸ¥', 'ğŸ“½ï¸', 'ğŸï¸', 'ğŸ“', 'â˜ï¸', 'ğŸ“Ÿ', 'ğŸ“ ', 'ğŸ“º', 'ğŸ“»', 'ğŸ™ï¸', 'ğŸšï¸', 'ğŸ›ï¸', 'ğŸ§­'
      ],
      
      symbols: [
        'â¤ï¸', 'ğŸ§¡', 'ğŸ’›', 'ğŸ’š', 'ğŸ’™', 'ğŸ’œ', 'ğŸ–¤', 'ğŸ¤', 'ğŸ¤', 'ğŸ’”', 'â£ï¸', 'ğŸ’•', 'ğŸ’', 'ğŸ’“', 'ğŸ’—', 'ğŸ’–',
        'ğŸ’˜', 'ğŸ’', 'ğŸ’Ÿ', 'â˜®ï¸', 'âœï¸', 'â˜ªï¸', 'ğŸ•‰ï¸', 'â˜¸ï¸', 'âœ¡ï¸', 'ğŸ”¯', 'ğŸ•', 'â˜¯ï¸', 'â˜¦ï¸', 'ğŸ›', 'â›', 'â™ˆ'
      ],
      
      flags: [
        'ğŸ‡³ğŸ‡¬', 'ğŸ‡ºğŸ‡¸', 'ğŸ‡¬ğŸ‡§', 'ğŸ‡¨ğŸ‡¦', 'ğŸ‡¦ğŸ‡º', 'ğŸ‡©ğŸ‡ª', 'ğŸ‡«ğŸ‡·', 'ğŸ‡®ğŸ‡¹', 'ğŸ‡ªğŸ‡¸', 'ğŸ‡·ğŸ‡º', 'ğŸ‡¨ğŸ‡³', 'ğŸ‡¯ğŸ‡µ', 'ğŸ‡°ğŸ‡·', 'ğŸ‡®ğŸ‡³', 'ğŸ‡§ğŸ‡·', 'ğŸ‡²ğŸ‡½',
        'ğŸ‡¿ğŸ‡¦', 'ğŸ‡ªğŸ‡¬', 'ğŸ‡°ğŸ‡ª', 'ğŸ‡¬ğŸ‡­', 'ğŸ‡ªğŸ‡¹', 'ğŸ‡²ğŸ‡¦', 'ğŸ‡¹ğŸ‡³', 'ğŸ‡©ğŸ‡¿', 'ğŸ‡±ğŸ‡¾', 'ğŸ‡¸ğŸ‡©', 'ğŸ‡ºğŸ‡¬', 'ğŸ‡¹ğŸ‡¿', 'ğŸ‡·ğŸ‡¼', 'ğŸ‡¿ğŸ‡¼', 'ğŸ‡§ğŸ‡¼', 'ğŸ‡³ğŸ‡¦',
        'ğŸ‡³ğŸ‡±', 'ğŸ‡§ğŸ‡ª', 'ğŸ‡¨ğŸ‡­', 'ğŸ‡¦ğŸ‡¹', 'ğŸ‡µğŸ‡±', 'ğŸ‡¨ğŸ‡¿', 'ğŸ‡­ğŸ‡º', 'ğŸ‡·ğŸ‡´', 'ğŸ‡§ğŸ‡¬', 'ğŸ‡­ğŸ‡·', 'ğŸ‡·ğŸ‡¸', 'ğŸ‡¸ğŸ‡®', 'ğŸ‡¸ğŸ‡°', 'ğŸ‡ºğŸ‡¦', 'ğŸ‡§ğŸ‡¾', 'ğŸ‡±ğŸ‡¹',
        'ğŸ‡¹ğŸ‡­', 'ğŸ‡»ğŸ‡³', 'ğŸ‡µğŸ‡­', 'ğŸ‡®ğŸ‡©', 'ğŸ‡²ğŸ‡¾', 'ğŸ‡¸ğŸ‡¬', 'ğŸ‡§ğŸ‡©', 'ğŸ‡µğŸ‡°', 'ğŸ‡±ğŸ‡°', 'ğŸ‡¦ğŸ‡«', 'ğŸ‡®ğŸ‡·', 'ğŸ‡®ğŸ‡¶', 'ğŸ‡¸ğŸ‡¦', 'ğŸ‡¦ğŸ‡ª', 'ğŸ‡®ğŸ‡±', 'ğŸ‡¹ğŸ‡·',
        'ğŸ', 'ğŸš©', 'ğŸŒ', 'ğŸ´', 'ğŸ³ï¸', 'ğŸ³ï¸â€ğŸŒˆ', 'ğŸ³ï¸â€âš§ï¸', 'ğŸ´â€â˜ ï¸', 'ğŸ‡ºğŸ‡³', 'ğŸ‡ªğŸ‡º'
      ],
      
      coding: [
        'ğŸ’»', 'ğŸ–¥ï¸', 'âŒ¨ï¸', 'ğŸ–±ï¸', 'ğŸ–²ï¸', 'ğŸ’¾', 'ğŸ’¿', 'ğŸ“€', 'ğŸ§®', 'ğŸ“±', 'ğŸ“²', 'â˜ï¸', 'ğŸ“', 'ğŸ“Ÿ', 'ğŸ“ ', 'ğŸ“¡',
        'âš¡', 'ğŸ”Œ', 'ğŸ”‹', 'ğŸª«', 'ğŸ’¡', 'ğŸ”¦', 'ğŸ•¯ï¸', 'ğŸ§¯', 'âš™ï¸', 'ğŸ”§', 'ğŸ”¨', 'âš’ï¸', 'ğŸ› ï¸', 'â›ï¸', 'ğŸ”©', 'âš—ï¸',
        'ğŸ”¢', 'ğŸ”£', 'ğŸ”¤', 'ğŸ”¡', 'ğŸ” ', '#ï¸âƒ£', '*ï¸âƒ£', '0ï¸âƒ£', '1ï¸âƒ£', '2ï¸âƒ£', '3ï¸âƒ£', '4ï¸âƒ£', '5ï¸âƒ£', '6ï¸âƒ£', '7ï¸âƒ£', '8ï¸âƒ£',
        '9ï¸âƒ£', 'ğŸ”Ÿ', 'ğŸ’¯', 'â•', 'â–', 'âœ–ï¸', 'â—', 'â™¾ï¸', 'â€¼ï¸', 'â‰ï¸', 'â“', 'â”', 'â—', 'â•', 'ã€°ï¸', 'ğŸ”€',
        'â¬†ï¸', 'â†—ï¸', 'â¡ï¸', 'â†˜ï¸', 'â¬‡ï¸', 'â†™ï¸', 'â¬…ï¸', 'â†–ï¸', 'â†•ï¸', 'â†”ï¸', 'â†©ï¸', 'â†ªï¸', 'â¤´ï¸', 'â¤µï¸', 'ğŸ”„', 'ğŸ”ƒ',
        'â–¶ï¸', 'â¸ï¸', 'â¹ï¸', 'âºï¸', 'â­ï¸', 'â®ï¸', 'â©', 'âª', 'â«', 'â¬', 'ğŸ”¼', 'ğŸ”½', 'â—€ï¸', 'ğŸ”', 'ğŸ”‚', 'ğŸ”€'
      ]
    };
    
    const emojis = emojiSets[categoryName] || emojiSets.recent;
    
    grid.innerHTML = emojis.map(emoji => 
      `<button class="emoji-option" data-emoji="${emoji}">${emoji}</button>`
    ).join('');
  }

  showGlobalEmojiPicker(btn) {
    const picker = document.getElementById('global-emoji-picker');
    if (!picker) return;
    
    const btnRect = btn.getBoundingClientRect();
    const pickerWidth = 320;
    const pickerHeight = 300;
    
    let left = btnRect.left;
    let top = btnRect.top - pickerHeight - 8;
    
    if (left + pickerWidth > window.innerWidth) {
      left = window.innerWidth - pickerWidth - 20;
    }
    if (left < 20) {
      left = 20;
    }
    
    if (top < 20) {
      top = btnRect.bottom + 8;
    }
    
    picker.style.left = `${left}px`;
    picker.style.top = `${top}px`;
    picker.style.display = 'block';
    this.emojiPickerVisible = true;
  }

  hideGlobalEmojiPicker() {
    const picker = document.getElementById('global-emoji-picker');
    if (picker) {
      picker.style.display = 'none';
    }
    
    this.currentEmojiForm = null;
    this.currentEmojiTextarea = null;
    this.emojiPickerVisible = false;
  }

  closeAllEmojiPickers() {
    this.hideGlobalEmojiPicker();
    
    document.querySelectorAll('.emoji-picker, .inline-emoji-picker').forEach(picker => {
      picker.classList.remove('show');
      picker.style.display = 'none';
      picker.style.visibility = 'hidden';
      picker.style.opacity = '0';
    });
    
    this.emojiPickerVisible = false;
  }

setupCommentActions() {
  document.addEventListener('click', (e) => {
    // Reply buttons
    if (e.target.closest('.reply-btn')) {
      e.preventDefault();
      const btn = e.target.closest('.reply-btn');
      this.handleInlineReplySetup(btn.dataset.commentId, btn.dataset.author);
    }

    // Vote buttons  
    if (e.target.closest('.vote-btn')) {
      e.preventDefault();
      const btn = e.target.closest('.vote-btn');
      this.handleVote(btn.dataset.commentId, btn.dataset.action || 'upvote');
    }

    // Reaction buttons
    if (e.target.closest('.reaction-btn')) {
      e.preventDefault();
      const btn = e.target.closest('.reaction-btn');
      this.handleReaction(btn.dataset.commentId, btn.dataset.reaction);
    }

    // âœ… UPDATED: Menu buttons with mobile positioning
    if (e.target.closest('.menu-btn')) {
      e.preventDefault();
      const btn = e.target.closest('.menu-btn');
      const commentId = btn.dataset.commentId;
      
      // âœ… ADD MOBILE MENU POSITIONING
      const dropdown = document.getElementById(`dropdown-${commentId}`);
      if (dropdown) {
        // Check if dropdown would go off-screen on mobile
        const btnRect = btn.getBoundingClientRect();
        const viewportWidth = window.innerWidth;
        
        // If button is in the right half of screen on mobile, flip menu left
        if (viewportWidth <= 768 && btnRect.right > viewportWidth * 0.7) {
          btn.closest('.comment-actions-menu').classList.add('flip-left');
        } else {
          btn.closest('.comment-actions-menu').classList.remove('flip-left');
        }
      }
      
      this.toggleDropdown(commentId);
    }

    // Edit buttons
    if (e.target.closest('.edit-comment-btn')) {
      e.preventDefault();
      const btn = e.target.closest('.edit-comment-btn');
      this.handleInlineEditSetup(btn.dataset.commentId);
    }

      // Delete buttons
      if (e.target.closest('.delete-comment-btn')) {
        e.preventDefault();
        const btn = e.target.closest('.delete-comment-btn');
        this.handleDeleteSetup(btn.dataset.commentId);
      }

      // Report buttons
      if (e.target.closest('.report-btn')) {
        e.preventDefault();
        const btn = e.target.closest('.report-btn');
        this.handleReportSetup(btn.dataset.commentId);
      }

      // Bookmark and copy buttons
      if (e.target.closest('.bookmark-btn')) {
        e.preventDefault();
        const btn = e.target.closest('.bookmark-btn');
        this.handleBookmark(btn.dataset.commentId);
      }

      if (e.target.closest('.copy-btn')) {
        e.preventDefault();
        const btn = e.target.closest('.copy-btn');
        this.handleCopy(btn.dataset.commentId);
      }
    });
  }

  setupSorting() {
    const sortSelect = document.getElementById('sort-select');
    if (sortSelect) {
      sortSelect.addEventListener('change', (e) => {
        this.currentSort = e.target.value;
        this.sortComments(e.target.value);
      });
    }
  }

  setupLoadMore() {
    const loadMoreBtn = document.getElementById('load-more-btn');
    if (loadMoreBtn) {
      // Remove any existing listeners first
      const newBtn = loadMoreBtn.cloneNode(true);
      loadMoreBtn.parentNode?.replaceChild(newBtn, loadMoreBtn);
      
      // Add the event listener with proper error handling
      newBtn.addEventListener('click', async (e) => {
        e.preventDefault();
        e.stopPropagation();
        
        try {
          await this.loadMoreComments();
        } catch (error) {
          debugLog('âŒ Load more error:', error);
          showUserError('Failed to load more comments. Please try again.');
        }
      });
    }
    
    // Setup load more replies buttons
    document.addEventListener('click', async (e) => {
      if (e.target.closest('.load-more-replies-btn')) {
        e.preventDefault();
        e.stopPropagation();
        
        const btn = e.target.closest('.load-more-replies-btn');
        const commentId = btn.dataset.commentId;
        const currentlyLoaded = parseInt(btn.dataset.loaded || '0');
        
        if (commentId) {
          try {
            await this.loadMoreReplies(commentId, currentlyLoaded);
          } catch (error) {
            debugLog('âŒ Load more replies error:', error);
            showUserError('Failed to load more replies. Please try again.');
          }
        }
      }
    });
  }

  // âœ… OPTIMIZED COMMENT SUBMISSION
async handleCommentSubmit(e) {
  e.preventDefault();
  e.stopPropagation();
  
  await this.ensureAuth();
  
  if (!this.isAuthenticated || !this.currentUser) {
    showUserError('Please sign in to comment');
    return;
  }

  if (this.isSubmitting) return;
  this.isSubmitting = true;

  const form = e.target;
  const formData = new FormData(form);
  const content = formData.get('content')?.trim();

  if (!this.validateComment(content)) {
    this.isSubmitting = false;
    return;
  }

  const submitBtn = form.querySelector('.submit-btn');
  if (submitBtn) submitBtn.disabled = true;
  this.showLoading(form);

  try {
    const result = await this.callAPI('addComment', [
      this.articleId,
      content, 
      this.replyingTo?.id || null
    ]);

    if (result && result.success) {
      if (['auto_approved', 'approved'].includes(result.data?.moderation_status)) {
        showUserSuccess('Comment posted successfully!');
        
        // âœ… ADD JUST THIS ONE LINE - Simple caching
        this.addToPageCache(result.data, this.replyingTo?.id || null);
        
        this.addCommentToUI(result.data);
      } else {
        showUserSuccess('Comment submitted and pending approval!');
      }
      
      this.resetForm(form);
      this.clearDraft();
      this.updateCommentCount(1);
      this.resetFormState(form);
    } else {
      showUserError(result?.error || 'Failed to post comment');
    }
  } catch (error) {
    showUserError('Failed to post comment. Please try again.');
  } finally {
    this.hideLoading(form);
    this.isSubmitting = false;
    if (submitBtn) submitBtn.disabled = false;
  }
}

// âœ… SIMPLE: update the page's data attribute
addToPageCache(newComment, parentId = null) {
  try {
    const commentSection = document.getElementById('comments-section');
    if (!commentSection) return;
    
    let allComments = JSON.parse(commentSection.dataset.allComments || '[]');
    
    if (parentId) {
      // Add as reply
      this.addReplyToTree(allComments, newComment, parentId);
    } else {
      // Add as root comment
      allComments.unshift(newComment);
    }
    
    // Update the page data
    commentSection.dataset.allComments = JSON.stringify(allComments);
    
    // Update count
    const totalComments = parseInt(commentSection.dataset.totalComments || '0');
    commentSection.dataset.totalComments = (totalComments + 1).toString();
    
    debugLog('âœ… Updated page cache');
    
  } catch (error) {
    debugLog('âŒ Cache update failed:', error);
  }
}

  // Inline reply setup with optimized auth check
  async handleInlineReplySetup(commentId, author) {
    await this.ensureAuth();
    
    if (!this.isAuthenticated) {
      window.location.href = '/auth/signin';
      return;
    }

    const container = document.querySelector(`[data-comment-id="${commentId}"] .inline-reply-container`);
    if (!container) return;

    const template = document.getElementById('inline-reply-template');
    const clone = template.content.cloneNode(true);

    const authorName = clone.querySelector('.reply-author-name');
    if (authorName) authorName.textContent = author;

    const userAvatar = clone.querySelector('.inline-user-avatar');
    const userName = clone.querySelector('.inline-user-name');
    
    if (userAvatar && this.profile) {
      userAvatar.innerHTML = `<img src="${this.getUserAvatar(this.profile)}" alt="${this.profile.display_name}" />`;
    }
    
    if (userName && this.profile) {
      userName.textContent = this.profile.display_name || 'User';
    }

    const form = clone.querySelector('.inline-comment-form');
    form.dataset.commentId = commentId;
    form.dataset.articleId = this.articleId;

    const textarea = clone.querySelector('.inline-textarea');
    const charCount = clone.querySelector('.inline-char-count .count');
    
    textarea.addEventListener('input', () => {
      const count = textarea.value.length;
      charCount.textContent = count;
      
      if (count > 800) {
        charCount.style.color = 'var(--warning-color)';
      } else if (count >= 1000) {
        charCount.style.color = 'var(--error-color)';
      } else {
        charCount.style.color = 'var(--text-secondary)';
      }
    });

    container.innerHTML = '';
    container.appendChild(clone);
    container.style.display = 'block';
    textarea.focus();
  }

  // Inline reply submission with optimized auth check
  async handleInlineReply(form) {
  await this.ensureAuth();
  
  if (!this.isAuthenticated) return;

  const formData = new FormData(form);
  const content = formData.get('content').trim();
  const commentId = form.dataset.commentId;

  if (!this.validateComment(content)) return;

  this.showLoading(form);

  try {
    const result = await this.callAPI('addComment', [
      this.articleId, 
      content, 
      commentId
    ]);

    if (result.success) {
      showUserSuccess('Reply posted successfully!');
      
      const container = form.closest('.inline-reply-container');
      if (container) {
        container.style.display = 'none';
        container.innerHTML = '';
      }
      
      // âœ… ADD TO CACHED TREE BEFORE ADDING TO UI
      this.updateCachedCommentTree(result.data, commentId);
      
      this.addReplyToUI(result.data, commentId);
      this.updateCommentCount(1);
    } else {
      showUserError(result.error || 'Failed to post reply');
    }
  } catch (error) {
    debugLog('âŒ Reply submission error:', error);
    showUserError('Network error. Please try again.');
  } finally {
    this.hideLoading(form);
  }
}

  // Inline edit setup with optimized auth check
  async handleInlineEditSetup(commentId) {
    await this.ensureAuth();
    
    if (!this.isAuthenticated) return;

    const container = document.querySelector(`[data-comment-id="${commentId}"] .inline-edit-container`);
    const commentCard = this.getCommentCardElement(commentId);
    
    if (!container || !commentCard) return;

    const commentText = commentCard.querySelector('.comment-text')?.textContent || '';

    const template = document.getElementById('inline-edit-template');
    const clone = template.content.cloneNode(true);

    const form = clone.querySelector('.edit-comment-form-inline');
    form.dataset.commentId = commentId;

    const textarea = clone.querySelector('.edit-textarea');
    textarea.value = commentText;

    const charCount = clone.querySelector('.edit-char-count .count');
    charCount.textContent = commentText.length;

    textarea.addEventListener('input', () => {
      const count = textarea.value.length;
      charCount.textContent = count;
      
      if (count > 800) {
        charCount.style.color = 'var(--warning-color)';
      } else if (count >= 1000) {
        charCount.style.color = 'var(--error-color)';
      } else {
        charCount.style.color = 'var(--text-secondary)';
      }
    });

    container.innerHTML = '';
    container.appendChild(clone);
    container.style.display = 'block';
    textarea.focus();
    textarea.setSelectionRange(textarea.value.length, textarea.value.length);
  }

  // Inline edit submission with optimized auth check
  async handleInlineEdit(form) {
    await this.ensureAuth();
    
    if (!this.isAuthenticated) return;

    const formData = new FormData(form);
    const content = formData.get('content').trim();
    const editReason = formData.get('edit_reason');
    const commentId = form.dataset.commentId;

    if (!this.validateComment(content)) return;

    this.showLoading(form);

    try {
      const result = await this.callAPI('updateComment', [commentId, content, editReason]);

      if (result.success) {
        showUserSuccess('Comment updated successfully!');
        
        const container = form.closest('.inline-edit-container');
        if (container) {
          container.style.display = 'none';
          container.innerHTML = '';
        }
        
        this.updateCommentInUI(result.data);
      } else {
        showUserError(result.error || 'Failed to update comment');
      }
    } catch (error) {
      debugLog('âŒ Edit submission error:', error);
      showUserError('Network error. Please try again.');
    } finally {
      this.hideLoading(form);
    }
  }

  // Vote handling with optimized auth check
  async handleVote(commentId, action = 'upvote') {
    await this.ensureAuth();
    
    if (!this.isAuthenticated) {
      window.location.href = '/auth/signin';
      return;
    }

    try {
      const result = await this.callAPI('toggleCommentLike', [commentId]);
      
      if (result.success) {
        this.updateVoteUI(commentId, result);
      } else {
        showUserError(result.error || 'Failed to vote');
      }
    } catch (error) {
      debugLog('âŒ Vote error:', error);
      showUserError('Network error. Please try again.');
    }
  }

  // Reaction handling with optimized auth check
  async handleReaction(commentId, reactionType) {
    await this.ensureAuth();
    
    if (!this.isAuthenticated) {
      window.location.href = '/auth/signin';
      return;
    }

    try {
      const result = await this.callAPI('toggleCommentReaction', [commentId, reactionType]);
      
      if (result.success) {
        this.updateReactionUI(commentId, reactionType, result);
      } else {
        showUserError(result.error || 'Failed to react');
      }
    } catch (error) {
      debugLog('âŒ Reaction error:', error);
      showUserError('Network error. Please try again.');
    }
  }

  // Bookmark handling with optimized auth check
  async handleBookmark(commentId) {
    await this.ensureAuth();
    
    if (!this.isAuthenticated) {
      window.location.href = '/auth/signin';
      return;
    }

    try {
      const result = await this.callAPI('toggleCommentBookmark', [commentId]);
      
      if (result.success) {
        this.updateBookmarkUI(commentId, result.bookmarked);
        showUserSuccess(result.bookmarked ? 'Comment bookmarked!' : 'Bookmark removed!');
      } else {
        showUserError(result.error || 'Failed to bookmark');
      }
    } catch (error) {
      debugLog('âŒ Bookmark error:', error);
      showUserError('Network error. Please try again.');
    }
  }

  // Copy handling
  async handleCopy(commentId) {
    const commentCard = this.getCommentCardElement(commentId);
    const commentText = commentCard?.querySelector('.comment-text')?.textContent || '';

    if (!commentText) return;

    try {
      await navigator.clipboard.writeText(commentText);
      showUserSuccess('Comment copied to clipboard!');
    } catch (error) {
      debugLog('âŒ Copy error:', error);
      showUserError('Failed to copy comment');
    }
  }

  // Delete setup
  handleDeleteSetup(commentId) {
    if (!commentId) {
      return;
    }

    const commentCard = this.getCommentCardElement(commentId);
    if (!commentCard) {
      return;
    }

    const commentText = commentCard.querySelector('.comment-text')?.textContent || '';

    const preview = document.getElementById('delete-comment-preview');
    const confirmBtn = document.getElementById('confirm-delete');

    if (preview) {
      preview.textContent = commentText.substring(0, 100) + (commentText.length > 100 ? '...' : '');
    }

    if (confirmBtn) {
      confirmBtn.dataset.commentId = commentId;
    }

    this.showModal('delete-modal');
  }

  // Delete confirmation
  async confirmDelete() {
    const confirmBtn = document.getElementById('confirm-delete');
    const commentId = confirmBtn?.dataset.commentId;

    if (!commentId) {
      showUserError('Error: No comment ID found');
      return;
    }

    this.showLoading(confirmBtn.closest('.modal-actions'));

    try {
      const result = await this.callAPI('deleteComment', [commentId]);

      if (result.success) {
        showUserSuccess('Comment deleted successfully!');
        this.removeCommentFromUI(commentId);
        this.updateCommentCount(-1);
        this.hideModal('delete-modal');
        confirmBtn.dataset.commentId = '';
      } else {
        showUserError(result.error || 'Failed to delete comment');
      }
    } catch (error) {
      debugLog('âŒ Delete error:', error);
      showUserError('Network error. Please try again.');
    } finally {
      this.hideLoading(confirmBtn.closest('.modal-actions'));
    }
  }

  // Report setup
  handleReportSetup(commentId) {
    const confirmBtn = document.getElementById('confirm-report');

    if (confirmBtn) {
      confirmBtn.dataset.commentId = commentId;
    }

    const reportModal = document.getElementById('report-modal');
    const reportReasons = reportModal.querySelectorAll('input[name="report-reason"]');
    reportReasons.forEach(radio => radio.checked = false);

    const reportDetails = document.getElementById('report-details');
    if (reportDetails) reportDetails.value = '';

    this.showModal('report-modal');
  }

  // Report confirmation
  async confirmReport() {
    const confirmBtn = document.getElementById('confirm-report');
    const commentId = confirmBtn?.dataset.commentId;

    if (!commentId) return;

    const selectedReason = document.querySelector('input[name="report-reason"]:checked');
    const details = document.getElementById('report-details')?.value || '';

    if (!selectedReason) {
      showUserError('Please select a reason for reporting');
      return;
    }

    this.showLoading(confirmBtn.closest('.modal-actions'));

    try {
      showUserSuccess('Comment reported successfully!');
      this.hideModal('report-modal');
    } catch (error) {
      debugLog('âŒ Report error:', error);
      showUserError('Network error. Please try again.');
    } finally {
      this.hideLoading(confirmBtn.closest('.modal-actions'));
    }
  }

  // UI Update Methods
  updateVoteUI(commentId, voteData) {
    const commentCard = this.getCommentCardElement(commentId);
    if (!commentCard) return;

    const voteBtn = commentCard.querySelector('.vote-btn');
    const voteCount = commentCard.querySelector('.vote-count');

    if (voteBtn) {
      voteBtn.classList.toggle('active', voteData.liked);
    }

    if (voteCount) {
      const currentCount = parseInt(voteCount.textContent) || 0;
      voteCount.textContent = voteData.liked ? currentCount + 1 : currentCount - 1;
    }
  }

  updateReactionUI(commentId, reactionType, reactionData) {
    const reactionBtn = document.querySelector(`[data-comment-id="${commentId}"] .reaction-btn[data-reaction="${reactionType}"]`);
    const countElement = document.getElementById(`reaction-${reactionType}-${commentId}`);
    
    if (reactionBtn) {
      reactionBtn.classList.toggle('active', reactionData.reacted);
    }
    
    if (countElement) {
      countElement.textContent = reactionData.count || 0;
    }
  }

  updateBookmarkUI(commentId, bookmarked) {
    const bookmarkBtn = document.querySelector(`[data-comment-id="${commentId}"] .bookmark-btn`);
    if (bookmarkBtn) {
      bookmarkBtn.classList.toggle('active', bookmarked);
      const svg = bookmarkBtn.querySelector('svg');
      if (svg) {
        svg.style.fill = bookmarked ? 'currentColor' : 'none';
      }
    }
  }

  updateCommentInUI(commentData) {
    const commentCard = document.querySelector(`[data-comment-id="${commentData.id}"]`);
    if (!commentCard) return;

    const commentText = commentCard.querySelector('.comment-text');
    if (commentText) {
      commentText.innerHTML = this.formatContent(commentData.content);
    }

    const userDetails = commentCard.querySelector('.user-details');
    if (userDetails && !userDetails.querySelector('.edit-indicator')) {
      const editIndicator = document.createElement('span');
      editIndicator.className = 'edit-indicator';
      editIndicator.title = 'This comment has been edited';
      editIndicator.textContent = '(edited)';
      userDetails.appendChild(editIndicator);
    }
  }

addCommentToUI(commentData) {
  if (commentData.moderation_status === 'pending' && commentData.user_id !== this.currentUser?.id) {
    return;
  }

  setTimeout(() => {
    this.syncCommentsWithDatabase();
  }, 1000);
  
  let commentsContainer = this.getMainCommentsContainer();
  
  if (!commentsContainer) {
    const commentsSection = document.getElementById('comments-section');
    if (commentsSection) {
      let commentsList = commentsSection.querySelector('.comments-list');
      if (!commentsList) {
        commentsList = document.createElement('div');
        commentsList.className = 'comments-list';
        commentsList.id = 'comments-list';
        commentsSection.appendChild(commentsList);
      }
      
      commentsContainer = document.createElement('div');
      commentsContainer.className = 'comments-items';
      commentsContainer.id = 'comments-items';
      commentsList.appendChild(commentsContainer);
    } else {
      return;
    }
  }

  // Hide empty state
  const emptyState = document.getElementById('empty-state') || 
                    document.querySelector('.empty-state');
  
  if (emptyState) {
    emptyState.style.display = 'none';
  }

  // âœ… USE CURRENT USER'S PROFILE DATA
  const userProfile = this.profile || {
    display_name: this.currentUser?.email?.split('@')[0] || 'User',
    avatar_type: 'preset',
    avatar_preset_id: 1,
    avatar_url: null,
    is_admin: false,
    membership_type: 'free'
  };

  // Create the comment element
// Create the comment element
const commentElement = document.createElement('div');
commentElement.className = commentData.parent_id ? 'comment-wrapper reply-wrapper' : 'comment-wrapper';
commentElement.dataset.commentId = commentData.id;

const threadLevel = commentData.thread_level || 0;
const avatarUrl = this.getUserAvatar(userProfile);
const formattedContent = this.formatContent(commentData.content);
const displayName = userProfile.display_name || 'User';

commentElement.innerHTML = `
  <div class="comment-card ${commentData.parent_id ? 'reply-card' : ''}" 
       data-comment-id="${commentData.id}" 
       data-user-id="${this.currentUser.id}"
       data-created-at="${commentData.created_at}"
       data-thread-level="${threadLevel}">
    
    ${commentData.parent_id ? '<div class="reply-connector"></div>' : ''}
    
    <!-- FIXED COMMENT HEADER - Single Horizontal Line -->
    <div class="comment-header">
      <div class="comment-user-info">
        <div class="comment-avatar">
          <img src="${avatarUrl}" alt="${displayName}" loading="lazy" />
          ${userProfile.is_admin ? '<div class="admin-badge">ğŸ‘‘</div>' : ''}
        </div>
        <!-- FIXED: Flattened structure for single-line layout -->
        <div class="comment-meta">
          <div class="user-details">
            <span class="username ${userProfile.is_admin ? 'admin' : ''}">${displayName}</span>
            <!-- FIXED: Time wrapper at same level as username -->
            <div class="comment-time-wrapper">
              <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <circle cx="12" cy="12" r="10"></circle>
                <polyline points="12,6 12,12 16,14"></polyline>
              </svg>
              <span class="comment-time" title="${new Date(commentData.created_at).toLocaleString()}">
                Just now
              </span>
            </div>
            ${commentData.is_edited ? '<span class="edit-indicator" title="This comment has been edited">(edited)</span>' : ''}
          </div>
        </div>
      </div>
      
      <div class="comment-actions-menu">
        <button class="menu-btn" data-comment-id="${commentData.id}" aria-label="Comment options">
          <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <circle cx="12" cy="12" r="1"></circle>
            <circle cx="19" cy="12" r="1"></circle>
            <circle cx="5" cy="12" r="1"></circle>
          </svg>
        </button>
        <div class="dropdown-menu" id="dropdown-${commentData.id}">
          <button class="dropdown-item edit-comment-btn" data-comment-id="${commentData.id}" style="display: none;">
            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"></path>
              <path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"></path>
            </svg>
            Edit
          </button>
          <button class="dropdown-item delete-comment-btn" data-comment-id="${commentData.id}" style="display: none;">
            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <polyline points="3,6 5,6 21,6"></polyline>
              <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2 2h4a2 2 0 0 1 2 2v2"></path>
            </svg>
            Delete
          </button>
          <button class="dropdown-item history-btn" data-comment-id="${commentData.id}" style="display: flex;">
            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <path d="M3 3v5h5"></path>
              <path d="M3.05 13A9 9 0 1 0 6 5.3L3 8"></path>
              <path d="M12 7v5l4 2"></path>
            </svg>
            History
          </button>
          <button class="dropdown-item report-btn" data-comment-id="${commentData.id}" style="display: flex;">
            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <path d="M4 15s1-1 4-1 5 2 8 2 4-1 4-1V3s-1 1-4 1-5-2-8-2-4 1-4 1z"></path>
              <line x1="4" y1="22" x2="4" y2="15"></line>
            </svg>
            Report
          </button>
        </div>
      </div>
    </div>

    <div class="comment-content">
      <div class="comment-text">${formattedContent}</div>
    </div>

    <!-- FIXED COMMENT FOOTER - Single Horizontal Line -->
    <div class="comment-footer">
      <!-- FIXED: Changed to comment-voting and proper structure -->
      <div class="comment-voting">
        <button class="vote-btn upvote-btn" data-comment-id="${commentData.id}" data-action="upvote" title="Upvote" aria-label="Upvote comment">
          <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M7 14l5-5 5 5"></path>
          </svg>
        </button>
        <span class="vote-count" id="vote-count-${commentData.id}">${commentData.like_count || 0}</span>
        <button class="vote-btn downvote-btn" data-comment-id="${commentData.id}" data-action="downvote" title="Downvote" aria-label="Downvote comment">
          <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M17 10l-5 5-5-5"></path>
          </svg>
        </button>
      </div>
      
      <!-- Reactions -->
      <div class="comment-reactions">
        <button class="reaction-btn" data-reaction="like" data-comment-id="${commentData.id}" title="React with thumbs up" aria-label="React with thumbs up">
          <span class="reaction-emoji">ğŸ‘</span>
          <span class="reaction-count" id="reaction-like-${commentData.id}">0</span>
        </button>
        <button class="reaction-btn" data-reaction="love" data-comment-id="${commentData.id}" title="React with heart" aria-label="React with heart">
          <span class="reaction-emoji">â¤ï¸</span>
          <span class="reaction-count" id="reaction-love-${commentData.id}">0</span>
        </button>
        <button class="reaction-btn" data-reaction="laugh" data-comment-id="${commentData.id}" title="React with laugh" aria-label="React with laugh">
          <span class="reaction-emoji">ğŸ˜‚</span>
          <span class="reaction-count" id="reaction-laugh-${commentData.id}">0</span>
        </button>
      </div>
      
      <!-- Actions -->
      <div class="comment-actions">
        ${threadLevel < 4 ? `
        <button class="action-btn reply-btn" data-comment-id="${commentData.id}" data-author="${displayName}" title="Reply to this comment" aria-label="Reply to comment">
          <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <polyline points="9,17 4,12 9,7"></polyline>
            <path d="M20 18v-2a4 4 0 0 0-4-4H4"></path>
          </svg>
          Reply
        </button>
        ` : ''}
        
        <button class="action-btn bookmark-btn" data-comment-id="${commentData.id}" title="Bookmark this comment" aria-label="Bookmark comment">
          <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M19 21l-7-5-7 5V5a2 2 0 0 1 2-2h10a2 2 0 0 1 2 2z"></path>
          </svg>
          Save
        </button>
        
        <button class="action-btn copy-btn" data-comment-id="${commentData.id}" title="Copy comment link" aria-label="Copy comment link">
          <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path>
            <path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path>
          </svg>
          Copy
        </button>
        
        <button class="action-btn share-btn" data-comment-id="${commentData.id}" title="Share comment" aria-label="Share comment">
          <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M4 12v8a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2v-8"></path>
            <polyline points="16,6 12,2 8,6"></polyline>
            <line x1="12" y1="2" x2="12" y2="15"></line>
          </svg>
          Share
        </button>
      </div>
    </div>

    <div class="inline-reply-container" data-comment-id="${commentData.id}" style="display: none;"></div>
    <div class="inline-edit-container" data-comment-id="${commentData.id}" style="display: none;"></div>
    <div class="comment-replies"></div>
  </div>
`;

// Add to the appropriate container
if (commentData.parent_id) {
  // This is a reply - find parent and add to its replies container
  const parentComment = document.querySelector(`[data-comment-id="${commentData.parent_id}"]`);
  if (parentComment) {
    let repliesContainer = parentComment.querySelector('.comment-replies');
    if (!repliesContainer) {
      repliesContainer = document.createElement('div');
      repliesContainer.className = 'comment-replies';
      parentComment.appendChild(repliesContainer);
    }
    repliesContainer.appendChild(commentElement);
  } else {
    // Parent not found, add to main container
    commentsContainer.appendChild(commentElement);
  }
} else {
  commentsContainer.insertBefore(commentElement, commentsContainer.firstChild);
}

// Highlight the new comment
const commentCard = commentElement.querySelector('.comment-card');
commentCard.classList.add('new-comment');

setTimeout(() => {
  commentCard.classList.remove('new-comment');
}, 3000);

// Scroll to the new comment
commentElement.scrollIntoView({ 
  behavior: 'smooth', 
  block: 'center' 
});

// Update permissions for the new comment
this.updateCommentPermissions(commentData.id);
  
if (!commentData.parent_id) {
  this.totalComments++;
  this.loadedComments++;
  
  const totalCountElement = document.getElementById('total-count');
  const threadCount = document.getElementById('total-comments');
  
  if (totalCountElement) totalCountElement.textContent = this.totalComments;
  if (threadCount) threadCount.textContent = this.totalComments;
  
  this.updateLoadMoreUI();
}
}

  async syncCommentsWithDatabase() {
    try {
      const result = await this.callAPI('getComments', [this.articleId]);
      if (result.success) {
        this.updateCommentCount(result.data.length);
      }
    } catch (error) {
      debugLog('âŒ Failed to sync comments:', error);
    }
  }

getMainCommentsContainer() {
  // âœ… TRY MULTIPLE SELECTORS TO FIND THE CONTAINER
  let commentsContainer = document.getElementById('comments-items');
  
  if (!commentsContainer) {
    commentsContainer = document.getElementById('comments-list');
  }
  
  if (!commentsContainer) {
    commentsContainer = document.querySelector('.comments-items');
  }
  
  if (!commentsContainer) {
    commentsContainer = document.querySelector('.comments-list');
  }
  
  if (!commentsContainer) {
    commentsContainer = document.querySelector('.comments-container .comments-list .comments-items');
  }
  
  if (!commentsContainer) {
    debugLog('âŒ Trying to create comments container...');
    const commentsSection = document.getElementById('comments-section');
    if (commentsSection) {
      const commentsList = commentsSection.querySelector('.comments-list');
      if (commentsList) {
        commentsContainer = document.createElement('div');
        commentsContainer.id = 'comments-items';
        commentsContainer.className = 'comments-items';
        commentsList.appendChild(commentsContainer);
        debugLog('âœ… Created comments container');
      }
    }
  }
  
  if (commentsContainer) {
    debugLog('âœ… Found comments container:', commentsContainer.id || commentsContainer.className);
  } else {
    debugLog('âŒ Could not find or create comments container');
  }
  
  return commentsContainer;
}

// THE addReplyToUI METHOD:
addReplyToUI(replyData, parentId) {
  debugLog('ğŸ”„ Adding reply to UI:', {
    replyId: replyData.id,
    parentId: parentId,
    content: replyData.content.substring(0, 30)
  });

  // âœ… BETTER PARENT FINDING - Look for the comment card first, then get its wrapper
  const parentCommentCard = document.querySelector(`[data-comment-id="${parentId}"]`);
  
  if (!parentCommentCard) {
    console.warn('âŒ Parent comment card not found for reply:', parentId);
    // Fallback: add to main comments container
    this.addCommentToUI(replyData);
    return;
  }

  // Get the parent wrapper that contains the comment card
  const parentWrapper = parentCommentCard.closest('.comment-wrapper');
  
  if (!parentWrapper) {
    console.warn('âŒ Parent wrapper not found for reply:', parentId);
    this.addCommentToUI(replyData);
    return;
  }

  // âœ… CALCULATE PROPER THREAD LEVEL
  const parentLevel = parseInt(parentCommentCard.dataset.threadLevel || '0');
  const replyLevel = Math.min(parentLevel + 1, 4);
  
  debugLog('ğŸ§µ Threading info:', {
    parentLevel,
    replyLevel,
    parentId,
    replyId: replyData.id
  });

  // âœ… FIND OR CREATE REPLIES CONTAINER - Look for direct child only
  let repliesContainer = parentWrapper.querySelector(':scope > .comment-replies, :scope > .replies-container');
  
  if (!repliesContainer) {
    repliesContainer = document.createElement('div');
    repliesContainer.className = 'comment-replies replies-container';
    
    // âœ… INSERT AFTER INLINE CONTAINERS BUT BEFORE ANY EXISTING REPLIES
    const inlineContainers = parentWrapper.querySelectorAll('.inline-reply-container, .inline-edit-container');
    const lastInlineContainer = inlineContainers[inlineContainers.length - 1];
    
    if (lastInlineContainer) {
      lastInlineContainer.insertAdjacentElement('afterend', repliesContainer);
    } else {
      parentWrapper.appendChild(repliesContainer);
    }
    
    debugLog('âœ… Created new replies container for parent:', parentId);
  }

  // Use current user's profile data
  const displayName = this.profile?.display_name || this.currentUser?.email?.split('@')[0] || 'User';
  const avatarUrl = this.getUserAvatar(this.profile);
  const isAdmin = this.profile?.is_admin || false;
  const membershipType = this.profile?.membership_type || 'free';
  
  // âœ… CREATE REPLY WRAPPER WITH PROPER STRUCTURE
  const replyWrapper = document.createElement('div');
  replyWrapper.className = 'comment-wrapper reply-wrapper';
  replyWrapper.dataset.commentId = replyData.id;
  
  // âœ… ADD VISUAL INDENTATION BASED ON THREAD LEVEL
  replyWrapper.style.marginLeft = `${replyLevel * 20}px`;
  
  replyWrapper.innerHTML = `
    <div class="comment-card reply-card" 
         data-comment-id="${replyData.id}" 
         data-user-id="${this.currentUser.id}" 
         data-created-at="${replyData.created_at}"
         data-thread-level="${replyLevel}">
      <div class="reply-connector"></div>
      
      <div class="comment-header">
        <div class="comment-user-info">
          <div class="comment-avatar">
            <img src="${avatarUrl}" alt="${displayName}" loading="lazy" />
            ${isAdmin ? '<div class="admin-badge">ğŸ‘‘</div>' : ''}
          </div>
          <div class="comment-meta">
            <div class="user-details">
              <span class="username ${isAdmin ? 'admin' : ''}">${displayName}</span>
              ${isAdmin ? '<span class="admin-badge">Admin</span>' : ''}
              ${membershipType === 'premium' ? '<span class="premium-badge">Premium</span>' : ''}
            </div>
            <div class="comment-time-wrapper">
              <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <circle cx="12" cy="12" r="10"></circle>
                <polyline points="12,6 12,12 16,14"></polyline>
              </svg>
              <span class="comment-time" title="${new Date(replyData.created_at).toLocaleString()}">Just now</span>
            </div>
          </div>
        </div>
        
        <div class="comment-actions-menu">
          <button class="menu-btn" data-comment-id="${replyData.id}" aria-label="Reply options">
            <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <circle cx="12" cy="12" r="1"></circle>
              <circle cx="12" cy="5" r="1"></circle>
              <circle cx="12" cy="19" r="1"></circle>
            </svg>
          </button>
          <div class="dropdown-menu" id="dropdown-${replyData.id}">
            <button class="dropdown-item edit-comment-btn" data-comment-id="${replyData.id}" style="display: inline-flex;">
              <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"></path>
                <path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"></path>
              </svg>
              Edit
            </button>
            <button class="dropdown-item delete-comment-btn" data-comment-id="${replyData.id}" style="display: inline-flex;">
              <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <polyline points="3,6 5,6 21,6"></polyline>
                <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2 2h4a2 2 0 0 1 2 2v2"></path>
              </svg>
              Delete
            </button>
            <button class="dropdown-item report-btn" data-comment-id="${replyData.id}" style="display: flex;">
              <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M4 15s1-1 4-1 5 2 8 2 4-1 4-1V3s-1 1-4 1-5-2-8-2-4 1-4 1z"></path>
                <line x1="4" y1="22" x2="4" y2="15"></line>
              </svg>
              Report
            </button>
          </div>
        </div>
      </div>

      <div class="comment-content">
        <div class="comment-text">${this.formatContent(replyData.content)}</div>
      </div>

<div class="comment-footer">
  <button class="vote-btn upvote-btn" data-comment-id="${replyData.id}" data-action="upvote">
    <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
      <path d="M7 14l5-5 5 5"></path>
    </svg>
  </button>
  <span class="vote-count">${replyData.like_count || 0}</span>
  <button class="vote-btn downvote-btn" data-comment-id="${replyData.id}" data-action="downvote">
    <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
      <path d="M17 10l-5 5-5-5"></path>
    </svg>
  </button>
  
  <button class="reaction-btn" data-reaction="love" data-comment-id="${replyData.id}">
    <span class="reaction-emoji">â¤ï¸</span>
    <span class="reaction-count">0</span>
  </button>
  
  ${replyLevel < 4 ? `
    <button class="action-btn reply-btn" data-comment-id="${replyData.id}" data-author="${displayName}">
      <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
        <polyline points="9,17 4,12 9,7"></polyline>
        <path d="M20 18v-2a4 4 0 0 0-4-4H4"></path>
      </svg>
      <span class="action-text">Reply</span>
    </button>
  ` : ''}
  
  <button class="action-btn bookmark-btn" data-comment-id="${replyData.id}">
    <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
      <path d="M19 21l-7-5-7 5V5a2 2 0 0 1 2-2h10a2 2 0 0 1 2 2z"></path>
    </svg>
    <span class="action-text">Save</span>
  </button>
  
  <button class="action-btn copy-btn" data-comment-id="${replyData.id}">
    <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
      <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
      <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2 2v1"></path>
    </svg>
    <span class="action-text">Copy</span>
  </button>
</div>
    
    <!-- âœ… INLINE CONTAINERS FOR THIS REPLY -->
    <div class="inline-reply-container" style="display: none;"></div>
    <div class="inline-edit-container" style="display: none;"></div>
  `;

  // âœ… ADD TO THE REPLIES CONTAINER (NOT MAIN CONTAINER)
  repliesContainer.appendChild(replyWrapper);
  
  // Add highlight animation
  const replyCard = replyWrapper.querySelector('.reply-card');
  replyCard.classList.add('new-comment');
  
  setTimeout(() => {
    replyCard.classList.remove('new-comment');
    // Update permissions after highlight animation
    this.updateCommentPermissions(replyData.id);
  }, 1000);
  
  // Scroll to the new reply
  replyWrapper.scrollIntoView({ 
    behavior: 'smooth', 
    block: 'center' 
  });
  
  debugLog('âœ… Reply added to UI successfully with thread level:', replyLevel);
}

  removeCommentFromUI(commentId) {
    const commentCard = this.getCommentCardElement(commentId);
    const commentWrapper = commentCard?.closest('.comment-wrapper');
    
    if (commentWrapper) {
      commentWrapper.remove();
    } else if (commentCard) {
      commentCard.remove();
    }
  }

  getCommentCardElement(commentId) {
    return document.querySelector(`.comment-card[data-comment-id="${commentId}"], .reply-card[data-comment-id="${commentId}"]`);
  }

  updateCommentCount(change) {
    const countElement = document.getElementById('total-comments');
    if (countElement) {
      const currentCount = parseInt(countElement.textContent) || 0;
      countElement.textContent = Math.max(0, currentCount + change);
    }
  }

  toggleDropdown(commentId) {
    const dropdown = document.getElementById(`dropdown-${commentId}`);
    if (!dropdown) return;

    // Close other dropdowns
    document.querySelectorAll('.dropdown-menu.show').forEach(menu => {
      if (menu !== dropdown) {
        menu.classList.remove('show');
      }
    });

    // Toggle current dropdown
    dropdown.classList.toggle('show');
    
    if (dropdown.classList.contains('show')) {
      this.updateCommentPermissions(commentId);
    }
  }

  canStillEdit(createdAtString) {
    if (!createdAtString) return false;
    
    const createdAt = new Date(createdAtString);
    const now = new Date();
    const diffInMinutes = (now - createdAt) / (1000 * 60);
    
    return diffInMinutes <= 15;
  }

  // Utility Methods
  validateComment(content) {
    if (!content || content.length < 1) {
      showUserError('Comment cannot be empty');
      return false;
    }

    if (content.length > 1000) {
      showUserError('Comment cannot exceed 1000 characters');
      return false;
    }

    return true;
  }

  formatContent(content) {
    const mentionPattern = /@(\w+)/g;
    return content
      .replace(/\*\*(.*?)\*\*/g, "<strong>$1</strong>")
      .replace(/\*(.*?)\*/g, "<em>$1</em>")
      .replace(/`(.*?)`/g, "<code>$1</code>")
      .replace(mentionPattern, '<span class="mention">@$1</span>')
      .replace(/\n/g, "<br>");
  }

  applyFormatting(format, textarea) {
    if (!textarea) return;

    const start = textarea.selectionStart;
    const end = textarea.selectionEnd;
    const selectedText = textarea.value.substring(start, end);
    
    let formattedText = '';
    
    switch (format) {
      case 'bold':
        formattedText = `**${selectedText}**`;
        break;
      case 'italic':
        formattedText = `*${selectedText}*`;
        break;
      case 'code':
        formattedText = `\`${selectedText}\``;
        break;
      default:
        return;
    }

    textarea.value = textarea.value.substring(0, start) + formattedText + textarea.value.substring(end);
    textarea.focus();
    textarea.setSelectionRange(start + formattedText.length, start + formattedText.length);
    
    const form = textarea.closest('form');
    const charCount = form?.querySelector('.count');
    if (charCount) {
      charCount.textContent = textarea.value.length;
    }
  }

  insertEmoji(emoji, textarea) {
    if (!textarea) return;

    const start = textarea.selectionStart;
    const end = textarea.selectionEnd;
    
    textarea.value = textarea.value.substring(0, start) + emoji + textarea.value.substring(end);
    textarea.focus();
    textarea.setSelectionRange(start + emoji.length, start + emoji.length);
    
    const form = textarea.closest('form');
    const charCount = form?.querySelector('.count');
    if (charCount) {
      charCount.textContent = textarea.value.length;
    }
  }

  updateCharacterCount() {
    const textarea = document.getElementById('comment-textarea');
    const countElement = document.querySelector('#character-count-comment-form .count') || 
                        document.querySelector('.character-count .count') ||
                        document.getElementById('character-count');
    
    if (textarea && countElement) {
      const count = textarea.value.length;
      countElement.textContent = count;
      
      if (count > 800) {
        countElement.style.color = 'var(--warning-color)';
      } else if (count >= 1000) {
        countElement.style.color = 'var(--error-color)';
      } else {
        countElement.style.color = 'var(--text-secondary)';
      }
    }
  }

  // Modal methods
  showModal(modalId) {
    const modal = document.getElementById(modalId);
    if (modal) {
      modal.style.display = 'flex';
      document.body.style.overflow = 'hidden';
    }
  }

  hideModal(modalId) {
    const modal = document.getElementById(modalId);
    if (modal) {
      modal.style.display = 'none';
      document.body.style.overflow = '';
    }
  }

  // Loading states
  showLoading(container) {
    const submitBtn = container.querySelector('.submit-btn');
    const btnText = submitBtn?.querySelector('.btn-text');
    const btnSpinner = submitBtn?.querySelector('.btn-spinner');
    
    if (submitBtn) {
      submitBtn.disabled = true;
      submitBtn.style.opacity = '0.7';
      submitBtn.style.cursor = 'not-allowed';
      if (btnText) btnText.style.display = 'none';
      if (btnSpinner) btnSpinner.style.display = 'flex';
    }
  }

  hideLoading(container) {
    const submitBtn = container.querySelector('.submit-btn');
    const btnText = submitBtn?.querySelector('.btn-text');
    const btnSpinner = submitBtn?.querySelector('.btn-spinner');
    
    if (submitBtn) {
      submitBtn.disabled = false;
      submitBtn.style.opacity = '1';
      submitBtn.style.cursor = 'pointer';
      if (btnText) btnText.style.display = 'flex';
      if (btnSpinner) btnSpinner.style.display = 'none';
    }
  }

  resetForm(form) {
    const textarea = form.querySelector('textarea');
    if (textarea) {
      textarea.value = '';
      textarea.disabled = false;
      
      // Trigger input event to update character count
      const inputEvent = new Event('input', { bubbles: true });
      textarea.dispatchEvent(inputEvent);
    }
    
    // Reset all form elements
    form.reset();
    
    // Close any open pickers
    this.closeAllEmojiPickers();
  }

  resetFormState(form) {
    const textarea = form.querySelector('textarea');
    const charCount = form.querySelector('.character-count .count, .count');
    const submitBtn = form.querySelector('.submit-btn');
    
    if (textarea) {
      textarea.value = '';
      textarea.disabled = false;
      textarea.style.opacity = '1';
    }
    
    if (charCount) {
      charCount.textContent = '0';
      charCount.style.color = 'var(--text-secondary)';
    }
    
    if (submitBtn) {
      submitBtn.disabled = false;
      submitBtn.style.opacity = '1';
      submitBtn.style.cursor = 'pointer';
      
      const btnText = submitBtn.querySelector('.btn-text');
      const btnSpinner = submitBtn.querySelector('.btn-spinner');
      
      if (btnText) btnText.style.display = 'flex';
      if (btnSpinner) btnSpinner.style.display = 'none';
    }
    
    this.closeAllEmojiPickers();
  }

  cancelReply() {
    this.replyingTo = null;
    const replyContext = document.getElementById('reply-context');
    if (replyContext) {
      replyContext.style.display = 'none';
    }
    
    // Close all inline reply forms
    document.querySelectorAll('.inline-reply-container').forEach(container => {
      container.style.display = 'none';
      container.innerHTML = '';
    });
  }

  closeAllModals() {
    document.querySelectorAll('.modal-overlay').forEach(modal => {
      modal.style.display = 'none';
    });
    document.body.style.overflow = '';
  }

  closeAllInlineForms() {
    document.querySelectorAll('.inline-reply-container, .inline-edit-container').forEach(container => {
      container.style.display = 'none';
      container.innerHTML = '';
    });
  }

  // âœ… MENTION SYSTEM
  setupMentionSystem() {
    // Remove any existing mention listeners first
    document.removeEventListener('input', this.mentionInputHandler);
    document.removeEventListener('keydown', this.mentionKeyHandler);
    
    // Create bound handlers to avoid conflicts
    this.mentionInputHandler = (e) => {
      if (e.target.tagName === 'TEXTAREA') {
        this.handleMentionInput(e.target);
      }
    };
    
    this.mentionKeyHandler = (e) => {
      if (e.target.tagName === 'TEXTAREA') {
        this.handleMentionNavigation(e);
      }
    };
    
    // Add the listeners
    document.addEventListener('input', this.mentionInputHandler);
    document.addEventListener('keydown', this.mentionKeyHandler);
    
    // Close mention dropdown when clicking outside
    document.addEventListener('click', (e) => {
      if (!e.target.closest('.mention-dropdown, textarea')) {
        this.closeMentionDropdown();
      }
    });
  }

  handleMentionInput(textarea) {
    const cursorPosition = textarea.selectionStart;
    const textBeforeCursor = textarea.value.substring(0, cursorPosition);
    
    // Look for @ symbol followed by word characters
    const mentionMatch = textBeforeCursor.match(/@(\w*)$/);
    
    if (mentionMatch) {
      const query = mentionMatch[1]; // The text after @
      const mentionStart = cursorPosition - mentionMatch[0].length; // Position of @
      
      this.showMentionDropdown(textarea, query, mentionStart);
    } else {
      this.closeMentionDropdown();
    }
  }

  async showMentionDropdown(textarea, query, mentionStart) {
    // Close any existing dropdown
    this.closeMentionDropdown();
    
    // Get mentionable users
    const users = await this.getMentionableUsers(query);
    
    if (!users || users.length === 0) {
      return;
    }
    
    // Create dropdown
    const dropdown = document.createElement('div');
    dropdown.className = 'mention-dropdown';
    dropdown.style.cssText = `
      position: fixed;
      background: var(--secondary-bg);
      border: 1px solid var(--border-color);
      border-radius: 0px;
      max-height: 200px;
      overflow-y: auto;
      z-index: 1000;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
      min-width: 200px;
    `;
    
    // Add users to dropdown
    users.forEach((user, index) => {
      const item = document.createElement('div');
      item.className = 'mention-item';
      item.dataset.username = user.username;
      item.style.cssText = `
        display: flex;
        align-items: center;
        gap: 0.75rem;
        padding: 0.5rem 1rem;
        cursor: pointer;
        transition: background-color 0.2s ease;
        ${index === 0 ? 'background: var(--tertiary-bg);' : ''}
      `;
      
      // Get avatar URL
      const avatarUrl = this.getUserAvatar(user);
      
      item.innerHTML = `
        <div class="mention-item-avatar" style="width: 24px; height: 24px; border-radius: 0%; overflow: hidden;">
          <img src="${avatarUrl}" alt="${user.display_name}" style="width: 100%; height: 100%; object-fit: cover;" />
        </div>
        <div class="mention-item-info">
          <div class="mention-item-name" style="font-weight: 600; font-size: 0.875rem; color: var(--text-primary);">
            ${user.display_name}
          </div>
          <div class="mention-item-handle" style="font-size: 0.75rem; color: var(--text-secondary);">
            @${user.username}
          </div>
        </div>
      `;
      
      // Add click handler
      item.addEventListener('click', () => {
        this.insertMention(textarea, user.username, mentionStart, query);
      });
      
      // Add hover handler
      item.addEventListener('mouseenter', () => {
        dropdown.querySelectorAll('.mention-item').forEach(i => i.style.background = '');
        item.style.background = 'var(--tertiary-bg)';
        this.selectedMentionIndex = index;
      });
      
      dropdown.appendChild(item);
    });
    
    // Position dropdown
    this.positionMentionDropdown(dropdown, textarea, mentionStart);
    
    // Add to DOM
    document.body.appendChild(dropdown);
    
    // Store references
    this.currentMentionDropdown = dropdown;
    this.currentMentionTextarea = textarea;
    this.currentMentionStart = mentionStart;
    this.selectedMentionIndex = 0;
  }

  async getMentionableUsers(query = '') {
    try {
      // Check if user is authenticated
      if (!this.isAuthenticated || !this.currentUser) {
        return [];
      }
      
      // Add timeout to prevent hanging
      const timeoutPromise = new Promise((_, reject) => {
        setTimeout(() => reject(new Error('API timeout')), 5000);
      });
      
      // Create API call promise
      const apiCall = async () => {
        let queryBuilder = this.supabase
          .from('profiles')
          .select('id, display_name, avatar_type, avatar_preset_id, avatar_url, is_admin, membership_type')
          .eq('environment', this.environment)
          .eq('is_public', true)
          .neq('id', this.currentUser.id)
          .limit(8);

        if (query && query.length > 0) {
          queryBuilder = queryBuilder.ilike('display_name', `%${query}%`);
        }

        const { data, error } = await queryBuilder;

        if (error) throw error;

        // Format for mention dropdown
        return (data || []).map(profile => ({
          id: profile.id,
          username: profile.display_name?.toLowerCase().replace(/\s+/g, '') || 'user',
          display_name: profile.display_name || 'User',
          avatar_type: profile.avatar_type,
          avatar_preset_id: profile.avatar_preset_id,
          avatar_url: profile.avatar_url,
          is_admin: profile.is_admin,
          membership_type: profile.membership_type
        }));
      };
      
      try {
        const result = await Promise.race([apiCall(), timeoutPromise]);
        return result;
      } catch (apiError) {
        // Fallback mock data for testing
        const mockUsers = [
          { 
            id: 'bb06d43f-279c-478c-b97f-afe8583c460d', 
            username: 'eiza', 
            display_name: 'Eiza', 
            avatar_type: 'preset', 
            avatar_preset_id: 1 
          },
          { 
            id: 'test-user-1', 
            username: 'john', 
            display_name: 'John Doe', 
            avatar_type: 'preset', 
            avatar_preset_id: 2 
          }
        ];
        
        // Filter mock data based on query
        return query 
          ? mockUsers.filter(user => 
              user.username.toLowerCase().includes(query.toLowerCase()) ||
              user.display_name.toLowerCase().includes(query.toLowerCase())
            )
          : mockUsers;
      }
      
    } catch (error) {
      debugLog('âŒ Error in getMentionableUsers:', error);
      return [];
    }
  }

  positionMentionDropdown(dropdown, textarea, mentionStart) {
    // Create a temporary span to measure text position
    const textMetrics = this.getTextPosition(textarea, mentionStart);
    const textareaRect = textarea.getBoundingClientRect();
    
    let left = textareaRect.left + textMetrics.left;
    let top = textareaRect.top + textMetrics.top + 20; // 20px below the text
    
    // Adjust if dropdown would go off screen
    if (left + 200 > window.innerWidth) {
      left = window.innerWidth - 220;
    }
    
    if (top + 200 > window.innerHeight) {
      top = textareaRect.top + textMetrics.top - 200; // Above the text
    }
    
    dropdown.style.left = `${left}px`;
    dropdown.style.top = `${top}px`;
  }

  getTextPosition(textarea, position) {
    // Create a mirror div to measure text position
    const mirror = document.createElement('div');
    const computedStyle = window.getComputedStyle(textarea);
    
    // Copy textarea styles to mirror
    ['fontFamily', 'fontSize', 'fontWeight', 'lineHeight', 'letterSpacing', 
     'padding', 'border', 'boxSizing', 'whiteSpace', 'wordWrap'].forEach(prop => {
      mirror.style[prop] = computedStyle[prop];
    });
    
    mirror.style.cssText += `
      position: absolute;
      visibility: hidden;
      height: auto;
      width: ${textarea.clientWidth}px;
      top: -9999px;
      white-space: pre-wrap;
      word-wrap: break-word;
    `;
    
    // Add text up to cursor position
    const textBeforeCursor = textarea.value.substring(0, position);
    mirror.textContent = textBeforeCursor;
    
    // Add a span at cursor position
    const cursorSpan = document.createElement('span');
    cursorSpan.textContent = '|';
    mirror.appendChild(cursorSpan);
    
    document.body.appendChild(mirror);
    
    const rect = cursorSpan.getBoundingClientRect();
    const mirrorRect = mirror.getBoundingClientRect();
    
    const position_result = {
      left: rect.left - mirrorRect.left,
      top: rect.top - mirrorRect.top
    };
    
    document.body.removeChild(mirror);
    
    return position_result;
  }

  handleMentionNavigation(e) {
    if (!this.currentMentionDropdown) return;
    
    const items = this.currentMentionDropdown.querySelectorAll('.mention-item');
    
    if (e.key === 'ArrowDown') {
      e.preventDefault();
      this.selectedMentionIndex = Math.min(this.selectedMentionIndex + 1, items.length - 1);
      this.updateMentionSelection(items);
    } else if (e.key === 'ArrowUp') {
      e.preventDefault();
      this.selectedMentionIndex = Math.max(this.selectedMentionIndex - 1, 0);
      this.updateMentionSelection(items);
    } else if (e.key === 'Enter' || e.key === 'Tab') {
      e.preventDefault();
      const selectedItem = items[this.selectedMentionIndex];
      if (selectedItem) {
        const username = selectedItem.dataset.username;
        const query = this.getCurrentMentionQuery();
        this.insertMention(this.currentMentionTextarea, username, this.currentMentionStart, query);
      }
    } else if (e.key === 'Escape') {
      this.closeMentionDropdown();
    }
  }

  updateMentionSelection(items) {
    items.forEach((item, index) => {
      item.style.backgroundColor = index === this.selectedMentionIndex ? 'var(--hover-bg)' : '';
    });
  }

  getCurrentMentionQuery() {
    if (!this.currentMentionTextarea) return '';
    
    const cursorPosition = this.currentMentionTextarea.selectionStart;
    const textBeforeCursor = this.currentMentionTextarea.value.substring(0, cursorPosition);
    const mentionMatch = textBeforeCursor.match(/@(\w*)$/);
    
    return mentionMatch ? mentionMatch[1] : '';
  }

  insertMention(textarea, username, mentionStart, query) {
    const currentValue = textarea.value;
    const mentionText = `@${username} `;
    
    // Replace the @query with @username
    const beforeMention = currentValue.substring(0, mentionStart);
    const afterMention = currentValue.substring(mentionStart + 1 + query.length);
    
    textarea.value = beforeMention + mentionText + afterMention;
    
    // Set cursor after the mention
    const newCursorPosition = mentionStart + mentionText.length;
    textarea.setSelectionRange(newCursorPosition, newCursorPosition);
    
    // Update character count
    const form = textarea.closest('form');
    const charCount = form?.querySelector('.count');
    if (charCount) {
      charCount.textContent = textarea.value.length;
    }
    
    this.closeMentionDropdown();
    textarea.focus();
  }

  closeMentionDropdown() {
    if (this.currentMentionDropdown) {
      this.currentMentionDropdown.remove();
      this.currentMentionDropdown = null;
      this.currentMentionTextarea = null;
      this.currentMentionStart = -1;
      this.selectedMentionIndex = 0;
    }
  }

  // âœ… SILENT DRAFT MANAGEMENT
  async saveDraft() {
    await this.ensureAuth();
    
    if (!this.isAuthenticated || !this.currentUser) return;
    
    const textarea = document.getElementById('comment-textarea');
    if (!textarea) return;
    
    const content = textarea.value.trim();
    if (!content) return;
    
    clearTimeout(this.draftTimeout);
    this.draftTimeout = setTimeout(async () => {
      try {
        // Try API first if available
        const result = await this.callAPI('saveCommentDraft', [this.articleId, content]);
        if (result.success) {
          return; // API worked
        }
      } catch (error) {
        debugLog('âŒ Draft API failed:', error);
      }
      
      // Fallback to localStorage
      try {
        const draftKey = `comment_draft_${this.articleId}_${this.currentUser.id}`;
        localStorage.setItem(draftKey, content);
      } catch (localError) {
        debugLog('âŒ localStorage draft failed:', localError);
      }
    }, 2000);
  }

  async loadDrafts() {
    if (!this.isAuthenticated || !this.currentUser) return;
    
    try {
      // Try API first if available
      const result = await this.callAPI('getCommentDraft', [this.articleId]);
      
      if (result.success && result.data?.content) {
        const textarea = document.getElementById('comment-textarea');
        if (textarea) {
          textarea.value = result.data.content;
          this.updateCharacterCount();
          return; // Exit early if API worked
        }
      }
    } catch (error) {
      debugLog('âŒ Draft API load failed:', error);
    }
    
    // Fallback to localStorage
    try {
      const draftKey = `comment_draft_${this.articleId}_${this.currentUser.id}`;
      const savedDraft = localStorage.getItem(draftKey);
      
      if (savedDraft) {
        const textarea = document.getElementById('comment-textarea');
        if (textarea) {
          textarea.value = savedDraft;
          this.updateCharacterCount();
        }
      }
    } catch (error) {
      debugLog('âŒ localStorage draft load failed:', error);
    }
  }

  clearDraft() {
    if (!this.isAuthenticated || !this.currentUser) return;
    
    setTimeout(async () => {
      try {
        // Try API first if available
        await this.callAPI('saveCommentDraft', [this.articleId, '']);
      } catch (error) {
        debugLog('âŒ API draft clear failed:', error);
      }
      
      // Also clear localStorage
      try {
        const draftKey = `comment_draft_${this.articleId}_${this.currentUser.id}`;
        localStorage.removeItem(draftKey);
      } catch (error) {
        debugLog('âŒ localStorage clear failed:', error);
      }
    }, 500);
  }

  // Sorting and pagination
  async sortComments(sortBy) {
    this.currentSort = sortBy;
    const url = new URL(window.location);
    url.searchParams.set('sort', sortBy);
    window.location.href = url.toString();
  }

async loadMoreComments() {
  if (this.isLoadingMore) {
    debugLog('â³ Load more already in progress');
    return;
  }

  if (this.loadedComments >= this.totalComments) {
    debugLog('âœ… All comments already loaded');
    this.updateLoadMoreUI();
    return;
  }

  this.isLoadingMore = true;
  const loadMoreBtn = document.getElementById('load-more-btn');
  
  this.showLoadMoreLoading(loadMoreBtn);

  try {
    debugLog('ğŸ”„ Loading more comments...', {
      loaded: this.loadedComments,
      total: this.totalComments,
      perPage: this.commentsPerPage
    });

    // âœ… GET CACHED COMMENTS WITH BETTER ERROR HANDLING
    const commentSection = document.getElementById('comments-section');
    if (!commentSection) {
      throw new Error('Comment section not found');
    }

    const allCommentsData = commentSection.dataset.allComments;
    if (!allCommentsData) {
      throw new Error('No cached comment data found');
    }

    let allComments = [];
    try {
      allComments = JSON.parse(allCommentsData);
    } catch (parseError) {
      debugLog('âŒ Error parsing comment data:', parseError);
      throw new Error('Invalid comment data format');
    }

    if (!Array.isArray(allComments)) {
      throw new Error('Comment data is not an array');
    }

    debugLog('ğŸ“Š Available comments:', allComments.length);

    // âœ… GET THE NEXT BATCH OF COMMENTS
    const startIndex = this.loadedComments;
    const endIndex = startIndex + this.commentsPerPage;
    const nextComments = allComments.slice(startIndex, endIndex);

    debugLog('ğŸ“‹ Next batch:', {
      startIndex,
      endIndex,
      nextComments: nextComments.length
    });

    if (nextComments.length > 0) {
      // âœ… ADD EACH COMMENT WITH ITS REPLIES TO UI
      nextComments.forEach(comment => {
        this.addCommentTreeToUI(comment);
      });
      
      // âœ… UPDATE STATE
      this.loadedComments += nextComments.length;
      
      debugLog('âœ… Added comments:', {
        added: nextComments.length,
        totalLoaded: this.loadedComments
      });
    } else {
      debugLog('â„¹ï¸ No more comments to load');
      this.loadedComments = this.totalComments;
    }

    this.updateLoadMoreUI();

  } catch (error) {
    debugLog('âŒ Error loading more comments:', error);
    
    // âœ… PROVIDE SPECIFIC ERROR MESSAGES
    let userMessage = 'Failed to load more comments. Please try again.';
    
    if (error.message.includes('Comment section not found')) {
      userMessage = 'Comment system not properly initialized. Please refresh the page.';
    } else if (error.message.includes('No cached comment data')) {
      userMessage = 'No additional comments available.';
    } else if (error.message.includes('Invalid comment data')) {
      userMessage = 'Comment data is corrupted. Please refresh the page.';
    }
    
    showUserError(userMessage);
  } finally {
    this.isLoadingMore = false;
    this.hideLoadMoreLoading(loadMoreBtn);
  }
}

addCommentTreeToUI(comment) {
  const commentsContainer = this.getMainCommentsContainer();
  if (!commentsContainer) {
    debugLog('âŒ Comments container not found');
    return;
  }

  try {
    const commentElement = this.createCommentElementFromData(comment);
    
    if (commentElement) {
      // âœ… ADD FADE-IN ANIMATION
      commentElement.classList.add('fade-in-new');
      
      // âœ… APPEND TO CONTAINER
      commentsContainer.appendChild(commentElement);
      
      // âœ… UPDATE PERMISSIONS AFTER A SHORT DELAY
      setTimeout(() => {
        this.updateCommentPermissions(comment.id);
        
        // âœ… ALSO UPDATE PERMISSIONS FOR REPLIES
        if (comment.replies && comment.replies.length > 0) {
          this.updatePermissionsForReplies(comment.replies);
        }
      }, 100);
      
      debugLog('âœ… Added comment to UI:', comment.id);
    } else {
      debugLog('âŒ Failed to create comment element for:', comment.id);
    }
  } catch (error) {
    debugLog('âŒ Error adding comment to UI:', error);
  }
}

updatePermissionsForReplies(replies) {
  replies.forEach(reply => {
    this.updateCommentPermissions(reply.id);
    if (reply.replies && reply.replies.length > 0) {
      this.updatePermissionsForReplies(reply.replies);
    }
  });
}

  showInitializationError() {
  const commentSection = document.getElementById('comments-section');
  if (commentSection) {
    commentSection.innerHTML = `
      <div class="comment-error-state" style="
        display: flex;
        flex-direction: column;
        align-items: center;
        padding: 2rem;
        text-align: center;
        background: var(--secondary-bg);
        border-radius: 0px;
        margin: 1rem 0;
      ">
        <div class="error-icon" style="font-size: 3rem; margin-bottom: 1rem;">âš ï¸</div>
        <h3 style="margin-bottom: 0.5rem; color: var(--text-primary);">Comments temporarily unavailable</h3>
        <p style="margin-bottom: 1.5rem; color: var(--text-secondary);">Please refresh the page or try again later.</p>
        <button onclick="window.location.reload()" class="retry-btn" style="
          background: var(--primary-color);
          color: white;
          border: none;
          padding: 0.75rem 1.5rem;
          border-radius: 0px;
          cursor: pointer;
          font-weight: 500;
        ">
          Retry
        </button>
      </div>
    `;
  }
}

  // Helper methods for load more UI
  showLoadMoreLoading(btn) {
    if (!btn) return;
    btn.disabled = true;
    const btnText = btn.querySelector('.btn-text');
    const btnSpinner = btn.querySelector('.btn-spinner');
    if (btnText) btnText.style.display = 'none';
    if (btnSpinner) btnSpinner.style.display = 'flex';
  }

  hideLoadMoreLoading(btn) {
    if (!btn) return;
    btn.disabled = false;
    const btnText = btn.querySelector('.btn-text');
    const btnSpinner = btn.querySelector('.btn-spinner');
    if (btnText) btnText.style.display = 'flex';
    if (btnSpinner) btnSpinner.style.display = 'none';
  }

  // Add multiple comments to UI
  addCommentsToUI(commentTree) {
    const commentsContainer = document.getElementById('comments-items');
    if (!commentsContainer) {
      return;
    }

    commentTree.forEach((comment, index) => {
      const commentElement = this.createCommentElementFromData(comment);
      
      if (commentElement) {
        // Add fade-in animation
        commentElement.classList.add('fade-in-new');
        
        // Append to container
        commentsContainer.appendChild(commentElement);
        
        // Update permissions after a short delay
        setTimeout(() => {
          this.updateCommentPermissions(comment.id);
          
          // Also update permissions for replies
          if (comment.replies && comment.replies.length > 0) {
            comment.replies.forEach(reply => {
              this.updateCommentPermissions(reply.id);
            });
          }
        }, 100);
      }
    });
  }

  addCommentWithThreading(commentData, parentId = null) {
  if (commentData.moderation_status === 'pending' && commentData.user_id !== this.currentUser?.id) {
    return;
  }

  // Hide empty state
  const emptyState = document.getElementById('empty-state');
  if (emptyState) {
    emptyState.style.display = 'none';
  }

  if (parentId) {
    // This is a reply - add to parent's replies container
    this.addReplyToUI(commentData, parentId);
  } else {
    // This is a root comment - add to main container
    this.addCommentToUI(commentData);
  }

  // Update comment count
  this.updateCommentCount(1);
  
  // Sync with database
  setTimeout(() => {
    this.syncCommentsWithDatabase();
  }, 1000);
}

  createCommentElementFromData(comment) {
    const wrapper = document.createElement('div');
    wrapper.className = 'comment-wrapper';
    wrapper.dataset.commentId = comment.id;
    
    const threadLevel = Math.min(comment.thread_level || 0, 4);
    const avatarUrl = this.getUserAvatar(comment.profiles);
    const formattedContent = this.formatContent(comment.content);
    const displayName = comment.profiles?.display_name || 'Anonymous';
    const isAdmin = comment.profiles?.is_admin || false;
    
    wrapper.innerHTML = `
      <div class="comment-card" 
          data-comment-id="${comment.id}" 
          data-user-id="${comment.user_id}" 
          data-created-at="${comment.created_at}" 
          data-thread-level="${threadLevel}">
        
        <div class="comment-header">
          <div class="comment-user-info">
            <div class="comment-avatar">
              <img src="${avatarUrl}" alt="${displayName}" loading="lazy" />
              ${isAdmin ? '<div class="admin-badge">ğŸ‘‘</div>' : ''}
            </div>
            <div class="comment-meta">
              <div class="user-details">
                <span class="username ${isAdmin ? 'admin' : ''}">${displayName}</span>
                ${isAdmin ? '<span class="admin-badge">Admin</span>' : ''}
              </div>
              <div class="comment-time-wrapper">
                <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                  <circle cx="12" cy="12" r="10"></circle>
                  <polyline points="12,6 12,12 16,14"></polyline>
                </svg>
                <span class="comment-time" title="${new Date(comment.created_at).toLocaleString()}">
                  ${this.formatDate(comment.created_at)}
                </span>
              </div>
            </div>
          </div>
          
          <div class="comment-actions-menu">
            <button class="menu-btn" data-comment-id="${comment.id}" title="More options" aria-label="Comment options">
              <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <circle cx="12" cy="12" r="1"></circle>
                <circle cx="19" cy="12" r="1"></circle>
                <circle cx="5" cy="12" r="1"></circle>
              </svg>
            </button>
            <div class="dropdown-menu" id="dropdown-${comment.id}">
              <button class="dropdown-item edit-comment-btn" data-comment-id="${comment.id}" style="display: none;">
                <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                  <path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"></path>
                  <path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"></path>
                </svg>
                Edit
              </button>
              <button class="dropdown-item delete-comment-btn" data-comment-id="${comment.id}" style="display: none;">
                <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                  <polyline points="3,6 5,6 21,6"></polyline>
                  <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2 2h4a2 2 0 0 1 2 2v2"></path>
                </svg>
                Delete
              </button>
              <button class="dropdown-item report-btn" data-comment-id="${comment.id}" style="display: flex;">
                <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                  <path d="M4 15s1-1 4-1 5 2 8 2 4-1 4-1V3s-1 1-4 1-5-2-8-2-4 1-4 1z"></path>
                  <line x1="4" y1="22" x2="4" y2="15"></line>
                </svg>
                Report
              </button>
            </div>
          </div>
        </div>

        <div class="comment-content">
          <div class="comment-text">${formattedContent}</div>
        </div>

<div class="comment-footer">
  <div class="footer-top-row">
    <div class="vote-section">
      <button class="vote-btn upvote-btn" data-comment-id="${replyData.id}" data-action="upvote">
        <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <path d="M7 14l5-5 5 5"></path>
        </svg>
      </button>
      <span class="vote-count">${replyData.like_count || 0}</span>
      <button class="vote-btn downvote-btn" data-comment-id="${replyData.id}" data-action="downvote">
        <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <path d="M17 10l-5 5-5-5"></path>
        </svg>
      </button>
    </div>
    
    <div class="comment-reactions">
      <button class="reaction-btn" data-reaction="like" data-comment-id="${comment.id}" title="Like">
        <span class="reaction-emoji">ğŸ‘</span>
        <span class="reaction-count" id="reaction-like-${comment.id}">${comment.reaction_counts?.like || 0}</span>
        </button>
      <button class="reaction-btn" data-reaction="love" data-comment-id="${replyData.id}">
        <span class="reaction-emoji">â¤ï¸</span>
        <span class="reaction-count" id="reaction-love-${replyData.id}">0</span>
      </button>
    
    </div>
  </div>

  <div class="comment-actions">
    ${replyLevel < 4 ? `
      <button class="action-btn reply-btn" data-comment-id="${replyData.id}" data-author="${displayName}">
        <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <polyline points="9,17 4,12 9,7"></polyline>
          <path d="M20 18v-2a4 4 0 0 0-4-4H4"></path>
        </svg>
        Reply
      </button>
    ` : ''}
    
    <button class="action-btn bookmark-btn" data-comment-id="${replyData.id}">
      <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
        <path d="M19 21l-7-5-7 5V5a2 2 0 0 1 2-2h10a2 2 0 0 1 2 2z"></path>
      </svg>
      Save
    </button>
    
    <button class="action-btn copy-btn" data-comment-id="${replyData.id}">
      <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
        <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
        <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2 2v1"></path>
      </svg>
      Copy
    </button>
  </div>
</div>

        <div class="inline-reply-container" data-comment-id="${comment.id}" style="display: none;"></div>
        <div class="inline-edit-container" data-comment-id="${comment.id}" style="display: none;"></div>
      </div>
    `;

    // Add replies if they exist
    if (comment.replies && comment.replies.length > 0) {
      const repliesContainer = document.createElement('div');
      repliesContainer.className = 'replies-container comment-replies';
      
      // Show first 3 replies
      const visibleReplies = comment.replies.slice(0, 3);
      visibleReplies.forEach(reply => {
        const replyElement = this.createReplyElementFromData(reply);
        if (replyElement) {
          repliesContainer.appendChild(replyElement);
        }
      });
      
      wrapper.appendChild(repliesContainer);
      
      // Add "show more replies" button if needed
      if (comment.replies.length > 3) {
        const loadMoreReplies = document.createElement('div');
        loadMoreReplies.className = 'load-more-replies';
        loadMoreReplies.innerHTML = `
          <button class="load-more-replies-btn" 
                  data-comment-id="${comment.id}" 
                  data-loaded="3" 
                  data-total="${comment.replies.length}">
            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <polyline points="6,9 12,15 18,9"></polyline>
            </svg>
            Show ${comment.replies.length - 3} more replies
          </button>
        `;
        wrapper.appendChild(loadMoreReplies);
      }
    }
    
    return wrapper;
  }

  // Helper method for creating reply elements
  createReplyElementFromData(reply) {
    const wrapper = document.createElement('div');
    wrapper.className = 'comment-wrapper reply-wrapper';
    wrapper.dataset.commentId = reply.id;
    
    const avatarUrl = this.getUserAvatar(reply.profiles);
    const formattedContent = this.formatContent(reply.content);
    const displayName = reply.profiles?.display_name || 'Anonymous';
    const isAdmin = reply.profiles?.is_admin || false;
    
    wrapper.innerHTML = `
      <div class="comment-card reply-card" 
          data-comment-id="${reply.id}" 
          data-user-id="${reply.user_id}" 
          data-created-at="${reply.created_at}">
        <div class="reply-connector"></div>
        
        <div class="comment-header">
          <div class="comment-user-info">
            <div class="comment-avatar">
              <img src="${avatarUrl}" alt="${displayName}" loading="lazy" />
              ${isAdmin ? '<div class="admin-badge">ğŸ‘‘</div>' : ''}
            </div>
            <div class="comment-meta">
              <div class="user-details">
                <span class="username ${isAdmin ? 'admin' : ''}">${displayName}</span>
              </div>
              <div class="comment-time-wrapper">
                <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                  <circle cx="12" cy="12" r="10"></circle>
                  <polyline points="12,6 12,12 16,14"></polyline>
                </svg>
                <span class="comment-time">${this.formatDate(reply.created_at)}</span>
              </div>
            </div>
          </div>
          
          <div class="comment-actions-menu">
            <button class="menu-btn" data-comment-id="${reply.id}">
              <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <circle cx="12" cy="12" r="1"></circle>
                <circle cx="19" cy="12" r="1"></circle>
                <circle cx="5" cy="12" r="1"></circle>
              </svg>
            </button>
            <div class="dropdown-menu" id="dropdown-${reply.id}">
              <button class="dropdown-item edit-comment-btn" data-comment-id="${reply.id}" style="display: none;">Edit</button>
              <button class="dropdown-item delete-comment-btn" data-comment-id="${reply.id}" style="display: none;">Delete</button>
              <button class="dropdown-item report-btn" data-comment-id="${reply.id}" style="display: flex;">Report</button>
            </div>
          </div>
        </div>

        <div class="comment-content">
          <div class="comment-text">${formattedContent}</div>
        </div>

        <div class="comment-footer">
          <div class="vote-section">
            <button class="vote-btn upvote-btn" data-comment-id="${reply.id}" data-action="upvote">
              <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M7 14l5-5 5 5"></path>
              </svg>
            </button>
            <span class="vote-count">${reply.like_count || 0}</span>
          </div>
          
          <div class="comment-actions">
            <button class="action-btn reply-btn" data-comment-id="${reply.id}" data-author="${displayName}">Reply</button>
            <button class="action-btn copy-btn" data-comment-id="${reply.id}">Copy</button>
          </div>
        </div>

        <div class="inline-reply-container" data-comment-id="${reply.id}" style="display: none;"></div>
        <div class="inline-edit-container" data-comment-id="${reply.id}" style="display: none;"></div>
      </div>
    `;
    
    return wrapper;
  }

  // Add helper method for date formatting
  formatDate(dateString) {
    const date = new Date(dateString);
    const now = new Date();
    const diffInSeconds = (now - date) / 1000;
    
    if (diffInSeconds < 60) return 'just now';
    if (diffInSeconds < 3600) return `${Math.floor(diffInSeconds / 60)}m ago`;
    if (diffInSeconds < 86400) return `${Math.floor(diffInSeconds / 3600)}h ago`;
    if (diffInSeconds < 604800) return `${Math.floor(diffInSeconds / 86400)}d ago`;
    
    return date.toLocaleDateString();
  }

  // Add helper method for building comment tree
  buildCommentTree(comments) {
    const commentMap = new Map();
    const rootComments = [];
    
    // Create map
    comments.forEach(comment => {
      comment.replies = [];
      commentMap.set(comment.id, comment);
    });
    
    // Build tree
    comments.forEach(comment => {
      if (comment.parent_id && commentMap.has(comment.parent_id)) {
        commentMap.get(comment.parent_id).replies.push(comment);
      } else if (!comment.parent_id) {
        rootComments.push(comment);
      }
    });
    
    return rootComments;
  }

  buildCommentTreeWithReplies(rootComments, replies) {
    const commentMap = new Map();
    
    // Add root comments
    rootComments.forEach(comment => {
      comment.replies = [];
      commentMap.set(comment.id, comment);
    });
    
    // Add replies to their parents
    replies.forEach(reply => {
      const parent = commentMap.get(reply.parent_id);
      if (parent) {
        parent.replies.push(reply);
      }
    });
    
    return rootComments;
  }

  createCommentElementWithReplies(comment) {
    const wrapper = this.createCommentElement(comment);
    
    // Add replies if they exist
    if (comment.replies && comment.replies.length > 0) {
      const repliesContainer = wrapper.querySelector('.replies-container');
      if (repliesContainer) {
        comment.replies.forEach(reply => {
          const replyElement = this.createReplyElement(reply);
          repliesContainer.appendChild(replyElement);
        });
        
        // Add load more replies button if there are more than 3
        if (comment.replies.length >= 3) {
          const loadMoreReplies = document.createElement('div');
          loadMoreReplies.className = 'load-more-replies';
          loadMoreReplies.innerHTML = `
            <button class="load-more-replies-btn" data-comment-id="${comment.id}" data-loaded="3" data-total="${comment.replies.length}">
              <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <polyline points="6,9 12,15 18,9"></polyline>
              </svg>
              Show more replies
            </button>
          `;
          wrapper.appendChild(loadMoreReplies);
        }
      }
    }
    
    return wrapper;
  }

  async loadMoreReplies(commentId, currentlyLoaded) {
    try {
      const { data: replies, error } = await this.supabase
        .from('comments')
        .select(`
          *,
          profiles!inner(
            id,
            display_name,
            avatar_type,
            avatar_preset_id,
            avatar_url,
            reputation_score,
            is_admin,
            membership_type
          ),
          comment_reactions(*),
          comment_likes(*),
          comment_bookmarks(*)
        `)
        .eq('parent_id', commentId)
        .eq('environment', this.environment)
        .eq('is_deleted', false)
        .in('moderation_status', ['approved', 'auto_approved'])
        .order('created_at', { ascending: true })
        .range(currentlyLoaded, currentlyLoaded + 4); // Load 5 more
      
      if (error) throw error;
      
      if (replies && replies.length > 0) {
        // Find the parent comment wrapper
        const parentWrapper = document.querySelector(`[data-comment-id="${commentId}"]`)?.closest('.comment-wrapper');
        const repliesContainer = parentWrapper?.querySelector('.replies-container') || 
                                parentWrapper?.querySelector('.comment-replies');
        
        if (repliesContainer) {
          // Add new replies
          replies.forEach(reply => {
            const replyElement = this.createReplyElement(reply);
            replyElement.classList.add('new-loaded');
            repliesContainer.appendChild(replyElement);
          });
          
          // Update the load more button
          const loadMoreBtn = parentWrapper?.querySelector('.load-more-replies-btn');
          if (loadMoreBtn) {
            const newLoaded = currentlyLoaded + replies.length;
            const totalReplies = parseInt(loadMoreBtn.dataset.total || '0');
            
            loadMoreBtn.dataset.loaded = newLoaded.toString();
            
            if (newLoaded >= totalReplies) {
              // Remove the load more button
              const loadMoreContainer = loadMoreBtn.closest('.load-more-replies');
              if (loadMoreContainer) {
                loadMoreContainer.remove();
              }
            } else {
              // Update button text
              const remaining = totalReplies - newLoaded;
              loadMoreBtn.innerHTML = `
                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                  <polyline points="6,9 12,15 18,9"></polyline>
                </svg>
                Show ${remaining} more replies
              `;
            }
          }
        }
      }
      
    } catch (error) {
      debugLog('âŒ Error loading more replies:', error);
      showUserError('Failed to load more replies. Please try again.');
    }
  }

  // âœ… CREATE COMMENT AND REPLY ELEMENTS (RETAINED FROM ORIGINAL)
  createCommentElement(comment) {
    const wrapper = document.createElement('div');
    wrapper.className = 'comment-wrapper';
    wrapper.dataset.commentId = comment.id;
    
    const threadLevel = Math.min(comment.thread_level || 0, 4);
    const avatarUrl = this.getUserAvatar(comment.profiles);
    const formattedContent = this.formatContent(comment.content);
    const displayName = comment.profiles?.display_name || 'Anonymous';
    const isAdmin = comment.profiles?.is_admin || false;
    
    wrapper.innerHTML = `
      <div class="comment-card" data-comment-id="${comment.id}" data-user-id="${comment.user_id}" data-created-at="${comment.created_at}" data-thread-level="${threadLevel}">
        <div class="comment-header">
          <div class="comment-user-info">
            <div class="comment-avatar">
              <img src="${avatarUrl}" alt="${displayName}" loading="lazy" />
              ${isAdmin ? '<div class="admin-badge">ğŸ‘‘</div>' : ''}
            </div>
            <div class="comment-meta">
              <div class="user-details">
                <span class="username ${isAdmin ? 'admin' : ''}">${displayName}</span>
                ${isAdmin ? '<span class="admin-badge">Admin</span>' : ''}
              </div>
              <div class="comment-time-wrapper">
                <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                  <circle cx="12" cy="12" r="10"></circle>
                  <polyline points="12,6 12,12 16,14"></polyline>
                </svg>
                <span class="comment-time" title="${new Date(comment.created_at).toLocaleString()}">
                  ${this.formatDate(comment.created_at)}
                </span>
              </div>
            </div>
          </div>
          
          <div class="comment-actions-menu">
            <button class="menu-btn" data-comment-id="${comment.id}" title="More options" aria-label="Comment options">
              <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <circle cx="12" cy="12" r="1"></circle>
                <circle cx="19" cy="12" r="1"></circle>
                <circle cx="5" cy="12" r="1"></circle>
              </svg>
            </button>
            <div class="dropdown-menu" id="dropdown-${comment.id}">
              <button class="dropdown-item edit-comment-btn" data-comment-id="${comment.id}" style="display: none;">
                <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                  <path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"></path>
                  <path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"></path>
                </svg>
                Edit
              </button>
              <button class="dropdown-item delete-comment-btn" data-comment-id="${comment.id}" style="display: none;">
                <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                  <polyline points="3,6 5,6 21,6"></polyline>
                  <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2 2h4a2 2 0 0 1 2 2v2"></path>
                </svg>
                Delete
              </button>
              <button class="dropdown-item report-btn" data-comment-id="${comment.id}" style="display: flex;">
                <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                  <path d="M4 15s1-1 4-1 5 2 8 2 4-1 4-1V3s-1 1-4 1-5-2-8-2-4 1-4 1z"></path>
                  <line x1="4" y1="22" x2="4" y2="15"></line>
                </svg>
                Report
              </button>
            </div>
          </div>
        </div>

        <div class="comment-content">
          <div class="comment-text">${formattedContent}</div>
        </div>

        <div class="comment-footer">
          <div class="vote-section">
            <button class="vote-btn upvote-btn" data-comment-id="${comment.id}" data-action="upvote" title="Upvote">
              <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M7 14l5-5 5 5"></path>
              </svg>
            </button>
            <span class="vote-count" id="vote-count-${comment.id}">${comment.like_count || 0}</span>
            <button class="vote-btn downvote-btn" data-comment-id="${comment.id}" data-action="downvote" title="Downvote">
              <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M17 10l-5 5-5-5"></path>
              </svg>
            </button>
          </div>
          
          <div class="comment-reactions">
            <button class="reaction-btn" data-reaction="like" data-comment-id="${comment.id}" title="Like">
              <span class="reaction-emoji">ğŸ‘</span>
              <span class="reaction-count" id="reaction-like-${comment.id}">${comment.reaction_counts?.like || 0}</span>
            </button>
            <button class="reaction-btn" data-reaction="love" data-comment-id="${comment.id}" title="Love">
              <span class="reaction-emoji">â¤ï¸</span>
              <span class="reaction-count" id="reaction-love-${comment.id}">${comment.reaction_counts?.love || 0}</span>
            </button>

          <div class="comment-actions">
            <button class="action-btn reply-btn" data-comment-id="${comment.id}" data-author="${displayName}" title="Reply">
              <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <polyline points="9,17 4,12 9,7"></polyline>
                <path d="M20 18v-2a4 4 0 0 0-4-4H4"></path>
              </svg>
              Reply
            </button>
            <button class="action-btn bookmark-btn" data-comment-id="${comment.id}" title="Bookmark">
              <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M19 21l-7-5-7 5V5a2 2 0 0 1 2-2h10a2 2 0 0 1 2 2z"></path>
              </svg>
              Save
            </button>
            <button class="action-btn copy-btn" data-comment-id="${comment.id}" title="Copy">
              <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
                <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2 2v1"></path>
              </svg>
              Copy
            </button>
          </div>
        </div>

        <div class="inline-reply-container" data-comment-id="${comment.id}" style="display: none;"></div>
        <div class="inline-edit-container" data-comment-id="${comment.id}" style="display: none;"></div>
        <div class="replies-container comment-replies"></div>
      </div>
    `;
    
    // Update permissions for the new comment after adding to DOM
    setTimeout(() => {
      this.updateCommentPermissions(comment.id);
    }, 100);
    
    return wrapper;
  }

  // Add helper method for creating reply elements
  createReplyElement(reply) {
    const wrapper = document.createElement('div');
    wrapper.className = 'comment-wrapper reply-wrapper';
    wrapper.dataset.commentId = reply.id;
    
    const avatarUrl = this.getUserAvatar(reply.profiles);
    const formattedContent = this.formatContent(reply.content);
    const displayName = reply.profiles?.display_name || 'Anonymous';
    const isAdmin = reply.profiles?.is_admin || false;
    
    wrapper.innerHTML = `
      <div class="comment-card reply-card" data-comment-id="${reply.id}" data-user-id="${reply.user_id}" data-created-at="${reply.created_at}">
        <div class="reply-connector"></div>
        
        <div class="comment-header">
          <div class="comment-user-info">
            <div class="comment-avatar">
              <img src="${avatarUrl}" alt="${displayName}" loading="lazy" />
              ${isAdmin ? '<div class="admin-badge">ğŸ‘‘</div>' : ''}
            </div>
            <div class="comment-meta">
              <div class="user-details">
                <span class="username ${isAdmin ? 'admin' : ''}">${displayName}</span>
              </div>
              <div class="comment-time-wrapper">
                <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                  <circle cx="12" cy="12" r="10"></circle>
                  <polyline points="12,6 12,12 16,14"></polyline>
                </svg>
                <span class="comment-time">${this.formatDate(reply.created_at)}</span>
              </div>
            </div>
          </div>
          
          <div class="comment-actions-menu">
            <button class="menu-btn" data-comment-id="${reply.id}">
              <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <circle cx="12" cy="12" r="1"></circle>
                <circle cx="19" cy="12" r="1"></circle>
                <circle cx="5" cy="12" r="1"></circle>
              </svg>
            </button>
            <div class="dropdown-menu" id="dropdown-${reply.id}">
              <button class="dropdown-item edit-comment-btn" data-comment-id="${reply.id}" style="display: none;">
                <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                  <path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"></path>
                  <path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"></path>
                </svg>
                Edit
              </button>
              <button class="dropdown-item delete-comment-btn" data-comment-id="${reply.id}" style="display: none;">
                <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                  <polyline points="3,6 5,6 21,6"></polyline>
                  <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2 2h4a2 2 0 0 1 2 2v2"></path>
                </svg>
                Delete
              </button>
              <button class="dropdown-item report-btn" data-comment-id="${reply.id}" style="display: flex;">
                <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                  <path d="M4 15s1-1 4-1 5 2 8 2 4-1 4-1V3s-1 1-4 1-5-2-8-2-4 1-4 1z"></path>
                  <line x1="4" y1="22" x2="4" y2="15"></line>
                </svg>
                Report
              </button>
            </div>
          </div>
        </div>

        <div class="comment-content">
          <div class="comment-text">${formattedContent}</div>
        </div>

        <div class="comment-footer">
          <div class="vote-section">
            <button class="vote-btn upvote-btn" data-comment-id="${reply.id}" data-action="upvote">
              <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M7 14l5-5 5 5"></path>
              </svg>
            </button>
            <span class="vote-count">${reply.like_count || 0}</span>
            <button class="vote-btn downvote-btn" data-comment-id="${reply.id}" data-action="downvote">
              <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M17 10l-5 5-5-5"></path>
              </svg>
            </button>
          </div>
          
          <div class="comment-reactions">
            <button class="reaction-btn" data-reaction="like" data-comment-id="${reply.id}">
              <span class="reaction-emoji">ğŸ‘</span>
              <span class="reaction-count">${reply.reaction_counts?.like || 0}</span>
            </button>
            <button class="reaction-btn" data-reaction="love" data-comment-id="${reply.id}">
              <span class="reaction-emoji">â¤ï¸</span>
              <span class="reaction-count">${reply.reaction_counts?.love || 0}</span>
            </button>
          </div>

          <div class="comment-actions">
            <button class="action-btn reply-btn" data-comment-id="${reply.id}" data-author="${displayName}">
              <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <polyline points="9,17 4,12 9,7"></polyline>
                <path d="M20 18v-2a4 4 0 0 0-4-4H4"></path>
              </svg>
              Reply
            </button>
            <button class="action-btn copy-btn" data-comment-id="${reply.id}">

// src/lib/supabase.ts - FIXED SINGLETON
import { createClient, SupabaseClient } from '@supabase/supabase-js'
import { config } from './config';

// âœ… GLOBAL SINGLETON - Prevent multiple instances
declare global {
  var __supabase_instance: SupabaseClient | undefined;
}

function createSupabaseClient(): SupabaseClient {
  // Return existing global instance if available
  if (globalThis.__supabase_instance) {
    console.log('ğŸ”„ Reusing global Supabase instance');
    return globalThis.__supabase_instance;
  }

  console.log('ğŸ†• Creating single Supabase instance');
  
  // Validate environment variables
  const supabaseUrl = config.supabase.url;
  const supabaseAnonKey = config.supabase.anonKey;

  if (!supabaseUrl || !supabaseAnonKey) {
    throw new Error('Missing Supabase environment variables');
  }

  // Create single instance with environment-specific storage
  const client = createClient(supabaseUrl, supabaseAnonKey, {
    auth: {
      autoRefreshToken: true,
      persistSession: true,
      detectSessionInUrl: true,
      flowType: 'pkce',
      storage: typeof window !== 'undefined' ? window.localStorage : undefined,
      storageKey: `tinkbyte-auth-${config.environment}` // Environment-specific key
    },
    global: {
      headers: {
        'X-Environment': config.environment,
        'X-Client-Info': `tinkbyte-static-${config.environment}`
      }
    }
  });

  // Store globally to prevent multiple instances
  globalThis.__supabase_instance = client;
  
  return client;
}

// Export the singleton
export const supabase = createSupabaseClient();
export { createSupabaseClient as getSupabaseClient };


// AuthState class
export class AuthState {
  private static instance: AuthState | null = null;
  private currentUser: any = null;
  private currentSession: any = null;
  private listeners: Array<(user: any) => void> = [];

  private constructor() {
    this.initializeAuth();
  }

  static getInstance(): AuthState {
    if (!AuthState.instance) {
      AuthState.instance = new AuthState();
    }
    return AuthState.instance;
  }

  async initialize(): Promise<void> {
    await this.initializeAuth();
  }

  private async initializeAuth() {
    const { data: { session } } = await supabase.auth.getSession();
    this.currentSession = session;
    this.currentUser = session?.user || null;

    // Listen for auth changes
    supabase.auth.onAuthStateChange((event, session) => {
      this.currentSession = session;
      this.currentUser = session?.user || null;
      this.notifyListeners();
    });
  }

  getCurrentUser() {
    return this.currentUser;
  }

  getCurrentSession() {
    return this.currentSession;
  }

  isAuthenticated(): boolean {
    return !!this.currentUser;
  }

  onAuthStateChange(callback: (user: any) => void) {
    this.listeners.push(callback);
    return () => {
      this.listeners = this.listeners.filter(listener => listener !== callback);
    };
  }

  private notifyListeners() {
    this.listeners.forEach(listener => listener(this.currentUser));
  }

  async signOut() {
    const { error } = await supabase.auth.signOut();
    if (!error) {
      this.currentUser = null;
      this.currentSession = null;
      this.notifyListeners();
    }
    return { error };
  }
}

// Database helpers
export const db = {
  profiles: () => supabase.from('profiles'),
  comments: () => supabase.from('comments'),
  commentLikes: () => supabase.from('comment_likes'),
  commentModeration: () => supabase.from('comment_moderation'),
  commentReactions: () => supabase.from('comment_reactions'),
  commentBookmarks: () => supabase.from('comment_bookmarks'),
  commentDrafts: () => supabase.from('comment_drafts'),
  commentSaves: () => supabase.from('comment_saves'),
  commentEditHistory: () => supabase.from('comment_edit_history'),
  commentNotifications: () => supabase.from('comment_notifications'),
  userRateLimits: () => supabase.from('user_rate_limits'),
  newsletterSubscriptions: () => supabase.from('newsletter_subscriptions'),
  userCategoryFollows: () => supabase.from('user_category_follows'),
  articles: () => supabase.from('articles'),
  articleLikes: () => supabase.from('article_likes'),
  articleReads: () => supabase.from('article_reads'),
  articleFollows: () => supabase.from('article_follows'),
  articleSaves: () => supabase.from('article_saves'),
  authorFollows: () => supabase.from('author_follows'),
  moderationRules: () => supabase.from('moderation_rules'),
  categories: () => supabase.from('categories'),
  authors: () => supabase.from('authors'),
  podcasts: () => supabase.from('podcasts'),
  threads: () => supabase.from('threads'),
  userActivities: () => supabase.from('user_activities'),
  userFollows: () => supabase.from('user_follows'),
  userPreferences: () => supabase.from('user_preferences'),
};

// Environment-aware query helpers
export const envDb = {
  profiles: {
    select: (columns: string = '*') => db.profiles().select(columns).eq('environment', config.environment),
    insert: (data: Partial<Profile>) => db.profiles().insert({ ...data, environment: config.environment } as any),
    update: (data: Partial<Profile>) => db.profiles().update({ ...data, environment: config.environment } as any),
    delete: () => db.profiles().delete().eq('environment', config.environment),
  },
  comments: {
    select: (columns: string = '*') => db.comments().select(columns).eq('environment', config.environment),
    insert: (data: any) => db.comments().insert({ ...data, environment: config.environment }),
    update: (data: any) => db.comments().update({ ...data, environment: config.environment }),
    delete: () => db.comments().delete().eq('environment', config.environment),
  },
  commentLikes: {
    select: (columns: string = '*') => db.commentLikes().select(columns).eq('environment', config.environment),
    insert: (data: any) => db.commentLikes().insert({ ...data, environment: config.environment }),
    update: (data: any) => db.commentLikes().update({ ...data, environment: config.environment }),
    delete: () => db.commentLikes().delete().eq('environment', config.environment),
  },
  commentModeration: {
    select: (columns: string = '*') => db.commentModeration().select(columns).eq('environment', config.environment),
    insert: (data: any) => db.commentModeration().insert({ ...data, environment: config.environment }),
    update: (data: any) => db.commentModeration().update({ ...data, environment: config.environment }),
    delete: () => db.commentModeration().delete().eq('environment', config.environment),
  },
  commentReactions: {
    select: (columns: string = '*') => db.commentReactions().select(columns).eq('environment', config.environment),
    insert: (data: any) => db.commentReactions().insert({ ...data, environment: config.environment }),
    update: (data: any) => db.commentReactions().update({ ...data, environment: config.environment }),
    delete: () => db.commentReactions().delete().eq('environment', config.environment),
  },
  commentBookmarks: {
    select: (columns: string = '*') => db.commentBookmarks().select(columns).eq('environment', config.environment),
    insert: (data: any) => db.commentBookmarks().insert({ ...data, environment: config.environment }),
    update: (data: any) => db.commentBookmarks().update({ ...data, environment: config.environment }),
    delete: () => db.commentBookmarks().delete().eq('environment', config.environment),
  },
  commentDrafts: {
    select: (columns: string = '*') => db.commentDrafts().select(columns).eq('environment', config.environment),
    insert: (data: any) => db.commentDrafts().insert({ ...data, environment: config.environment }),
    update: (data: any) => db.commentDrafts().update({ ...data, environment: config.environment }),
    delete: () => db.commentDrafts().delete().eq('environment', config.environment),
  },
  commentNotifications: {
    select: (columns: string = '*') => db.commentNotifications().select(columns).eq('environment', config.environment),
    insert: (data: any) => db.commentNotifications().insert({ ...data, environment: config.environment }),
    update: (data: any) => db.commentNotifications().update({ ...data, environment: config.environment }),
    delete: () => db.commentNotifications().delete().eq('environment', config.environment),
  },
  userRateLimits: {
    select: (columns: string = '*') => db.userRateLimits().select(columns).eq('environment', config.environment),
    insert: (data: any) => db.userRateLimits().insert({ ...data, environment: config.environment }),
    update: (data: any) => db.userRateLimits().update({ ...data, environment: config.environment }),
    delete: () => db.userRateLimits().delete().eq('environment', config.environment),
  },
  userCategoryFollows: {
    select: (columns: string = '*') => db.userCategoryFollows().select(columns).eq('environment', config.environment),
    insert: (data: any) => db.userCategoryFollows().insert({ ...data, environment: config.environment }),
    update: (data: any) => db.userCategoryFollows().update({ ...data, environment: config.environment }),
    delete: () => db.userCategoryFollows().delete().eq('environment', config.environment),
  },
  newsletterSubscriptions: {
    select: (columns: string = '*') => db.newsletterSubscriptions().select(columns).eq('environment', config.environment),
    insert: (data: any) => db.newsletterSubscriptions().insert({ ...data, environment: config.environment }),
    update: (data: any) => db.newsletterSubscriptions().update({ ...data, environment: config.environment }),
    delete: () => db.newsletterSubscriptions().delete().eq('environment', config.environment),
  },
  userActivities: {
    select: (columns: string = '*') => db.userActivities().select(columns).eq('environment', config.environment),
    insert: (data: any) => db.userActivities().insert({ ...data, environment: config.environment }),
    update: (data: any) => db.userActivities().update({ ...data, environment: config.environment }),
    delete: () => db.userActivities().delete().eq('environment', config.environment),
  },
};

// Utility for RPC calls
export const rpc = (fn: string, params: object) => 
  supabase.rpc(fn, params);

export type TableName = keyof typeof db;

// All your interfaces - keeping them exactly as they were
export interface User {
  id: string;
  email?: string;
  created_at: string;
  user_metadata?: {
    display_name?: string;
    full_name?: string;
    given_name?: string;
    family_name?: string;
    avatar_url?: string;
    picture?: string;
    name?: string;
    provider?: string;
  };
  app_metadata?: {
    provider?: string;
    providers?: string[];
  };
}

export interface UserCategoryFollow {
  id: string;
  user_id: string;
  category_slug: string;
  environment: string;
  created_at: string;
  updated_at: string;
}

export interface AdminUser extends User {
  is_admin?: boolean;
  admin_level?: 'super' | 'moderator' | 'editor';
}

export interface AdminProfile extends Profile {
  admin_permissions?: string[];
  last_admin_activity?: string;
}

export interface AdminSession {
  user: AdminUser;
  profile: AdminProfile;
  permissions: string[];
  expires_at: string;
}

export interface CommentNotification {
  id: string;
  user_id: string;
  comment_id: string;
  notification_type: 'mention' | 'reply' | 'reaction';
  message?: string;
  is_read: boolean;
  environment: string;
  created_at: string;
}

export interface Profile {
  id: string;
  display_name: string | null;
  first_name: string | null;
  full_name?: string; 
  last_name: string | null;
  bio: string | null;
  avatar_type: 'preset' | 'uploaded' | 'google'; 
  avatar_preset_id: number | null;
  avatar_url: string | null;
  website?: string | null;
  twitter_handle?: string | null;
  linkedin_url?: string | null;
  github_username?: string | null;
  location?: string | null;
  job_title?: string | null;
  company?: string | null;
  total_reads: number;
  total_comments: number;
  total_articles: number;
  reputation_score: number;
  following_count: number;
  followers_count: number;
  is_public: boolean;
  membership_type: 'free' | 'premium' | 'enterprise';
  is_admin: boolean;
  email?: string;
  environment?: string;
  created_at: string;
  updated_at: string;
}

export interface Article {
  id: string;
  title: string;
  slug: string;
  content: string;
  excerpt: string;
  author_id: string;
  category_id: string;
  tags: string[];
  featured_image?: string;
  is_published: boolean;
  is_featured: boolean;
  view_count: number;
  like_count: number;
  comment_count: number;
  reading_time: number;
  seo_title?: string;
  seo_description?: string;
  published_at?: string;
  created_at: string;
  updated_at: string;
  environment?: string;
  author?: Profile;
  category?: Category;
  comments?: Comment[];
}

export interface Category {
  id: string;
  name: string;
  slug: string;
  description?: string;
  color: string;
  icon?: string;
  parent_id?: string;
  sort_order: number;
  article_count: number;
  is_active: boolean;
  environment?: string;
  created_at: string;
  updated_at: string;
}

export interface Comment {
  id: string;
  content: string;
  user_id: string;
  article_id: string;
  parent_id?: string;
  moderation_status: 'pending' | 'approved' | 'flagged' | 'hidden' | 'auto_approved';
  like_count: number;
  environment?: string;
  created_at: string;
  updated_at: string;
  author?: Profile;
  replies?: Comment[];
}

export interface UserFollow {
  id: string;
  follower_id: string;
  following_id: string;
  follow_type: 'user' | 'category';
  created_at: string;
}

export interface ArticleFollow {
  id: string;
  user_id: string;
  article_id: string;
  created_at: string;
}

export interface ArticleLike {
  id: string;
  user_id: string;
  article_id: string;
  created_at: string;
}

export interface ArticleSave {
  id: string;
  user_id: string;
  article_id: string;
  created_at: string;
}

export interface CommentSave {
  id: string;
  user_id: string;
  comment_id: string;
  created_at: string;
}

export interface CommentLike {
  id: string;
  user_id: string;
  comment_id: string;
  environment?: string;
  created_at: string;
}

export interface ArticleRead {
  id: string;
  user_id: string;
  article_id: string;
  read_percentage: number;
  time_spent_seconds: number;
  created_at: string;
}

export interface UserActivity {
  id: string;
  user_id: string;
  activity_type: string;
  entity_type: string;
  entity_id: string;
  description: string;
  metadata: any;
  environment: string;
  created_at: string;
}

export interface Newsletter {
  id: string;
  email: string;
  name?: string;
  is_subscribed: boolean;
  subscription_source: string;
  preferences: {
    weekly_digest: boolean;
    new_articles: boolean;
    featured_content: boolean;
  };
  environment?: string;
  created_at: string;
  updated_at: string;
}

// Helper function for retry logic
export async function withRetry(operation: () => Promise<any>, maxRetries = 3) {
  for (let i = 0; i < maxRetries; i++) {
    try {
      return await operation();
    } catch (error) {
      if (i === maxRetries - 1) throw error;
      await new Promise(resolve => setTimeout(resolve, 1000 * (i + 1)));
    }
  }
  throw new Error('Max retries exceeded');
}

// Database query helpers with retry and environment awareness
export const dbWithRetry = {
  async getProfile(userId: string) {
    return withRetry(async () => {
      const { data, error } = await supabase
        .from("profiles")
        .select("*")
        .eq("id", userId)
        .eq("environment", config.environment)
        .single();
      
      if (error) throw error;
      return data;
    });
  },

  async updateProfile(userId: string, updates: Partial<Profile>) {
    return withRetry(async () => {
      const { data, error } = await supabase
        .from("profiles")
        .update(updates)
        .eq("id", userId)
        .eq('environment', config.environment)
        .select()
        .single();
      
      if (error) throw error;
      return data;
    });
  }
};

// Complete TinkByteAPI with ALL methods
export class TinkByteAPI {
  // UUID generator with fallback
  private static generateUUID(): string {
    if (typeof crypto !== 'undefined' && crypto.randomUUID) {
      return crypto.randomUUID();
    }
    // Fallback for environments without crypto.randomUUID
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
      const r = Math.random() * 16 | 0;
      const v = c === 'x' ? r : (r & 0x3 | 0x8);
      return v.toString(16);
    });
  }

  // **CORE ACTIVITY RECORDING METHODS**
  static async recordActivity(activityType: string, entityType: string, entityId: string, metadata?: any) {
    try {
      const { data: { session } } = await supabase.auth.getSession();
      const user = session?.user;

      if (!user) return { success: false, error: 'User not authenticated' };

      // Create a readable description based on activity type
      let description = '';
      switch (activityType) {
        case 'comment':
          description = `Commented on ${entityType}`;
          break;
        case 'like':
          description = `Liked a ${entityType}`;
          break;
        case 'unlike':
          description = `Unliked a ${entityType}`;
          break;
        case 'follow':
          description = `Followed a ${entityType}`;
          break;
        case 'unfollow':
          description = `Unfollowed a ${entityType}`;
          break;
        case 'read':
          description = `Read an ${entityType}`;
          break;
        case 'save':
          description = `Saved an ${entityType}`;
          break;
        case 'bookmark':
          description = `Bookmarked a ${entityType}`;
          break;
        default:
          description = `Performed ${activityType} on ${entityType}`;
      }

      const { data, error } = await supabase
        .from('user_activities')
        .insert({
          user_id: user.id,
          activity_type: activityType,
          entity_type: entityType,
          entity_id: entityId,
          description: description,
          metadata: metadata || {},
          environment: config.environment,
          created_at: new Date().toISOString()
        })
        .select()
        .single();

      if (error) throw error;
      return { success: true, data };
    } catch (error: any) {
      console.error('Error recording activity:', error);
      return { success: false, error: error.message };
    }
  }

  // Update profile statistics
 static async updateProfileStats(userId: string, field: string, increment: number = 1) {
  try {
    // âœ… REMOVE ENVIRONMENT FILTER
    const { data: profile, error: fetchError } = await supabase
      .from('profiles')
      .select(field)
      .eq('id', userId)
      .single();

    if (fetchError) throw fetchError;

    const currentValue = profile[field] || 0;
    const newValue = Math.max(0, currentValue + increment);

    const { error: updateError } = await supabase
      .from('profiles')
      .update({ [field]: newValue })
      .eq('id', userId);

    if (updateError) throw updateError;
    return { success: true };
  } catch (error: any) {
    console.error('Error updating profile stats:', error);
    return { success: false, error: error.message };
  }
}

  // **ARTICLE OPERATIONS**
  static async getArticles(options: {
    limit?: number;
    offset?: number;
    category?: string;
    author?: string;
    featured?: boolean;
    published?: boolean;
    search?: string;
  } = {}) {
    try {
      let query = supabase
        .from('articles')
        .select(`
          *,
          author:authors!articles_author_id_fkey(*),
          category:categories!articles_category_slug_fkey(*)
        `)
        .order('published_at', { ascending: false });

      if (options.published !== false) {
        query = query.eq('is_published', true);
      }

      if (options.featured) {
        query = query.eq('is_featured', true);
      }

      if (options.category) {
        query = query.eq('category_slug', options.category);
      }

      if (options.author) {
        query = query.eq('author_id', options.author);
      }

      if (options.search) {
        query = query.or(`title.ilike.%${options.search}%,content.ilike.%${options.search}%`);
      }

      if (options.limit) {
        query = query.limit(options.limit);
      }

      if (options.offset) {
        query = query.range(options.offset, options.offset + (options.limit || 10) - 1);
      }

      const { data, error } = await query;

      if (error) throw error;

      return { success: true, data: data as Article[] };
    } catch (error: any) {
      console.error('Error fetching articles:', error);
      return { success: false, error: error.message };
    }
  }

  static async getArticle(slug: string) {
    try {
      const { data, error } = await supabase
        .from('articles')
        .select(`
          *,
          author:authors!articles_author_id_fkey(*),
          category:categories!articles_category_slug_fkey(*)
        `)
        .eq('slug', slug)
        .eq('is_published', true)
        .single();

      if (error) throw error;

      // Increment view count
      await supabase
        .from('articles')
        .update({ view_count: (data.view_count || 0) + 1 })
        .eq('id', data.id);

      return { success: true, data: data as Article };
    } catch (error: any) {
      console.error('Error fetching article:', error);
      return { success: false, error: error.message };
    }
  }


  // **ARTICLE READ TRACKING**
  static async recordArticleRead(articleSlug: string, readPercentage: number = 100, timeSpentSeconds: number = 0) {
    try {
      const { data: { session } } = await supabase.auth.getSession();
      const user = session?.user;

      if (!user) return { success: false, error: 'User not authenticated' };

      // Check if already read
      const { data: existingRead } = await supabase
        .from('article_reads')
        .select('id, read_percentage')
        .eq('user_id', user.id)
        .eq('article_id', articleSlug)
        .single();

      if (existingRead) {
        // Update read percentage if higher
        if (readPercentage > existingRead.read_percentage) {
          await supabase
            .from('article_reads')
            .update({
              read_percentage: readPercentage,
              time_spent_seconds: timeSpentSeconds
            })
            .eq('id', existingRead.id);
        }
      } else {
        // Insert new reading record
        await supabase
          .from('article_reads')
          .insert({
            user_id: user.id,
            article_id: articleSlug,
            read_percentage: readPercentage,
            time_spent_seconds: timeSpentSeconds,
            created_at: new Date().toISOString()
          });

        // Record activity
        await this.recordActivity('read', 'article', articleSlug, {
          read_percentage: readPercentage,
          time_spent_seconds: timeSpentSeconds
        });

        // Update profile stats
        await this.updateProfileStats(user.id, 'total_reads', 1);
      }

      return { success: true };
    } catch (error: any) {
      console.error('Error recording article read:', error);
      return { success: false, error: error.message };
    }
  }

  // **ARTICLE FOLLOWS**
static async followArticle(articleSlug: string) {
  try {
    const { data: { session } } = await supabase.auth.getSession();
    const user = session?.user;

    if (!user) {
      throw new Error('Must be logged in to follow articles');
    }

    // Check if already following
    const { data: existingFollow } = await supabase
      .from('article_follows')
      .select('id')
      .eq('user_id', user.id)
      .eq('article_id', articleSlug)
      .single();

    if (existingFollow) {
      return { success: false, error: 'Already following this article' };
    }

    const { error } = await supabase
      .from('article_follows')
      .insert({
        user_id: user.id,
        article_id: articleSlug,
        created_at: new Date().toISOString()
      });

    if (error) throw error;

    // Record activity
    await this.recordActivity('follow', 'article', articleSlug);

    return { success: true };
  } catch (error: any) {
    console.error('Error following article:', error);
    return { success: false, error: error.message };
  }
}

static async unfollowArticle(articleSlug: string) {
  try {
    const { data: { session } } = await supabase.auth.getSession();
    const user = session?.user;

    if (!user) {
      throw new Error('Must be logged in to unfollow articles');
    }

    const { error } = await supabase
      .from('article_follows')
      .delete()
      .eq('user_id', user.id)
      .eq('article_id', articleSlug);

    if (error) throw error;

    // Record activity
    await this.recordActivity('unfollow', 'article', articleSlug);

    return { success: true };
  } catch (error: any) {
    console.error('Error unfollowing article:', error);
    return { success: false, error: error.message };
  }
}

  // **ARTICLE LIKES**
  static async toggleArticleLike(articleId: string) {
    try {
      const { data: { session } } = await supabase.auth.getSession();
      const user = session?.user;

      if (!user) {
        throw new Error('Must be logged in to like articles');
      }

      // Check if already liked
      const { data: existingLike } = await supabase
        .from('article_likes')
        .select('id')
        .eq('user_id', user.id)
        .eq('article_id', articleId)
        .single();

      if (existingLike) {
        // Remove like
        await supabase
          .from('article_likes')
          .delete()
          .eq('id', existingLike.id);

        // Record unlike activity
        await this.recordActivity('unlike', 'article', articleId);

        return { success: true, liked: false };
      } else {
        // Add like
        await supabase
          .from('article_likes')
          .insert({
            user_id: user.id,
            article_id: articleId,
            created_at: new Date().toISOString()
          });

        // Record like activity
        await this.recordActivity('like', 'article', articleId);

        return { success: true, liked: true };
      }
    } catch (error: any) {
      console.error('Error toggling article like:', error);
      return { success: false, error: error.message };
    }
  }

  // **ARTICLE SAVES**
  static async toggleArticleSave(articleId: string) {
    try {
      const { data: { session } } = await supabase.auth.getSession();
      const user = session?.user;

      if (!user) {
        throw new Error('Must be logged in to save articles');
      }

      // Check if already saved
      const { data: existingSave } = await supabase
        .from('article_saves')
        .select('id')
        .eq('user_id', user.id)
        .eq('article_id', articleId)
        .single();

      if (existingSave) {
        // Remove save
        await supabase
          .from('article_saves')
          .delete()
          .eq('id', existingSave.id);

        return { success: true, saved: false };
      } else {
        // Add save
        await supabase
          .from('article_saves')
          .insert({
            user_id: user.id,
            article_id: articleId,
            created_at: new Date().toISOString()
          });

        // Record save activity
        await this.recordActivity('save', 'article', articleId);

        return { success: true, saved: true };
      }
    } catch (error: any) {
      console.error('Error toggling article save:', error);
      return { success: false, error: error.message };
    }
  }

  // **COMMENT OPERATIONS**
  static async getComments(articleId: string) {
    try {
      const { data, error } = await supabase
        .from('comments')
        .select(`
          *,
          profiles!inner(
            id,
            display_name,
            avatar_type,
            avatar_preset_id,
            avatar_url,
            reputation_score,
            is_admin,
            membership_type
          ),
          comment_reactions(
            reaction_type,
            user_id
          ),
          comment_likes(
            user_id
          ),
          comment_bookmarks(
            user_id
          )
        `)
        .eq('article_id', articleId)
        .eq('environment', config.environment)
        .eq('is_deleted', false)
        .in('moderation_status', ['approved', 'auto_approved'])
        .order('created_at', { ascending: false });

      if (error) {
        console.error('Error fetching comments:', error);
        throw error;
      }

      return { success: true, data: data || [] };
    } catch (error: any) {
      console.error('Error fetching comments:', error);
      return { success: false, error: error.message };
    }
  }

static async addComment(articleSlug: string, content: string, parentId: string | null = null) {
  try {
    console.log('ğŸ” addComment called with:', { articleSlug, contentLength: content.length, parentId });
    
    const { data: { session }, error: sessionError } = await supabase.auth.getSession();
    
    if (sessionError || !session?.user) {
      throw new Error('Must be logged in to comment');
    }

    const user = session.user;
    console.log('ğŸ‘¤ User authenticated:', user.email);

    // âœ… ENHANCED ARTICLE VERIFICATION
    console.log('ğŸ” Verifying article exists with slug:', articleSlug);
    
    const { data: article, error: articleError } = await supabase
      .from('articles')
      .select('slug, title, id')
      .eq('slug', articleSlug)
      .single();

    console.log('ğŸ“Š Article query result:', { article, error: articleError });

    if (articleError || !article) {
      console.error('âŒ Article verification failed:', articleError);
      throw new Error(`Article with slug "${articleSlug}" not found. Error: ${articleError?.message || 'Not found'}`);
    }

    console.log('âœ… Article verified:', article.title);

    // Calculate thread level for replies
    let threadLevel = 0;
    if (parentId) {
      console.log('ğŸ”— Calculating thread level for parent:', parentId);
      
      const { data: parentComment } = await supabase
        .from('comments')
        .select('thread_level')
        .eq('id', parentId)
        .eq('environment', config.environment)
        .single();
      
      if (parentComment) {
        threadLevel = Math.min((parentComment.thread_level || 0) + 1, 4);
        console.log('ğŸ“ Thread level calculated:', threadLevel);
      }
    }

    const commentId = this.generateUUID();
    console.log('ğŸ†” Generated comment ID:', commentId);
    
    const commentData = {
      id: commentId,
      content: content,
      raw_content: content,
      user_id: user.id,
      article_id: articleSlug, // âœ… This should match articles.slug exactly
      parent_id: parentId || null,
      thread_level: threadLevel,
      environment: config.environment,
      moderation_status: 'auto_approved' as const,
      auto_approved_reason: 'Auto-approved by content filter',
      quality_score: 50,
      like_count: 0,
      reply_count: 0,
      created_at: new Date().toISOString(),
      updated_at: new Date().toISOString()
    };

    console.log('ğŸ’¾ Inserting comment data:', {
      ...commentData,
      content: content.substring(0, 50) + '...'
    });

    // Insert comment
    const { data: insertedComment, error: insertError } = await supabase
      .from('comments')
      .insert(commentData)
      .select('*')
      .single();

    if (insertError) {
      console.error('âŒ Insert error:', insertError);
      throw insertError;
    }

    console.log('âœ… Comment inserted successfully:', insertedComment.id);

    // Record activity
    await this.recordActivity('comment', 'article', articleSlug, {
      comment_id: commentId,
      article_title: article.title,
      is_reply: !!parentId
    });

    // Update profile stats
    await this.updateProfileStats(user.id, 'total_comments', 1);

    // Process mentions
    await this.processMentions(content, insertedComment.id, user.email?.split('@')[0] || 'Someone');

    // Fetch profile separately - TRY WITHOUT ENVIRONMENT FILTER FIRST
    console.log('ğŸ‘¤ Fetching user profile...');
    
    let { data: profileData, error: profileError } = await supabase
      .from('profiles')
      .select(`
        id, display_name, avatar_type, avatar_preset_id, avatar_url,
        reputation_score, is_admin, membership_type
      `)
      .eq('id', user.id)
      .eq('environment', config.environment)
      .maybeSingle();

    // âœ… FALLBACK WITHOUT ENVIRONMENT FILTER
    if (!profileData && config.environment === 'production') {
      console.log('ğŸ”„ Trying profile fetch without environment filter...');
      
      const { data: fallbackProfile } = await supabase
        .from('profiles')
        .select(`
          id, display_name, avatar_type, avatar_preset_id, avatar_url,
          reputation_score, is_admin, membership_type
        `)
        .eq('id', user.id)
        .maybeSingle();
        
      profileData = fallbackProfile;
    }

    console.log('ğŸ‘¤ Profile data:', profileData);

    // Delete draft after successful comment
    try {
      await this.deleteCommentDraft(articleSlug);
    } catch (draftError) {
      console.warn('Could not delete draft:', draftError);
    }

    // Combine the data
    const finalData = {
      ...insertedComment,
      profiles: profileData || {
        id: user.id,
        display_name: user.email?.split('@')[0] || 'User',
        avatar_type: 'preset' as const,
        avatar_preset_id: 1,
        avatar_url: null,
        reputation_score: 0,
        is_admin: false,
        membership_type: 'free' as const
      }
    };

    console.log('ğŸ‰ Comment creation successful!');
    return { success: true, data: finalData };

  } catch (error: any) {
    console.error('âŒ Error adding comment:', error);
    console.error('âŒ Error details:', {
      message: error.message,
      code: error.code,
      details: error.details,
      hint: error.hint
    });
    return { success: false, error: error.message };
  }
}


  // **COMMENT SAVES** 
static async toggleCommentSave(commentId: string) {
  try {
    const { data: { session } } = await supabase.auth.getSession();
    const user = session?.user;

    if (!user) {
      throw new Error('Must be logged in to save comments');
    }

    // Check if already saved
    const { data: existingSave } = await supabase
      .from('comment_saves')
      .select('id')
      .eq('user_id', user.id)
      .eq('comment_id', commentId)
      .single();

    if (existingSave) {
      // Remove save
      await supabase
        .from('comment_saves')
        .delete()
        .eq('id', existingSave.id);

      return { success: true, saved: false };
    } else {
      // Add save
      await supabase
        .from('comment_saves')
        .insert({
          user_id: user.id,
          comment_id: commentId,
          created_at: new Date().toISOString()
        });

      // Record save activity
      await this.recordActivity('save', 'comment', commentId);

      return { success: true, saved: true };
    }
  } catch (error: any) {
    console.error('Error toggling comment save:', error);
    return { success: false, error: error.message };
  }
}

  static async toggleCommentLike(commentId: string) {
    try {
      const { data: { session } } = await supabase.auth.getSession();
      const user = session?.user;

      if (!user) {
        throw new Error('Must be logged in to like comments');
      }

      // Check if already liked
      const { data: existingLike } = await supabase
        .from('comment_likes')
        .select('id')
        .eq('user_id', user.id)
        .eq('comment_id', commentId)
        .eq('environment', config.environment)
        .single();

      if (existingLike) {
        // Remove like
        await supabase
          .from('comment_likes')
          .delete()
          .eq('id', existingLike.id)
          .eq('environment', config.environment);

        // Update comment like count
        const { data: comment } = await supabase
          .from('comments')
          .select('like_count')
          .eq('id', commentId)
          .eq('environment', config.environment)
          .single();

        const newCount = Math.max((comment?.like_count || 1) - 1, 0);
        
        await supabase
          .from('comments')
          .update({ like_count: newCount })
          .eq('id', commentId)
          .eq('environment', config.environment);

        // Record unlike activity
        await this.recordActivity('unlike', 'comment', commentId);

        return { success: true, liked: false };
      } else {
        // Add like
        await supabase
          .from('comment_likes')
          .insert({
            user_id: user.id,
            comment_id: commentId,
            environment: config.environment,
            created_at: new Date().toISOString()
          });

        // Update comment like count
        const { data: comment } = await supabase
          .from('comments')
          .select('like_count')
          .eq('id', commentId)
          .eq('environment', config.environment)
          .single();

        const newCount = (comment?.like_count || 0) + 1;
        
        await supabase
          .from('comments')
          .update({ like_count: newCount })
          .eq('id', commentId)
          .eq('environment', config.environment);

        // Record like activity
        await this.recordActivity('like', 'comment', commentId);

        return { success: true, liked: true };
      }
    } catch (error: any) {
      console.error('Error toggling comment like:', error);
      return { success: false, error: error.message };
    }
  }

  // **FOLLOW OPERATIONS**
  static async followUser(userId: string) {
    try {
      const { data: { session } } = await supabase.auth.getSession();
      const user = session?.user;

      if (!user) {
        throw new Error('Must be logged in to follow users');
      }

      if (user.id === userId) {
        throw new Error('Cannot follow yourself');
      }

      // Check if already following
      const { data: existingFollow } = await supabase
        .from('user_follows')
        .select('id')
        .eq('follower_id', user.id)
        .eq('following_id', userId)
        .eq('follow_type', 'user')
        .eq('is_active', true)
        .single();

      if (existingFollow) {
        return { success: false, error: 'Already following this user' };
      }

      const { error } = await supabase
        .from('user_follows')
        .insert({
          follower_id: user.id,
          following_id: userId,
          follow_type: 'user',
          is_active: true,
          created_at: new Date().toISOString()
        });

      if (error) throw error;

      // Record follow activity
      await this.recordActivity('follow', 'user', userId);

      // Update follower/following counts
      await this.updateProfileStats(user.id, 'following_count', 1);
      await this.updateProfileStats(userId, 'followers_count', 1);

      return { success: true };
    } catch (error: any) {
      console.error('Error following user:', error);
      return { success: false, error: error.message };
    }
  }

  static async unfollowUser(userId: string) {
    try {
      const { data: { session } } = await supabase.auth.getSession();
      const user = session?.user;

      if (!user) {
        throw new Error('Must be logged in to unfollow users');
      }

      const { error } = await supabase
        .from('user_follows')
        .update({ is_active: false })
        .eq('follower_id', user.id)
        .eq('following_id', userId)
        .eq('follow_type', 'user');

      if (error) throw error;

      // Record unfollow activity
      await this.recordActivity('unfollow', 'user', userId);

      // Update follower/following counts
      await this.updateProfileStats(user.id, 'following_count', -1);
      await this.updateProfileStats(userId, 'followers_count', -1);

      return { success: true };
    } catch (error: any) {
      console.error('Error unfollowing user:', error);
      return { success: false, error: error.message };
    }
  }

  static async followCategory(categorySlug: string) {
    try {
      const { data: { session } } = await supabase.auth.getSession();
      const user = session?.user;

      if (!user) {
        throw new Error('Must be logged in to follow categories');
      }

      // Check if already following
      const { data: existingFollow } = await supabase
        .from('user_category_follows')
        .select('id')
        .eq('user_id', user.id)
        .eq('category_slug', categorySlug)
        .eq('environment', config.environment)
        .single();

      if (existingFollow) {
        return { success: false, error: 'Already following this category' };
      }

      const { error } = await supabase
        .from('user_category_follows')
        .insert({
          user_id: user.id,
          category_slug: categorySlug,
          environment: config.environment,
          created_at: new Date().toISOString()
        });

      if (error) throw error;

      // Record activity
      await this.recordActivity('follow', 'category', categorySlug);

      return { success: true };
    } catch (error: any) {
      console.error('Error following category:', error);
      return { success: false, error: error.message };
    }
  }

  static async unfollowCategory(categorySlug: string) {
    try {
      const { data: { session } } = await supabase.auth.getSession();
      const user = session?.user;

      if (!user) {
        throw new Error('Must be logged in to unfollow categories');
      }

      const { error } = await supabase
        .from('user_category_follows')
        .delete()
        .eq('user_id', user.id)
        .eq('category_slug', categorySlug)
        .eq('environment', config.environment);

      if (error) throw error;

      // Record activity
      await this.recordActivity('unfollow', 'category', categorySlug);

      return { success: true };
    } catch (error: any) {
      console.error('Error unfollowing category:', error);
      return { success: false, error: error.message };
    }
  }

  static async followAuthor(authorSlug: string) {
    try {
      const { data: { session } } = await supabase.auth.getSession();
      const user = session?.user;

      if (!user) {
        throw new Error('Must be logged in to follow authors');
      }

      // Check if already following
      const { data: existingFollow } = await supabase
        .from('author_follows')
        .select('id')
        .eq('user_id', user.id)
        .eq('author_slug', authorSlug)
        .single();

      if (existingFollow) {
        return { success: false, error: 'Already following this author' };
      }

      const { error } = await supabase
        .from('author_follows')
        .insert({
          user_id: user.id,
          author_slug: authorSlug,
          created_at: new Date().toISOString()
        });

      if (error) throw error;

      // Record activity
      await this.recordActivity('follow', 'author', authorSlug);

      return { success: true };
    } catch (error: any) {
      console.error('Error following author:', error);
      return { success: false, error: error.message };
    }
  }

  static async unfollowAuthor(authorSlug: string) {
    try {
      const { data: { session } } = await supabase.auth.getSession();
      const user = session?.user;

      if (!user) {
        throw new Error('Must be logged in to unfollow authors');
      }

      const { error } = await supabase
        .from('author_follows')
        .delete()
        .eq('user_id', user.id)
        .eq('author_slug', authorSlug);

      if (error) throw error;

      // Record activity
      await this.recordActivity('unfollow', 'author', authorSlug);

      return { success: true };
    } catch (error: any) {
      console.error('Error unfollowing author:', error);
      return { success: false, error: error.message };
    }
  }

  // **USER PROFILE AND ACTIVITY**
  static async getUserActivity(userId: string, limit = 20) {
    try {
      const { data, error } = await supabase
        .from('user_activities')
        .select('*')
        .eq('user_id', userId)
        .eq('environment', config.environment)
        .order('created_at', { ascending: false })
        .limit(limit);

      if (error) throw error;

      return { success: true, data };
    } catch (error: any) {
      console.error('Error fetching user activity:', error);
      return { success: false, error: error.message };
    }
  }

 static async getProfileData(userId: string) {
  try {
    // Get profile with all stats
    const { data: profile, error: profileError } = await supabase
      .from('profiles')
      .select('*')
      .eq('id', userId)
      .eq('environment', config.environment)
      .single();

    if (profileError) throw profileError;

    // Get following counts using your user_follows table
    const { count: followingCount } = await supabase
      .from('user_follows')
      .select('*', { count: 'exact', head: true })
      .eq('follower_id', userId)
      .eq('follow_type', 'user')
      .eq('is_active', true);

    const { count: followersCount } = await supabase
      .from('user_follows')
      .select('*', { count: 'exact', head: true })
      .eq('following_id', userId)
      .eq('follow_type', 'user')
      .eq('is_active', true);

    // Get category follows count
    const { count: categoryFollowsCount } = await supabase
      .from('user_category_follows')
      .select('*', { count: 'exact', head: true })
      .eq('user_id', userId)
      .eq('environment', config.environment);

    // Get author follows count
    const { count: authorFollowsCount } = await supabase
      .from('author_follows')
      .select('*', { count: 'exact', head: true })
      .eq('user_id', userId);

    // Get article follows count
    const { count: articleFollowsCount } = await supabase
      .from('article_follows')
      .select('*', { count: 'exact', head: true })
      .eq('user_id', userId);

    // Get activity count
    const { count: activityCount } = await supabase
      .from('user_activities')
      .select('*', { count: 'exact', head: true })
      .eq('user_id', userId)
      .eq('environment', config.environment);

    // Get recent activities
    const { data: activities } = await supabase
      .from('user_activities')
      .select('*')
      .eq('user_id', userId)
      .eq('environment', config.environment)
      .order('created_at', { ascending: false })
      .limit(10);

    // Get article reads count
    const { count: articlesReadCount } = await supabase
      .from('article_reads')
      .select('*', { count: 'exact', head: true })
      .eq('user_id', userId);

    // Get comments count
    const { count: commentsCount } = await supabase
      .from('comments')
      .select('*', { count: 'exact', head: true })
      .eq('user_id', userId)
      .eq('environment', config.environment)
      .eq('is_deleted', false);

    // Get article likes count
    const { count: articleLikesCount } = await supabase
      .from('article_likes')
      .select('*', { count: 'exact', head: true })
      .eq('user_id', userId);

    // Get article saves count
    const { count: articleSavesCount } = await supabase
      .from('article_saves')
      .select('*', { count: 'exact', head: true })
      .eq('user_id', userId);

    // Get comment likes count
    const { count: commentLikesCount } = await supabase
      .from('comment_likes')
      .select('*', { count: 'exact', head: true })
      .eq('user_id', userId)
      .eq('environment', config.environment);

    // Get comment saves count
    const { count: commentSavesCount } = await supabase
      .from('comment_saves')
      .select('*', { count: 'exact', head: true })
      .eq('user_id', userId);

    // Get comment bookmarks count
    const { count: commentBookmarksCount } = await supabase
      .from('comment_bookmarks')
      .select('*', { count: 'exact', head: true })
      .eq('user_id', userId)
      .eq('environment', config.environment);

    return {
      success: true,
      data: {
        ...profile,
        // Following counts
        following_count: followingCount || 0,
        followers_count: followersCount || 0,
        category_follows_count: categoryFollowsCount || 0,
        author_follows_count: authorFollowsCount || 0,
        article_follows_count: articleFollowsCount || 0,
        
        // Activity counts
        activity_count: activityCount || 0,
        articles_read_count: articlesReadCount || 0,
        comments_count: commentsCount || 0,
        
        // Interaction counts
        article_likes_count: articleLikesCount || 0,
        article_saves_count: articleSavesCount || 0,
        comment_likes_count: commentLikesCount || 0,
        comment_saves_count: commentSavesCount || 0,
        comment_bookmarks_count: commentBookmarksCount || 0,
        
        // Recent activities
        recent_activities: activities || []
      }
    };
  } catch (error: any) {
    console.error('Error fetching profile data:', error);
    return { success: false, error: error.message };
  }
}

  // **COMMENT DRAFTS**
  static async saveCommentDraft(articleId: string, content: string, draftKey?: string) {
    try {
      const { data: { session } } = await supabase.auth.getSession();
      const user = session?.user;

      if (!user) {
        throw new Error('Must be logged in to save draft');
      }

      const { data, error } = await supabase
        .from('comment_drafts')
        .upsert({
          user_id: user.id,
          article_id: articleId,
          content,
          environment: config.environment,
          updated_at: new Date().toISOString()
        }, {
          onConflict: 'user_id,article_id,environment',
          ignoreDuplicates: false
        })
        .select()
        .single();

      if (error) {
        console.error('Draft save error:', error);
        throw error;
      }
      
      return { success: true, data };
    } catch (error: any) {
      console.error('Error saving comment draft:', error);
      return { success: false, error: error.message };
    }
  }

  static async getCommentDraft(articleId: string, draftKey?: string) {
    try {
      const { data: { session } } = await supabase.auth.getSession();
      const user = session?.user;

      if (!user) {
        return { success: false, error: 'Must be logged in to get draft' };
      }

      // First try current environment
      let { data, error } = await supabase
        .from('comment_drafts')
        .select('*')
        .eq('user_id', user.id)
        .eq('article_id', articleId)
        .eq('environment', config.environment)
        .maybeSingle();

      // If not found and we're in production, try development as fallback
      if (!data && config.environment === 'production') {
        const { data: devData, error: devError } = await supabase
          .from('comment_drafts')
          .select('*')
          .eq('user_id', user.id)
          .eq('article_id', articleId)
          .eq('environment', 'development')
          .maybeSingle();

        if (devData) {
          // Migrate the draft to production
          await supabase
            .from('comment_drafts')
            .update({ environment: 'production' })
            .eq('id', devData.id);
          
          data = { ...devData, environment: 'production' };
        }
      }

      if (error && error.code !== 'PGRST116') throw error;

      return { success: true, data };
    } catch (error: any) {
      console.error('Error getting comment draft:', error);
      return { success: false, error: error.message };
    }
  }

  static async deleteCommentDraft(articleId: string) {
    try {
      const { data: { session } } = await supabase.auth.getSession();
      const user = session?.user;

      if (!user) {
        return { success: false, error: 'Must be logged in to delete draft' };
      }

      const { error } = await supabase
        .from('comment_drafts')
        .delete()
        .eq('user_id', user.id)
        .eq('article_id', articleId)
        .eq('environment', config.environment);

      if (error) {
        console.error('Error deleting draft:', error);
        throw error;
      }

      return { success: true };
    } catch (error: any) {
      console.error('Error deleting comment draft:', error);
      return { success: false, error: error.message };
    }
  }

  // **COMMENT ADDITIONAL FEATURES**
  static async updateComment(commentId: string, content: string, editReason: string | null = null) {
    try {
      const { data: { session } } = await supabase.auth.getSession();
      const user = session?.user;

      if (!user) {
        throw new Error('Must be logged in to update comment');
      }

      // First, get the comment to check ownership and time
      const { data: existingComment, error: fetchError } = await supabase
        .from('comments')
        .select('user_id, created_at, editable_until')
        .eq('id', commentId)
        .eq('environment', config.environment)
        .single();

      if (fetchError || !existingComment) {
        throw new Error('Comment not found');
      }

      // Check ownership
      if (existingComment.user_id !== user.id) {
        throw new Error('You can only edit your own comments');
      }

      // Check time limit (15 minutes)
      const createdAt = new Date(existingComment.created_at);
      const now = new Date();
      const diffInMinutes = (now.getTime() - createdAt.getTime()) / (1000 * 60);

      if (diffInMinutes > 15) {
        throw new Error('Comments can only be edited within 15 minutes of posting');
      }

      // Update the comment
      const { data, error } = await supabase
        .from('comments')
        .update({
          content,
          raw_content: content,
          edit_reason: editReason || null,
          is_edited: true,
          updated_at: new Date().toISOString()
        })
        .eq('id', commentId)
        .eq('user_id', user.id)
        .eq('environment', config.environment)
        .select('*')
        .single();

      if (error) throw error;

      return { success: true, data };
    } catch (error: any) {
      return { success: false, error: error.message };
    }
  }

  static async deleteComment(commentId: string) {
    try {
      const { data: { session } } = await supabase.auth.getSession();
      const user = session?.user;

      if (!user) {
        throw new Error('Must be logged in to delete comment');
      }

      const { error } = await supabase
        .from('comments')
        .update({
          is_deleted: true,
          deleted_at: new Date().toISOString(),
          deleted_by: user.id
        })
        .eq('id', commentId)
        .eq('user_id', user.id)
        .eq('environment', config.environment);

      if (error) throw error;

      return { success: true };
    } catch (error: any) {
      console.error('Error deleting comment:', error);
      return { success: false, error: error.message };
    }
  }

  static async toggleCommentBookmark(commentId: string) {
    try {
      const { data: { session } } = await supabase.auth.getSession();
      const user = session?.user;

      if (!user) {
        throw new Error('Must be logged in to bookmark comments');
      }

      // Check if already bookmarked
      const { data: existingBookmark } = await supabase
        .from('comment_bookmarks')
        .select('id')
        .eq('user_id', user.id)
        .eq('comment_id', commentId)
        .eq('environment', config.environment)
        .single();

      if (existingBookmark) {
        // Remove bookmark
        await supabase
          .from('comment_bookmarks')
          .delete()
          .eq('id', existingBookmark.id);

        return { success: true, bookmarked: false };
      } else {
        // Add bookmark
        await supabase
          .from('comment_bookmarks')
          .insert({
            user_id: user.id,
            comment_id: commentId,
            environment: config.environment,
            created_at: new Date().toISOString()
          });

        // Record bookmark activity
        await this.recordActivity('bookmark', 'comment', commentId);

        return { success: true, bookmarked: true };
      }
    } catch (error: any) {
      console.error('Error toggling bookmark:', error);
      return { success: false, error: error.message };
    }
  }

  static async toggleCommentReaction(commentId: string, reactionType: string) {
    try {
      const { data: { session } } = await supabase.auth.getSession();
      const user = session?.user;

      if (!user) {
        throw new Error('Must be logged in to react to comments');
      }

      // Check if already reacted
      const { data: existingReaction } = await supabase
        .from('comment_reactions')
        .select('id')
        .eq('user_id', user.id)
        .eq('comment_id', commentId)
        .eq('reaction_type', reactionType)
        .eq('environment', config.environment)
        .single();

      if (existingReaction) {
        // Remove reaction
        await supabase
          .from('comment_reactions')
          .delete()
          .eq('id', existingReaction.id);

        // Get updated count
        const { count } = await supabase
          .from('comment_reactions')
          .select('*', { count: 'exact', head: true })
          .eq('comment_id', commentId)
          .eq('reaction_type', reactionType)
          .eq('environment', config.environment);

        return { success: true, reacted: false, count: count || 0 };
      } else {
        // Add reaction
        await supabase
          .from('comment_reactions')
          .insert({
            user_id: user.id,
            comment_id: commentId,
            reaction_type: reactionType,
            environment: config.environment,
            created_at: new Date().toISOString()
          });

        // Get updated count
        const { count } = await supabase
          .from('comment_reactions')
          .select('*', { count: 'exact', head: true })
          .eq('comment_id', commentId)
          .eq('reaction_type', reactionType)
          .eq('environment', config.environment);

        return { success: true, reacted: true, count: count || 0 };
      }
    } catch (error: any) {
      console.error('Error toggling reaction:', error);
      return { success: false, error: error.message };
    }
  }

  // **MENTIONS AND NOTIFICATIONS**
  static async processMentions(content: string, commentId: string, mentionerName: string) {
    try {
      const mentionRegex = /@(\w+)/g;
      const mentions: string[] = [];
      let match: RegExpExecArray | null;

      mentionRegex.lastIndex = 0;
      
      while ((match = mentionRegex.exec(content)) !== null) {
        if (match[1]) {
          mentions.push(match[1].toLowerCase());
        }
      }

      if (mentions.length === 0) return;

      const { data: users, error } = await supabase
        .from('profiles')
        .select('id, display_name')
        .eq('environment', config.environment);

      if (error) {
        console.error('Error fetching users for mentions:', error);
        return;
      }

      const userProfiles = users || [];

      const mentionedUsers = userProfiles.filter((user: any) => {
        if (!user.display_name) return false;
        
        const username = user.display_name.toLowerCase().replace(/\s+/g, '');
        return mentions.includes(username);
      });

      // Create notifications for mentioned users
      for (const mentionedUser of mentionedUsers) {
        try {
          await this.createMentionNotification(commentId, mentionedUser.id, mentionerName);
        } catch (error) {
          console.error(`Failed to create notification for ${mentionedUser.display_name}:`, error);
        }
      }

      // Update the comment with mention_users array
      if (mentionedUsers.length > 0) {
        const mentionedUserIds: string[] = mentionedUsers.map((user: any) => user.id);
        
        const { error: updateError } = await supabase
          .from('comments')
          .update({ 
            mention_users: mentionedUserIds 
          } as { mention_users: string[] })
          .eq('id', commentId)
          .eq('environment', config.environment);

        if (updateError) {
          console.error('Error updating comment with mentions:', updateError);
        }
      }

    } catch (error) {
      console.error('Error processing mentions:', error);
    }
  }

  static async getMentionableUsers(query: string = '') {
    try {
      const { data: { session } } = await supabase.auth.getSession();
      const user = session?.user;

      if (!user) {
        return { success: false, error: 'Must be logged in to get mentionable users' };
      }

      let queryBuilder = supabase
        .from('profiles')
        .select('id, display_name, avatar_type, avatar_preset_id, avatar_url, is_admin, membership_type')
        .eq('environment', config.environment)
        .eq('is_public', true)
        .neq('id', user.id)
        .limit(8);

      if (query && query.length > 0) {
        queryBuilder = queryBuilder.ilike('display_name', `%${query}%`);
      }

      const { data, error } = await queryBuilder;

      if (error) throw error;

      const formattedUsers = (data || []).map((profile: any) => ({
        id: profile.id,
        username: profile.display_name?.toLowerCase().replace(/\s+/g, '') || 'user',
        display_name: profile.display_name || 'User',
        avatar_type: profile.avatar_type,
        avatar_preset_id: profile.avatar_preset_id,
        avatar_url: profile.avatar_url,
        is_admin: profile.is_admin,
        membership_type: profile.membership_type
      }));

      return { success: true, data: formattedUsers };
    } catch (error: any) {
      console.error('Error fetching mentionable users:', error);
      return { success: false, error: error.message };
    }
  }

  static async createMentionNotification(commentId: string, mentionedUserId: string, mentionerName: string) {
    try {
      const { data: { session } } = await supabase.auth.getSession();
      const user = session?.user;

      if (!user) {
        return { success: false, error: 'Must be logged in to create notifications' };
      }

      // Check if user has notification preferences
      const { data: prefs } = await supabase
        .from('comment_notification_preferences')
        .select('mention_notifications')
        .eq('user_id', mentionedUserId)
        .single();

      // If user has disabled mention notifications, don't create notification
      if (prefs && prefs.mention_notifications === false) {
        return { success: true, message: 'User has disabled mention notifications' };
      }

      // Insert notification into comment_notifications table
      const { data, error } = await supabase
        .from('comment_notifications')
        .insert({
          user_id: mentionedUserId,
          comment_id: commentId,
          notification_type: 'mention' as const,
          is_read: false,
          environment: config.environment,
          created_at: new Date().toISOString()
        })
        .select()
        .single();

      if (error) throw error;

      return { success: true, data };
    } catch (error: any) {
      console.error('Error creating mention notification:', error);
      return { success: false, error: error.message };
    }
  }

  static async getUserNotifications(limit = 20) {
    try {
      const { data: { session } } = await supabase.auth.getSession();
      const user = session?.user;

      if (!user) {
        return { success: false, error: 'Must be logged in to get notifications' };
      }

      const { data, error } = await supabase
        .from('comment_notifications')
        .select(`
          *,
          comments!inner(
            id,
            content,
            article_id,
            user_id,
            profiles!inner(
              display_name,
              avatar_type,
              avatar_preset_id,
              avatar_url
            )
          )
        `)
        .eq('user_id', user.id)
        .eq('environment', config.environment)
        .order('created_at', { ascending: false })
        .limit(limit);

      if (error) throw error;

      return { success: true, data: data || [] };
    } catch (error: any) {
      console.error('Error fetching notifications:', error);
      return { success: false, error: error.message };
    }
  }

  static async markNotificationAsRead(notificationId: string) {
    try {
      const { data: { session } } = await supabase.auth.getSession();
      const user = session?.user;

      if (!user) {
        return { success: false, error: 'Must be logged in to mark notifications as read' };
      }

      const { error } = await supabase
        .from('comment_notifications')
        .update({ is_read: true })
        .eq('id', notificationId)
        .eq('user_id', user.id)
        .eq('environment', config.environment);

      if (error) throw error;

      return { success: true };
    } catch (error: any) {
      console.error('Error marking notification as read:', error);
      return { success: false, error: error.message };
    }
  }

  static async getUnreadNotificationCount() {
    try {
      const { data: { session } } = await supabase.auth.getSession();
      const user = session?.user;

      if (!user) {
        return { success: false, error: 'Must be logged in to get notification count' };
      }

      const { count, error } = await supabase
        .from('comment_notifications')
        .select('*', { count: 'exact', head: true })
        .eq('user_id', user.id)
        .eq('environment', config.environment)
        .eq('is_read', false);

      if (error) throw error;

      return { success: true, count: count || 0 };
    } catch (error: any) {
      console.error('Error getting notification count:', error);
      return { success: false, error: error.message };
    }
  }

  // **CATEGORY OPERATIONS**
  static async getCategories() {
    try {
      const { data, error } = await supabase
        .from('categories')
        .select('*')
        .order('sort_order');

      if (error) throw error;

      return { success: true, data: data as Category[] };
    } catch (error: any) {
      console.error('Error fetching categories:', error);
      return { success: false, error: error.message };
    }
  }

  // **NEWSLETTER OPERATIONS**
  static async subscribeToNewsletter(email: string, name?: string) {
    try {
      const { data: { session } } = await supabase.auth.getSession();
      const user = session?.user;

      const { data, error } = await supabase
        .from('newsletter_subscriptions')
        .upsert({
          email,
          user_id: user?.id || null,
          newsletter_type: 'weekly',
          is_active: true,
          environment: config.environment,
          subscribed_at: new Date().toISOString()
        })
        .select()
        .single();

      if (error) throw error;

      return { success: true, data };
    } catch (error: any) {
      console.error('Error subscribing to newsletter:', error);
      return { success: false, error: error.message };
    }
  }

  static async getUserNewsletterSubscriptions() {
    try {
      const { data: { session } } = await supabase.auth.getSession();
      const user = session?.user;

      if (!user) {
        return { success: false, error: 'Must be logged in to get subscriptions' };
      }

      const { data, error } = await supabase
        .from('newsletter_subscriptions')
        .select('*')
        .eq('user_id', user.id)
        .eq('environment', config.environment)
        .eq('is_active', true);

      if (error) throw error;

      return { success: true, data };
    } catch (error: any) {
      console.error('Error fetching newsletter subscriptions:', error);
      return { success: false, error: error.message };
    }
  }

  // **SEARCH OPERATIONS**
  static async searchContent(query: string, type: 'articles' | 'users' | 'all' = 'all') {
    try {
      const results: any = {};

      if (type === 'articles' || type === 'all') {
        const { data: articles } = await supabase
          .from('articles')
          .select(`
            *,
            author:authors!articles_author_id_fkey(*),
            category:categories!articles_category_slug_fkey(*)
          `)
          .or(`title.ilike.%${query}%,content.ilike.%${query}%,excerpt.ilike.%${query}%`)
          .eq('is_published', true)
          .limit(10);

        results.articles = articles || [];
      }

      if (type === 'users' || type === 'all') {
        const { data: users } = await supabase
          .from('profiles')
          .select('*')
          .or(`display_name.ilike.%${query}%,bio.ilike.%${query}%`)
          .eq('is_public', true)
          .eq('environment', config.environment)
          .limit(10);

        results.users = users || [];
      }

      return { success: true, data: results };
    } catch (error: any) {
      console.error('Error searching content:', error);
      return { success: false, error: error.message };
    }
  }

  // **ADMIN OPERATIONS**
  static async moderateComment(commentId: string, action: 'approve' | 'flag' | 'hide' | 'delete', reason?: string) {
    try {
      const { data: { session } } = await supabase.auth.getSession();
      const user = session?.user;

      if (!user) {
        throw new Error('Must be logged in to moderate comments');
      }

      // Get user profile to check admin status
      const { data: profile } = await supabase
        .from('profiles')
        .select('is_admin')
        .eq('id', user.id)
        .eq('environment', config.environment)
        .single();

      if (!profile?.is_admin) {
        throw new Error('Must be admin to moderate comments');
      }

      // Update comment status
      const { error: commentError } = await supabase
        .from('comments')
        .update({
          moderation_status: action === 'approve' ? 'approved' : 
                           action === 'flag' ? 'flagged' : 
                           action === 'hide' ? 'hidden' : 'hidden',
          moderation_reason: reason || null,
          updated_at: new Date().toISOString()
        })
        .eq('id', commentId)
        .eq('environment', config.environment);

      if (commentError) throw commentError;

      // Log moderation action
      const { error: logError } = await supabase
        .from('comment_moderation')
        .insert({
          comment_id: commentId,
          moderator_id: user.id,
          action,
          reason: reason || null,
          environment: config.environment,
          created_at: new Date().toISOString()
        });

      if (logError) throw logError;

      return { success: true };
    } catch (error: any) {
      console.error('Error moderating comment:', error);
      return { success: false, error: error.message };
    }
  }
}

export default supabase;
              <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
                <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2 2v1"></path>
              </svg>
              Copy
            </button>
          </div>
        </div>

        <div class="inline-reply-container" data-comment-id="${reply.id}" style="display: none;"></div>
        <div class="inline-edit-container" data-comment-id="${reply.id}" style="display: none;"></div>
      </div>
    `;
    
    setTimeout(() => {
      this.updateCommentPermissions(reply.id);
    }, 100);
    
    return wrapper;
  }
}

// Close dropdowns when clicking outside
document.addEventListener('click', (e) => {
  if (!e.target.closest('.comment-actions-menu')) {
    document.querySelectorAll('.dropdown-menu.show').forEach(menu => {
      menu.classList.remove('show');
    });
  }
});



debugLog('TinkByte Comments script loaded successfully');

/* ===== CSS VARIABLES & THEME SYSTEM ===== */
:root {
  --primary-bg: #0f1419;
  --secondary-bg: #1a1f29;
  --tertiary-bg: #252d3a;
  --border-color: #2d3748;
  --text-primary: #e2e8f0;
  --text-secondary: #94a3b8;
  --text-muted: #64748b;
  --accent-primary: #3b82f6;
  --accent-secondary: #2563eb;
  --success-color: #10b981;
  --warning-color: #f59e0b;
  --error-color: #ef4444;
  --upvote-color: #10b981;
  --downvote-color: #ef4444;
  --admin-color: #8b5cf6;
  --mention-color: #3b82f6;
  --mention-bg: rgba(59, 130, 246, 0.1);
  --border-radius: 0px;
  --box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
  --transition: opacity 0.2s ease, background-color 0.2s ease, border-color 0.2s ease;
  --z-dropdown: 800;
  --z-modal: 1000;
  --z-notification: 1100;
  --z-tooltip: 1200;
}

[data-theme="light"] {
  --primary-bg: #ffffff;
  --secondary-bg: #f8fafc;
  --tertiary-bg: #e2e8f0;
  --border-color: #cbd5e1;
  --text-primary: #1e293b;
  --text-secondary: #475569;
  --text-muted: #64748b;
  --accent-primary: #3b82f6;
  --accent-secondary: #2563eb;
  --success-color: #059669;
  --warning-color: #d97706;
  --error-color: #dc2626;
  --upvote-color: #059669;
  --downvote-color: #dc2626;
  --admin-color: #7c3aed;
  --mention-color: #3b82f6;
  --mention-bg: rgba(59, 130, 246, 0.1);
  --box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
}

/* ===== GLOBAL RESETS ===== */
* {
  box-sizing: border-box;
  margin: 0;
  padding: 0;
}

/* ===== LOADING STATES ===== */
.loading-state {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  padding: 3rem;
  color: var(--text-muted);
}

.loading-spinner {
  width: 32px;
  height: 32px;
  border: 3px solid var(--border-color);
  border-top: 3px solid var(--accent-primary);
  border-radius: 50%;
  animation: spin 1s linear infinite;
  margin-bottom: 1rem;
}

:global(.dark) .loading-spinner {
  border-color: rgb(51, 65, 85);
  border-top-color: #b4bce1;
}

/* ===== ANIMATIONS ===== */
.animate-spin {
  animation: spin 1s linear infinite;
}

.animate-fade-in {
  animation: fadeIn 0.3s ease-out;
}

@keyframes spin {
  0% { transform: rotate(0deg); }
  100% { transform: rotate(360deg); }
}

@keyframes fadeIn {
  from {
    opacity: 0;
    transform: translateY(20px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

@keyframes slideDown {
  from {
    opacity: 0;
    transform: translateY(-10px);
    max-height: 0;
  }
  to {
    opacity: 1;
    transform: translateY(0);
    max-height: 500px;
  }
}

@keyframes slideInRight {
  from {
    opacity: 0;
    transform: translateX(100%);
  }
  to {
    opacity: 1;
    transform: translateX(0);
  }
}

@keyframes fadeOut {
  to {
    opacity: 0;
    transform: translateX(100%);
  }
}

@keyframes slideInFromTop {
  from {
    opacity: 0;
    transform: translateY(-20px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

@keyframes slideInFromBottom {
  from {
    opacity: 0;
    transform: translateY(20px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

@keyframes fadeInUp {
  from {
    opacity: 0;
    transform: translateY(20px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

@keyframes highlightComment {
  0% { background: var(--accent-primary); opacity: 0.1; }
  100% { background: transparent; opacity: 1; }
}

/* ===== BUTTON LOADING STATES ===== */
.btn-loading {
  pointer-events: none;
  opacity: 0.7;
}

.btn-loading .animate-spin {
  margin-right: 0.5rem;
}

/* ===== COMMENT TRANSITIONS ===== */
.comment-item {
  transition: var(--transition);
  will-change: opacity, border-color;
  contain: layout style;
}

.comment-item.loading {
  opacity: 0.5;
  pointer-events: none;
}

.comment-item.new {
  animation: fadeIn 0.5s ease-out;
  border-left: 3px solid var(--accent-primary);
  padding-left: 1rem;
}

:global(.dark) .comment-item.new {
  border-left-color: #b4bce1;
}

/* ===== MAIN COMMENT SECTION ===== */
.tinkbyte-comment-section {
  max-width: 900px;
  margin: 2rem auto;
  padding: 0 1rem;
  font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", "Roboto", sans-serif;
  background-color: var(--primary-bg);
  color: var(--text-primary);
  line-height: 1.6;
}

/* ===== THREAD HEADER ===== */
.thread-header {
  background: var(--secondary-bg);
  border: 1px solid var(--border-color);
  padding: 1.5rem;
  margin-bottom: 1rem;
  border-radius: var(--border-radius);
}

.thread-header-content {
  display: flex;
  justify-content: space-between;
  align-items: flex-start;
  margin-bottom: 1rem;
  flex-wrap: wrap;
  gap: 1rem;
}

.thread-info {
  display: flex;
  align-items: center;
  gap: 0.75rem;
}

.thread-info svg {
  color: var(--accent-primary);
  flex-shrink: 0;
}

.thread-label {
  font-weight: 700;
  font-size: 0.875rem;
  letter-spacing: 0.1em;
  color: var(--text-primary);
}

.thread-count {
  background: var(--accent-primary);
  color: white;
  padding: 0.25rem 0.5rem;
  border-radius: var(--border-radius);
  font-size: 0.75rem;
  font-weight: 600;
  min-width: 1.5rem;
  text-align: center;
}

.header-actions {
  display: flex;
  align-items: center;
}

.manage-btn {
  display: flex;
  align-items: center;
  gap: 0.5rem;
  background: transparent;
  border: 1px solid var(--border-color);
  color: var(--text-secondary);
  padding: 0.5rem 1rem;
  font-size: 0.875rem;
  cursor: pointer;
  transition: var(--transition);
  font-family: inherit;
  border-radius: var(--border-radius);
}

.manage-btn:hover {
  background: var(--tertiary-bg);
  border-color: var(--accent-primary);
  color: var(--text-primary);
}

.manage-btn .highlight {
  color: var(--accent-primary);
  font-weight: 700;
}

.manage-btn svg {
  flex-shrink: 0;
  opacity: 0.7;
}

.thread-subtitle {
  color: var(--text-secondary);
  font-size: 0.875rem;
  line-height: 1.5;
  margin-top: 0;
}

/* ===== COMMENT FORM SECTION ===== */
.comment-form-section {
  margin-bottom: 1.5rem;
}

/* ===== GUEST COMMENT PROMPT ===== */
.guest-comment-prompt {
  display: flex;
  align-items: center;
  gap: 1rem;
  background: var(--secondary-bg);
  border: 1px solid var(--border-color);
  padding: 1rem;
  margin-bottom: 1rem;
  border-radius: var(--border-radius);
}

.guest-avatar {
  width: 40px;
  height: 40px;
  background: var(--tertiary-bg);
  border: 1px solid var(--border-color);
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
  color: var(--text-secondary);
  flex-shrink: 0;
}

.guest-prompt-content {
  flex: 1;
}

.guest-comment-input {
  width: 100%;
  padding: 0.75rem 1rem;
  background: var(--tertiary-bg);
  border: 1px solid var(--border-color);
  border-radius: var(--border-radius);
  color: var(--text-secondary);
  font-size: 0.875rem;
  cursor: pointer;
  transition: var(--transition);
  font-family: inherit;
}

.guest-comment-input:hover {
  border-color: var(--accent-primary);
}

.guest-prompt-text {
  margin-top: 0.5rem;
  font-size: 0.75rem;
  color: var(--text-muted);
}

.auth-link {
  color: var(--accent-primary);
  text-decoration: none;
  font-weight: 500;
}

.auth-link:hover {
  text-decoration: underline;
}

/* ===== USER COMMENT FORM ===== */
.user-comment-form {
  background: var(--secondary-bg);
  border: 1px solid var(--border-color);
  border-radius: var(--border-radius);
  margin-bottom: 1rem;
}

.comment-form-container {
  padding: 1rem;
}

/* ===== REPLY CONTEXT ===== */
.reply-context {
  background: var(--primary-bg);
  border: 1px solid var(--border-color);
  border-radius: var(--border-radius);
  padding: 0.75rem 1rem;
  margin-bottom: 1rem;
}

.reply-header {
  display: flex;
  align-items: center;
  gap: 0.5rem;
  color: var(--text-secondary);
  font-size: 0.875rem;
}

.cancel-reply-btn {
  margin-left: auto;
  background: none;
  border: none;
  color: var(--text-secondary);
  cursor: pointer;
  font-size: 1.25rem;
  padding: 0.25rem;
  border-radius: var(--border-radius);
  transition: var(--transition);
}

.cancel-reply-btn:hover {
  background: var(--tertiary-bg);
  color: var(--error-color);
}

.reply-preview {
  background: var(--tertiary-bg);
  border: 1px solid var(--border-color);
  border-radius: var(--border-radius);
  padding: 0.75rem;
  margin-top: 0.5rem;
  font-size: 0.8125rem;
  color: var(--text-secondary);
  max-height: 60px;
  overflow: hidden;
}

/* ===== USER INFO ===== */
.user-info {
  display: flex;
  align-items: center;
  gap: 0.75rem;
  margin-bottom: 1rem;
  padding-bottom: 1rem;
  border-bottom: 1px solid var(--border-color);
}

.user-avatar {
  width: 40px;
  height: 40px;
  background: var(--tertiary-bg);
  border: 1px solid var(--border-color);
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
  overflow: hidden;
}

.user-avatar img {
  width: 100%;
  height: 100%;
  object-fit: cover;
}

.user-details {
  flex: 1;
}

.user-name {
  font-weight: 600;
  color: var(--text-primary);
  font-size: 0.875rem;
}

/* ===== COMMENT INPUT SECTION ===== */
.comment-input-section {
  display: flex;
  flex-direction: column;
}

.formatting-toolbar {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 0.5rem;
  background: var(--primary-bg);
  border: 1px solid var(--border-color);
  border-bottom: none;
  border-radius: var(--border-radius) var(--border-radius) 0 0;
  position: relative;
}

.format-buttons {
  display: flex;
  gap: 0.25rem;
}

.format-btn,
.mention-btn,
.emoji-btn {
  width: 32px;
  height: 32px;
  border: 1px solid var(--border-color);
  background: var(--tertiary-bg);
  color: var(--text-primary);
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 0.875rem;
  transition: var(--transition);
  border-radius: var(--border-radius);
}

.format-btn:hover,
.mention-btn:hover,
.emoji-btn:hover {
  background: var(--border-color);
  border-color: var(--accent-primary);
}

.format-btn.active {
  background: var(--accent-primary);
  border-color: var(--accent-primary);
  color: white;
}

.character-count {
  font-size: 0.75rem;
  color: var(--text-secondary);
  font-weight: 500;
}

/* ===== EMOJI PICKER ===== */
.emoji-picker,
.inline-emoji-picker {
  position: absolute !important;
  top: 100% !important;
  left: 0 !important;
  right: 0 !important;
  background: var(--secondary-bg) !important;
  border: 1px solid var(--border-color) !important;
  border-radius: var(--border-radius) !important;
  padding: 0.75rem !important;
  z-index: var(--z-modal) !important;
  max-height: 300px !important;
  overflow-y: auto !important;
  box-shadow: var(--box-shadow) !important;
  display: none !important;
  margin-top: 4px !important;
}

.emoji-picker.show,
.inline-emoji-picker.show {
  display: block !important;
}

.emoji-categories {
  display: flex;
  gap: 0.5rem;
  padding-bottom: 0.75rem;
  border-bottom: 1px solid var(--border-color);
  margin-bottom: 0.75rem;
  overflow-x: auto;
  -webkit-overflow-scrolling: touch;
}

.emoji-category {
  padding: 0.5rem;
  background: var(--tertiary-bg);
  border: 1px solid var(--border-color);
  color: var(--text-secondary);
  cursor: pointer;
  transition: var(--transition);
  border-radius: var(--border-radius);
  font-size: 0.875rem;
  white-space: nowrap;
  flex-shrink: 0;
}

.emoji-category:hover,
.emoji-category.active {
  background: var(--accent-primary);
  color: white;
  border-color: var(--accent-primary);
}

.emoji-grid {
  display: grid !important;
  grid-template-columns: repeat(8, 1fr) !important;
  gap: 0.5rem !important;
}

.emoji-option {
  width: 32px !important;
  height: 32px !important;
  border: none !important;
  background: transparent !important;
  cursor: pointer !important;
  display: flex !important;
  align-items: center !important;
  justify-content: center !important;
  font-size: 1.2rem !important;
  transition: background-color 0.2s ease !important;
  border-radius: var(--border-radius) !important;
}

.emoji-option:hover {
  background: var(--tertiary-bg) !important;
}

/* ===== GLOBAL EMOJI PICKER ===== */
.global-emoji-picker {
  position: fixed;
  z-index: var(--z-modal);
  width: 320px;
  max-width: 90vw;
  max-height: 300px;
  background: var(--secondary-bg);
  border: 1px solid var(--border-color);
  border-radius: var(--border-radius);
  padding: 0.75rem;
  overflow-y: auto;
  box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
  display: none;
  box-sizing: border-box;
}

.global-emoji-picker .emoji-categories {
  display: flex;
  gap: 0.25rem;
  padding-bottom: 0.75rem;
  border-bottom: 1px solid var(--border-color);
  margin-bottom: 0.75rem;
  overflow-x: auto;
}

.global-emoji-picker .emoji-category {
  padding: 0.375rem 0.5rem;
  background: var(--tertiary-bg);
  border: 1px solid var(--border-color);
  color: var(--text-secondary);
  cursor: pointer;
  transition: var(--transition);
  border-radius: var(--border-radius);
  font-size: 0.75rem;
  white-space: nowrap;
  flex-shrink: 0;
  min-width: 32px;
  text-align: center;
}

.global-emoji-picker .emoji-category:hover,
.global-emoji-picker .emoji-category.active {
  background: var(--accent-primary);
  color: white;
  border-color: var(--accent-primary);
}

.global-emoji-picker .emoji-grid {
  display: grid;
  grid-template-columns: repeat(8, 1fr);
  gap: 0.375rem;
  width: 100%;
  max-height: 180px;
  overflow-y: auto;
}

.global-emoji-picker .emoji-option {
  width: 32px;
  height: 32px;
  border: none;
  background: transparent;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 1.25rem;
  border-radius: var(--border-radius);
  transition: background-color 0.2s ease;
}

.global-emoji-picker .emoji-option:hover {
  background: var(--tertiary-bg);
}

/* ===== MENTION SUGGESTIONS ===== */
.mention-suggestions {
  position: absolute;
  top: 100%;
  left: 0;
  right: 0;
  background: var(--secondary-bg);
  border: 1px solid var(--border-color);
  border-radius: var(--border-radius);
  max-height: 200px;
  overflow-y: auto;
  z-index: var(--z-modal);
  display: none;
  box-shadow: var(--box-shadow);
}

.mention-suggestions.show {
  display: block;
}

.mention-list {
  padding: 0.5rem 0;
}

.mention-item {
  display: flex;
  align-items: center;
  gap: 0.75rem;
  padding: 0.5rem 1rem;
  cursor: pointer;
  transition: var(--transition);
  border: none;
  background: none;
  width: 100%;
  text-align: left;
  color: var(--text-primary);
}

.mention-item:hover,
.mention-item.selected {
  background: var(--tertiary-bg);
}

.mention-item-avatar {
  width: 24px;
  height: 24px;
  border-radius: 50%;
  background: var(--tertiary-bg);
  display: flex;
  align-items: center;
  justify-content: center;
  overflow: hidden;
}

.mention-item-avatar img {
  width: 100%;
  height: 100%;
  object-fit: cover;
}

.mention-item-info {
  flex: 1;
}

.mention-item-name {
  font-weight: 600;
  font-size: 0.875rem;
  color: var(--text-primary);
}

.mention-item-handle {
  font-size: 0.75rem;
  color: var(--text-secondary);
}

.mention {
  color: var(--mention-color);
  font-weight: 500;
  background: var(--mention-bg);
  padding: 0 4px;
  border-radius: var(--border-radius);
  cursor: pointer;
  transition: var(--transition);
  text-decoration: none;
}

.mention:hover {
  background: var(--accent-primary);
  color: white;
}

/* ===== COMMENT TEXTAREA ===== */
.comment-textarea {
  width: 100%;
  min-height: 120px;
  padding: 1rem;
  border: 1px solid var(--border-color);
  border-top: none;
  border-radius: 0 0 var(--border-radius) var(--border-radius);
  background: var(--secondary-bg);
  color: var(--text-primary);
  font-size: 0.875rem;
  font-family: inherit;
  resize: vertical;
  box-sizing: border-box;
  line-height: 1.5;
}

.comment-textarea:focus {
  outline: none;
  background: var(--tertiary-bg);
  border-color: var(--accent-primary);
}

.comment-textarea::placeholder {
  color: var(--text-secondary);
}

/* ===== FORM FOOTER ===== */
.form-footer {
  background: var(--primary-bg);
  border: 1px solid var(--border-color);
  border-top: none;
  border-radius: 0 0 var(--border-radius) var(--border-radius);
  padding: 1rem;
  display: flex;
  justify-content: space-between;
  align-items: center;
  flex-wrap: wrap;
  gap: 1rem;
}

.form-guidelines {
  font-size: 0.75rem;
  color: var(--text-muted);
}

.form-guidelines a {
  color: var(--accent-primary);
  text-decoration: none;
}

.form-guidelines a:hover {
  text-decoration: underline;
}

.form-actions {
  display: flex;
  gap: 0.5rem;
}

.cancel-btn,
.submit-btn {
  padding: 0.5rem 1rem;
  border: 1px solid var(--border-color);
  background: var(--tertiary-bg);
  color: var(--text-primary);
  cursor: pointer;
  font-size: 0.875rem;
  transition: var(--transition);
  display: flex;
  align-items: center;
  gap: 0.5rem;
  font-family: inherit;
  border-radius: var(--border-radius);
  white-space: nowrap;
}

.cancel-btn:hover {
  background: var(--border-color);
  color: var(--error-color);
  border-color: var(--error-color);
}

.submit-btn {
  background: var(--accent-primary);
  border-color: var(--accent-primary);
  color: white;
}

.submit-btn:hover:not(:disabled) {
  background: var(--accent-secondary);
  border-color: var(--accent-secondary);
}

.submit-btn:disabled {
  opacity: 0.6;
  cursor: not-allowed;
}

.cancel-btn > svg,
.submit-btn > svg {
  width: 16px !important;
  height: 16px !important;
  flex-shrink: 0 !important;
}

/* ===== SORT SECTION ===== */
.sort-section {
  margin-bottom: 1rem;
  padding: 1rem;
  background: var(--secondary-bg);
  border: 1px solid var(--border-color);
  border-radius: var(--border-radius);
}

.sort-controls {
  display: flex;
  align-items: center;
  gap: 0.5rem;
}

.sort-controls label {
  font-size: 0.875rem;
  color: var(--text-secondary);
  font-weight: 500;
}

.sort-select {
  padding: 0.5rem;
  background: var(--tertiary-bg);
  border: 1px solid var(--border-color);
  border-radius: var(--border-radius);
  color: var(--text-primary);
  font-size: 0.875rem;
  font-family: inherit;
}

.sort-select:focus {
  outline: none;
  border-color: var(--accent-primary);
}

/* ===== EMPTY STATE ===== */
.empty-state {
  background: var(--secondary-bg);
  border: 1px solid var(--border-color);
  border-radius: var(--border-radius);
  padding: 3rem 2rem;
  text-align: center;
}

.empty-content {
  max-width: 400px;
  margin: 0 auto;
}

.empty-icon {
  margin-bottom: 1.5rem;
  opacity: 0.6;
}

.empty-icon svg {
  color: var(--text-secondary);
}

.empty-title {
  color: var(--text-primary);
  font-size: 1.25rem;
  font-weight: 600;
  margin: 0 0 0.5rem 0;
}

.empty-description {
  color: var(--text-secondary);
  font-size: 0.875rem;
  margin: 0;
  line-height: 1.5;
}

/* ===== COMMENTS LIST ===== */
.comments-list {
  background: var(--primary-bg);
}

/* ===== COMMENT CARDS ===== */
.comment-card {
  background: var(--secondary-bg);
  border: 1px solid var(--border-color);
  border-radius: var(--border-radius);
  margin-bottom: 1rem;
  transition: var(--transition);
  contain: layout style;
}

.comment-card:hover {
  border-color: var(--accent-primary);
}

.comment-card.new-comment {
  animation: slideInFromTop 0.5s ease-out;
  border-color: var(--success-color);
}

.comment-card.new-comment .comment-header {
  background: rgba(16, 185, 129, 0.05);
}

/* ===== FIXED COMMENT HEADER ===== */
.comment-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 0.75rem 1rem;
  border-bottom: 1px solid var(--border-color);
  gap: 0.75rem;
  min-height: 60px;
  flex-wrap: nowrap;
}

.comment-user-info {
  display: flex;
  align-items: center;
  gap: 0.75rem;
  flex: 1;
  min-width: 0;
}

.comment-avatar {
  width: 32px;
  height: 32px;
  background: var(--tertiary-bg);
  border: 1px solid var(--border-color);
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
  overflow: hidden;
  flex-shrink: 0;
  position: relative;
}

.comment-avatar img {
  width: 100%;
  height: 100%;
  object-fit: cover;
}

.admin-badge {
  position: absolute;
  top: -2px;
  right: -2px;
  font-size: 0.75rem;
  background: var(--admin-color);
  border-radius: 50%;
  width: 16px;
  height: 16px;
  display: flex;
  align-items: center;
  justify-content: center;
  color: white;
}

.comment-meta {
  display: flex;
  flex-direction: column;
  gap: 0.25rem;
  min-width: 0;
  flex: 1;
}

.user-details {
  display: flex;
  align-items: center;
  gap: 0.5rem;
  flex-wrap: nowrap;
}

.username {
  font-weight: 600;
  color: var(--text-primary);
  font-size: 0.875rem;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  max-width: 150px;
}

.username.admin {
  color: var(--admin-color);
}

.comment-time-wrapper {
  display: inline-flex;
  align-items: center;
  gap: 0.25rem;
  font-size: 0.75rem;
  color: var(--text-secondary);
  white-space: nowrap;
  flex-shrink: 0;
}

.comment-time-wrapper svg {
  width: 12px;
  height: 12px;
  flex-shrink: 0;
  opacity: 0.7;
}

.comment-time {
  font-size: 0.75rem;
  color: var(--text-secondary);
}

.edit-indicator {
  font-size: 0.75rem;
  color: var(--text-muted);
  font-style: italic;
  margin-left: 0.25rem;
}

/* ===== COMMENT ACTIONS MENU ===== */
.comment-actions-menu {
  position: relative;
  flex-shrink: 0;
}

.menu-btn {
  width: 32px;
  height: 32px;
  background: transparent;
  border: 1px solid var(--border-color);
  border-radius: var(--border-radius);
  color: var(--text-secondary);
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: var(--transition);
}

.menu-btn:hover {
  background: var(--tertiary-bg);
  color: var(--text-primary);
  border-color: var(--accent-primary);
}

.dropdown-menu {
  position: absolute;
  top: calc(100% + 4px);
  right: 0;
  background: var(--secondary-bg);
  border: 1px solid var(--border-color);
  border-radius: var(--border-radius);
  box-shadow: var(--box-shadow);
  min-width: 140px;
  z-index: var(--z-dropdown);
  display: none;
  overflow: hidden;
}

.dropdown-menu.show {
  display: block;
}

.dropdown-item {
  width: 100%;
  padding: 0.75rem 1rem;
  background: none;
  border: none;
  color: var(--text-primary);
  font-size: 0.875rem;
  cursor: pointer;
  display: flex;
  align-items: center;
  gap: 0.75rem;
  transition: background-color 0.2s ease;
  font-family: inherit;
  text-align: left;
  white-space: nowrap;
}

.dropdown-item:hover {
  background: var(--tertiary-bg);
}

.dropdown-item.edit-comment-btn:hover {
  background: rgba(59, 130, 246, 0.1);
  color: var(--accent-primary);
}

.dropdown-item.delete-comment-btn:hover {
  background: rgba(239, 68, 68, 0.1);
  color: var(--error-color);
}

.dropdown-item.report-btn:hover {
  background: rgba(245, 158, 11, 0.1);
  color: var(--warning-color);
}

.dropdown-item svg {
  flex-shrink: 0;
  width: 16px;
  height: 16px;
}

/* ===== COMMENT CONTENT ===== */
.comment-content {
  padding: 1rem;
}

.comment-text {
  color: var(--text-primary);
  line-height: 1.6;
  font-size: 0.875rem;
  word-wrap: break-word;
  margin-bottom: 0.5rem;
}

.comment-text strong {
  font-weight: 600;
  color: var(--text-primary);
}

.comment-text em {
  font-style: italic;
}

.comment-text code {
  background: var(--primary-bg);
  border: 1px solid var(--border-color);
  border-radius: var(--border-radius);
  padding: 2px 4px;
  font-family: "SF Mono", Monaco, "Cascadia Code", "Roboto Mono", Consolas, "Courier New", monospace;
  font-size: 0.8125rem;
  color: var(--text-primary);
}

/* ===== FIXED COMMENT FOOTER ===== */
.comment-footer {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 0.75rem 1rem;
  background: var(--primary-bg);
  border-top: 1px solid var(--border-color);
  gap: 0.75rem;
  flex-wrap: nowrap;
  overflow-x: auto;
  -webkit-overflow-scrolling: touch;
  min-height: 60px;
}

/* ===== VOTING SECTION ===== */
.comment-voting {
  display: flex;
  align-items: center;
  gap: 0.25rem;
  flex-shrink: 0;
}

.vote-btn {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 0.25rem;
  background: var(--tertiary-bg);
  border: 1px solid var(--border-color);
  border-radius: var(--border-radius);
  color: var(--text-secondary);
  cursor: pointer;
  padding: 0.375rem;
  font-size: 0.75rem;
  transition: var(--transition);
  font-family: inherit;
  min-width: 32px;
  min-height: 32px;
}

.vote-btn svg {
  width: 16px;
  height: 16px;
  flex-shrink: 0;
}

.vote-btn:hover {
  background: var(--border-color);
  color: var(--text-primary);
}

.upvote-btn.active {
  background: var(--upvote-color);
  color: white;
  border-color: var(--upvote-color);
}

.downvote-btn.active {
  background: var(--downvote-color);
  color: white;
  border-color: var(--downvote-color);
}

.vote-count {
  font-weight: 500;
  min-width: 16px;
  text-align: center;
  font-size: 0.8125rem;
  padding: 0 0.25rem;
}

/* ===== REACTIONS SECTION ===== */
.comment-reactions {
  display: flex;
  gap: 0.25rem;
  flex-shrink: 0;
  flex-wrap: nowrap;
}

.reaction-btn {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 0.25rem;
  background: var(--tertiary-bg);
  border: 1px solid var(--border-color);
  border-radius: var(--border-radius);
  color: var(--text-secondary);
  cursor: pointer;
  padding: 0.375rem;
  font-size: 0.75rem;
  transition: var(--transition);
  font-family: inherit;
  min-width: 32px;
  min-height: 32px;
}

.reaction-btn:hover {
  background: var(--border-color);
  color: var(--text-primary);
  border-color: var(--accent-primary);
}

.reaction-btn.active {
  background: var(--accent-primary);
  color: white;
  border-color: var(--accent-primary);
}

.reaction-emoji {
  font-size: 1rem;
  line-height: 1;
}

.reaction-count {
  font-weight: 500;
  min-width: 16px;
  text-align: center;
  font-size: 0.8125rem;
}

/* ===== COMMENT ACTIONS SECTION ===== */
.comment-actions {
  display: flex;
  gap: 0.25rem;
  flex-shrink: 0;
  flex-wrap: nowrap;
}

.action-btn {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 0.25rem;
  background: var(--tertiary-bg);
  border: 1px solid var(--border-color);
  border-radius: var(--border-radius);
  color: var(--text-secondary);
  cursor: pointer;
  padding: 0.375rem;
  font-size: 0.75rem;
  transition: var(--transition);
  font-family: inherit;
  min-width: 32px;
  min-height: 32px;
  white-space: nowrap;
}

.action-btn svg {
  width: 16px;
  height: 16px;
  flex-shrink: 0;
}

.action-btn:hover {
  background: var(--border-color);
  color: var(--text-primary);
  border-color: var(--accent-primary);
}

.bookmark-btn.active {
  background: var(--warning-color);
  color: white;
  border-color: var(--warning-color);
}

/* ===== THREADING AND REPLIES ===== */
.comment-replies {
  margin-top: 1rem;
  position: relative;
}

.reply-card {
  margin-left: 2rem;
  margin-bottom: 1rem;
  position: relative;
  border-left: 2px solid var(--border-color);
  padding-left: 1rem;
}

.reply-card[data-thread-level="1"] {
  margin-left: 2rem;
  border-left-color: #818cf8;
}

.reply-card[data-thread-level="2"] {
  margin-left: 4rem;
  border-left-color: #34d399;
}

.reply-card[data-thread-level="3"] {
  margin-left: 6rem;
  border-left-color: #fbbf24;
}

.reply-card[data-thread-level="4"] {
  margin-left: 8rem;
  border-left-color: #f87171;
}

.reply-card[data-thread-level="5"] {
  position: relative;
}

.reply-card[data-thread-level="5"] > .reply-indicator::before {
  content: "â†³ More replies";
  position: absolute;
  left: -10px;
  top: 50%;
  transform: translateY(-50%);
  font-size: 0.7rem;
  color: var(--text-muted);
  background: var(--primary-bg);
  padding: 2px 4px;
  border-radius: 4px;
  white-space: nowrap;
}

.reply-indicator {
  position: absolute;
  left: -1rem;
  top: 1rem;
  width: 1rem;
  height: 2px;
  background: var(--border-color);
}

.reply-indicator::before {
  content: "";
  position: absolute;
  left: -2px;
  top: -1rem;
  width: 2px;
  height: 1rem;
  background: var(--border-color);
}

.reply-content {
  background: var(--secondary-bg);
  border: 1px solid var(--border-color);
  border-radius: var(--border-radius);
}

/* Threading visual indicators */
.comment-card[data-thread-level="0"] {
  border-left: 3px solid var(--accent-primary);
}

.comment-card[data-thread-level="1"] {
  border-left: 3px solid #818cf8;
}

.comment-card[data-thread-level="2"] {
  border-left: 3px solid #34d399;
}

.comment-card[data-thread-level="3"] {
  border-left: 3px solid #fbbf24;
}

.comment-card[data-thread-level="4"] {
  border-left: 3px solid #f87171;
}

.reply-card[data-thread-level="1"] .reply-indicator {
  background: #818cf8;
}

.reply-card[data-thread-level="2"] .reply-indicator {
  background: #34d399;
}

.reply-card[data-thread-level="3"] .reply-indicator {
  background: #fbbf24;
}

.reply-card[data-thread-level="4"] .reply-indicator {
  background: #f87171;
}

/* ===== INLINE REPLY FORMS ===== */
.inline-reply-container {
  margin: 1rem 0;
  padding: 0;
  display: block;
  width: 100%;
  height: auto;
  border-radius: 0;
  background: transparent;
  border: none;
  position: static;
}

.inline-reply-form {
  margin: 1rem 0;
  background: var(--secondary-bg);
  border: 1px solid var(--accent-primary);
  border-radius: var(--border-radius);
  overflow: hidden;
  animation: slideDown 0.3s ease-out;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
}

.reply-form-header {
  padding: 0.75rem 1rem;
  background: var(--primary-bg);
  border-bottom: 1px solid var(--border-color);
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.reply-context-info {
  display: flex;
  align-items: center;
  gap: 0.5rem;
  color: var(--text-secondary);
  font-size: 0.875rem;
  flex: 1;
}

.reply-context-info svg {
  color: var(--accent-primary);
  flex-shrink: 0;
}

.reply-author-name {
  color: var(--accent-primary);
  font-weight: 600;
}

.cancel-inline-reply {
  background: none;
  border: none;
  color: var(--text-secondary);
  cursor: pointer;
  font-size: 1.125rem;
  padding: 0.25rem 0.5rem;
  border-radius: var(--border-radius);
  transition: var(--transition);
  margin-left: auto;
  flex-shrink: 0;
}

.cancel-inline-reply:hover {
  background: var(--tertiary-bg);
  color: var(--error-color);
}

.inline-comment-form {
  padding: 1rem;
  background: var(--secondary-bg);
}

.inline-user-info {
  display: flex;
  align-items: center;
  gap: 0.75rem;
  margin-bottom: 1rem;
  padding-bottom: 1rem;
  border-bottom: 1px solid var(--border-color);
}

.inline-user-avatar {
  width: 40px;
  height: 40px;
  background: var(--tertiary-bg);
  border: 1px solid var(--border-color);
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
  overflow: hidden;
  flex-shrink: 0;
}

.inline-user-avatar img {
  width: 100%;
  height: 100%;
  object-fit: cover;
}

.inline-user-name {
  font-weight: 600;
  color: var(--text-primary);
  font-size: 0.875rem;
}

.inline-content-section {
  position: relative;
}

.inline-formatting-toolbar {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 0.5rem;
  background: var(--primary-bg);
  border: 1px solid var(--border-color);
  border-bottom: none;
  border-radius: var(--border-radius) var(--border-radius) 0 0;
}

.inline-format-buttons {
  display: flex;
  gap: 0.25rem;
  flex-wrap: wrap;
}

.inline-format-btn,
.inline-emoji-btn {
  width: 32px;
  height: 32px;
  border: 1px solid var(--border-color);
  background: var(--tertiary-bg);
  color: var(--text-primary);
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 0.875rem;
  transition: var(--transition);
  border-radius: var(--border-radius);
  flex-shrink: 0;
}

.inline-format-btn:hover,
.inline-emoji-btn:hover {
  background: var(--border-color);
  border-color: var(--accent-primary);
}

.inline-format-btn.active {
  background: var(--accent-primary);
  border-color: var(--accent-primary);
  color: white;
}

.inline-char-count {
  font-size: 0.75rem;
  color: var(--text-secondary);
  font-weight: 500;
  flex-shrink: 0;
}

.inline-textarea {
  width: 100%;
  padding: 1rem;
  background: var(--secondary-bg);
  border: 1px solid var(--border-color);
  border-top: none;
  border-radius: 0;
  color: var(--text-primary);
  font-size: 0.875rem;
  resize: vertical;
  min-height: 100px;
  font-family: inherit;
  box-sizing: border-box;
  line-height: 1.5;
}

.inline-textarea:focus {
  outline: none;
  border-color: var(--accent-primary);
  background: var(--tertiary-bg);
}

.inline-textarea::placeholder {
  color: var(--text-secondary);
}

.inline-form-footer {
  background: var(--primary-bg);
  border: 1px solid var(--border-color);
  border-top: none;
  border-radius: 0 0 var(--border-radius) var(--border-radius);
  padding: 1rem;
  display: flex;
  justify-content: space-between;
  align-items: center;
  flex-wrap: wrap;
  gap: 1rem;
}

.inline-guidelines {
  font-size: 0.75rem;
  color: var(--text-muted);
  flex: 1;
}

.inline-actions {
  display: flex;
  gap: 0.5rem;
  flex-shrink: 0;
}

.cancel-inline-btn,
.submit-inline-btn {
  padding: 0.5rem 1rem;
  border: 1px solid var(--border-color);
  background: var(--tertiary-bg);
  color: var(--text-primary);
  cursor: pointer;
  font-size: 0.875rem;
  transition: var(--transition);
  display: flex;
  align-items: center;
  gap: 0.5rem;
  font-family: inherit;
  border-radius: var(--border-radius);
}

.cancel-inline-btn:hover {
  background: var(--border-color);
  color: var(--error-color);
  border-color: var(--error-color);
}

.submit-inline-btn {
  background: var(--accent-primary);
  border-color: var(--accent-primary);
  color: white;
}

.submit-inline-btn:hover:not(:disabled) {
  background: var(--accent-secondary);
  border-color: var(--accent-secondary);
}

.submit-inline-btn:disabled {
  opacity: 0.6;
  cursor: not-allowed;
}

/* ===== INLINE EDIT FORMS ===== */
.inline-edit-form {
  background: var(--secondary-bg);
  border: 1px solid var(--accent-primary);
  border-radius: var(--border-radius);
  margin: 1rem 0;
  animation: slideDown 0.3s ease-out;
  overflow: hidden;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
}

.edit-form-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 0.75rem 1rem;
  background: var(--primary-bg);
  border-bottom: 1px solid var(--border-color);
  font-size: 0.875rem;
  color: var(--text-secondary);
  font-weight: 600;
}

.cancel-edit-inline {
  background: none;
  border: none;
  color: var(--text-secondary);
  cursor: pointer;
  font-size: 1.125rem;
  padding: 0.25rem 0.5rem;
  border-radius: var(--border-radius);
  transition: var(--transition);
}

.cancel-edit-inline:hover {
  background: var(--tertiary-bg);
  color: var(--error-color);
}

.edit-comment-form-inline {
  padding: 1rem;
}

.edit-formatting-toolbar {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 0.5rem;
  background: var(--primary-bg);
  border: 1px solid var(--border-color);
  border-bottom: none;
  border-radius: var(--border-radius) var(--border-radius) 0 0;
}

.edit-format-buttons {
  display: flex;
  gap: 0.25rem;
}

.edit-format-btn {
  width: 28px;
  height: 28px;
  border: 1px solid var(--border-color);
  background: var(--tertiary-bg);
  color: var(--text-primary);
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 0.75rem;
  transition: var(--transition);
  border-radius: var(--border-radius);
}

.edit-format-btn:hover {
  background: var(--border-color);
  border-color: var(--accent-primary);
}

.edit-format-btn.active {
  background: var(--accent-primary);
  border-color: var(--accent-primary);
  color: white;
}

.edit-char-count {
  font-size: 0.75rem;
  color: var(--text-secondary);
  font-weight: 500;
}

.edit-textarea {
  width: 100%;
  padding: 0.75rem;
  background: var(--tertiary-bg);
  border: 1px solid var(--border-color);
  border-top: none;
  border-radius: 0 0 var(--border-radius) var(--border-radius);
  color: var(--text-primary);
  font-size: 0.875rem;
  resize: vertical;
  min-height: 100px;
  font-family: inherit;
  box-sizing: border-box;
  line-height: 1.5;
}

.edit-textarea:focus {
  outline: none;
  border-color: var(--accent-primary);
}

.edit-form-footer {
  background: var(--primary-bg);
  border: 1px solid var(--border-color);
  border-top: none;
  border-radius: 0 0 var(--border-radius) var(--border-radius);
  padding: 0.75rem;
  display: flex;
  justify-content: space-between;
  align-items: center;
  flex-wrap: wrap;
  gap: 0.5rem;
}

.edit-reason-select {
  padding: 0.5rem;
  background: var(--tertiary-bg);
  border: 1px solid var(--border-color);
  border-radius: var(--border-radius);
  color: var(--text-primary);
  font-size: 0.875rem;
  font-family: inherit;
}

.edit-reason-select:focus {
  outline: none;
  border-color: var(--accent-primary);
}

.edit-actions {
  display: flex;
  gap: 0.5rem;
}

.cancel-edit-btn,
.save-edit-btn {
  padding: 0.5rem 1rem;
  border: 1px solid var(--border-color);
  background: var(--tertiary-bg);
  color: var(--text-primary);
  cursor: pointer;
  font-size: 0.875rem;
  transition: var(--transition);
  display: flex;
  align-items: center;
  gap: 0.5rem;
  font-family: inherit;
  border-radius: var(--border-radius);
}

.cancel-edit-btn:hover {
  background: var(--border-color);
  color: var(--error-color);
  border-color: var(--error-color);
}

.save-edit-btn {
  background: var(--accent-primary);
  border-color: var(--accent-primary);
  color: white;
}

.save-edit-btn:hover:not(:disabled) {
  background: var(--accent-secondary);
  border-color: var(--accent-secondary);
}

.save-edit-btn:disabled {
  opacity: 0.6;
  cursor: not-allowed;
}

/* ===== MODAL STYLES ===== */
.modal-overlay {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgba(0, 0, 0, 0.8);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: var(--z-modal);
  animation: fadeIn 0.2s ease-out;
}

.modal-container {
  background: var(--secondary-bg);
  border: 1px solid var(--border-color);
  border-radius: var(--border-radius);
  width: 90%;
  max-width: 500px;
  max-height: 80vh;
  overflow-y: auto;
  box-shadow: var(--box-shadow);
  animation: slideInFromTop 0.3s ease-out;
}

.modal-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 1rem 1.25rem;
  border-bottom: 1px solid var(--border-color);
}

.modal-header h3 {
  color: var(--text-primary);
  font-size: 1.125rem;
  font-weight: 600;
  margin: 0;
}

.modal-close {
  background: transparent;
  border: none;
  color: var(--text-secondary);
  cursor: pointer;
  font-size: 1.5rem;
  padding: 0.25rem;
  border-radius: var(--border-radius);
  transition: var(--transition);
}

.modal-close:hover {
  background: var(--tertiary-bg);
  color: var(--error-color);
}

.modal-body {
  padding: 1.25rem;
}

.modal-body p {
  color: var(--text-primary);
  margin: 0 0 1rem 0;
  line-height: 1.5;
}

.comment-preview {
  background: var(--primary-bg);
  border: 1px solid var(--border-color);
  border-radius: var(--border-radius);
  padding: 0.75rem;
  margin: 0.75rem 0;
  color: var(--text-secondary);
  font-size: 0.875rem;
  max-height: 100px;
  overflow-y: auto;
  font-style: italic;
}

.modal-actions {
  display: flex;
  justify-content: flex-end;
  gap: 0.75rem;
  padding: 1rem 1.25rem;
  border-top: 1px solid var(--border-color);
  background: var(--primary-bg);
}

/* ===== BUTTON STYLES ===== */
.btn-primary,
.btn-secondary,
.btn-danger {
  padding: 0.5rem 1rem;
  font-size: 0.875rem;
  font-weight: 500;
  cursor: pointer;
  display: flex;
  align-items: center;
  gap: 0.5rem;
  transition: var(--transition);
  font-family: inherit;
  border-radius: var(--border-radius);
}

.btn-primary {
  background: var(--accent-primary);
  border: 1px solid var(--accent-primary);
  color: white;
}

.btn-primary:hover:not(:disabled) {
  background: var(--accent-secondary);
  border-color: var(--accent-secondary);
}

.btn-secondary {
  background: transparent;
  border: 1px solid var(--border-color);
  color: var(--text-primary);
}

.btn-secondary:hover {
  background: var(--tertiary-bg);
  border-color: var(--accent-primary);
}

.btn-danger {
  background: var(--error-color);
  border: 1px solid var(--error-color);
  color: white;
}

.btn-danger:hover:not(:disabled) {
  background: #dc2626;
  border-color: #dc2626;
}

.btn-primary:disabled,
.btn-secondary:disabled,
.btn-danger:disabled {
  opacity: 0.6;
  cursor: not-allowed;
}

/* ===== NOTIFICATIONS ===== */
.comment-success-indicator {
  position: fixed;
  top: 20px;
  right: 20px;
  background: rgba(16, 185, 129, 0.9);
  color: white;
  padding: 8px 12px;
  border-radius: var(--border-radius);
  font-size: 0.875rem;
  z-index: var(--z-notification);
  animation: slideInRight 0.3s ease-out, fadeOut 0.3s ease-out 2.7s forwards;
  -webkit-backdrop-filter: blur(4px);
  backdrop-filter: blur(4px);
}

.comment-success-notification {
  position: fixed !important;
  top: 20px !important;
  right: 20px !important;
  background: rgba(16, 185, 129, 0.9) !important;
  -webkit-backdrop-filter: blur(12px) !important;
  backdrop-filter: blur(12px) !important;
  color: white !important;
  padding: 12px 24px !important;
  border-radius: var(--border-radius) !important;
  z-index: var(--z-notification) !important;
  font-size: 14px !important;
  font-weight: 500 !important;
  border: 1px solid rgba(16, 185, 129, 0.3) !important;
  box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3) !important;
}

.comment-error-notification {
  position: fixed !important;
  top: 20px !important;
  right: 20px !important;
  background: rgba(239, 68, 68, 0.9) !important;
  -webkit-backdrop-filter: blur(12px) !important;
  backdrop-filter: blur(12px) !important;
  color: white !important;
  padding: 12px 24px !important;
  border-radius: var(--border-radius) !important;
  z-index: var(--z-notification) !important;
  font-size: 14px !important;
  font-weight: 500 !important;
  border: 1px solid rgba(239, 68, 68, 0.3) !important;
  box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3) !important;
}

/* ===== ERROR MESSAGES ===== */
.error-message {
  padding: 0.75rem;
  font-size: 0.875rem;
  display: flex;
  align-items: center;
  gap: 0.5rem;
  margin-top: 1rem;
  background: rgba(239, 68, 68, 0.1);
  border: 1px solid var(--error-color);
  border-radius: var(--border-radius);
  color: var(--error-color);
}

/* ===== REPORT MODAL STYLES ===== */
.report-reasons {
  margin: 1rem 0;
}

.report-reason {
  display: flex;
  align-items: center;
  gap: 0.5rem;
  padding: 0.5rem;
  cursor: pointer;
  border-radius: var(--border-radius);
  transition: var(--transition);
}

.report-reason:hover {
  background: var(--tertiary-bg);
}

.report-reason input[type="radio"] {
  margin: 0;
}

.report-reason span {
  color: var(--text-primary);
  font-size: 0.875rem;
}

#report-details {
  width: 100%;
  padding: 0.75rem;
  background: var(--tertiary-bg);
  border: 1px solid var(--border-color);
  border-radius: var(--border-radius);
  color: var(--text-primary);
  font-size: 0.875rem;
  font-family: inherit;
  resize: vertical;
  margin-top: 1rem;
}

#report-details:focus {
  outline: none;
  border-color: var(--accent-primary);
}

/* ===== HISTORY MODAL STYLES ===== */
.history-list {
  max-height: 400px;
  overflow-y: auto;
}

.history-item {
  padding: 1rem;
  border-bottom: 1px solid var(--border-color);
}

.history-item:last-child {
  border-bottom: none;
}

.history-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 0.5rem;
}

.history-user {
  font-weight: 600;
  color: var(--text-primary);
}

.history-time {
  font-size: 0.75rem;
  color: var(--text-secondary);
}

.history-reason {
  font-size: 0.75rem;
  color: var(--text-muted);
  margin-bottom: 0.5rem;
}

.history-content {
  background: var(--primary-bg);
  border: 1px solid var(--border-color);
  border-radius: var(--border-radius);
  padding: 0.75rem;
  font-size: 0.875rem;
  color: var(--text-primary);
  max-height: 100px;
  overflow-y: auto;
}

/* ===== LOAD MORE SECTION ===== */
.load-more-section {
  margin-top: 2rem;
  padding: 2rem 0;
  text-align: center;
  border-top: 2px solid var(--border-color);
  background: var(--secondary-bg);
}

.load-more-container {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 1rem;
  padding: 2rem;
  background: var(--secondary-bg);
  border: 2px solid var(--border-color);
  border-radius: var(--border-radius);
  margin-top: 2rem;
}

.load-more-info {
  color: var(--text-secondary);
  font-size: 0.875rem;
  font-weight: 500;
  text-align: center;
}

.showing-count {
  color: var(--text-primary);
  font-weight: 600;
}

.load-more-btn {
  padding: 1rem 2rem;
  background: var(--tertiary-bg);
  border: 2px solid var(--border-color);
  border-radius: var(--border-radius);
  color: var(--text-primary);
  cursor: pointer;
  font-size: 0.875rem;
  font-weight: 600;
  text-transform: uppercase;
  letter-spacing: 0.025em;
  transition: var(--transition);
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 0.5rem;
  font-family: inherit;
  min-width: 200px;
}

.load-more-btn:hover:not(:disabled) {
  background: var(--accent-primary);
  border-color: var(--accent-primary);
  color: white;
  transform: translateY(-2px);
  box-shadow: 0 4px 12px rgba(36, 55, 136, 0.3);
}

.load-more-btn:disabled {
  opacity: 0.6;
  cursor: not-allowed;
  transform: none;
  pointer-events: none;
}

.load-more-btn svg {
  transition: transform 0.3s ease;
}

.load-more-btn:hover svg {
  transform: translateY(2px);
}

/* ===== LOAD MORE REPLIES ===== */
.load-more-replies {
  margin: 1rem 0 0 2rem;
  padding-left: 1rem;
  border-left: 2px solid var(--border-color);
}

.load-more-replies-btn {
  background: var(--primary-bg);
  border: 1px solid var(--border-color);
  border-radius: var(--border-radius);
  color: var(--text-secondary);
  cursor: pointer;
  font-size: 0.8125rem;
  font-weight: 600;
  text-transform: uppercase;
  letter-spacing: 0.025em;
  transition: var(--transition);
  display: flex;
  align-items: center;
  gap: 0.5rem;
  font-family: inherit;
  padding: 0.75rem 1rem;
}

.load-more-replies-btn:hover {
  background: var(--tertiary-bg);
  border-color: var(--accent-primary);
  color: var(--accent-primary);
  transform: translateX(4px);
}

.load-more-replies-btn svg {
  transition: transform 0.3s ease;
}

.load-more-replies-btn:hover svg {
  transform: rotate(180deg);
}

/* ===== PAGINATION LOADING STATES ===== */
.pagination-loading {
  display: flex;
  align-items: center;
  justify-content: center;
  padding: 2rem;
  gap: 1rem;
  color: var(--text-secondary);
}

.pagination-loading .loading-spinner {
  width: 24px;
  height: 24px;
}

/* ===== FADE IN NEW ===== */
.fade-in-new {
  animation: fadeInUp 0.6s ease-out forwards;
  opacity: 0;
}

.comment-wrapper.new-loaded {
  animation: slideInFromBottom 0.5s ease;
}

.new-comment {
  animation: highlightComment 3s ease-out;
}

/* ===== ADDITIONAL UTILITY CLASSES ===== */
.flag-option {
  display: flex !important;
  align-items: center !important;
  justify-content: center !important;
  padding: 4px !important;
  border: 1px solid var(--border-color) !important;
  background: var(--tertiary-bg) !important;
  border-radius: 4px !important;
  transition: var(--transition) !important;
}

.flag-option:hover {
  background: var(--border-color) !important;
  border-color: var(--accent-primary) !important;
  transform: scale(1.05) !important;
}

.flag-option img {
  pointer-events: none;
  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2);
}

.mention-dropdown {
  font-family: inherit;
}

.mention-item:last-child {
  border-bottom: none;
}

.notification-bell {
  position: relative;
  cursor: pointer;
  padding: 8px;
}

.notification-count {
  position: absolute;
  top: 0;
  right: 0;
  background: var(--error-color);
  color: white;
  border-radius: 50%;
  width: 18px;
  height: 18px;
  font-size: 11px;
  display: flex;
  align-items: center;
  justify-content: center;
  font-weight: 600;
}

.notification-dropdown {
  position: absolute;
  top: 100%;
  right: 0;
  width: 320px;
  max-height: 400px;
  background: var(--secondary-bg);
  border: 1px solid var(--border-color);
  border-radius: 8px;
  box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
  z-index: var(--z-dropdown);
  overflow-y: auto;
}

.notification-header {
  padding: 16px;
  border-bottom: 1px solid var(--border-color);
}

.notification-item {
  padding: 12px 16px;
  border-bottom: 1px solid var(--border-color);
  cursor: pointer;
}

.notification-item:hover {
  background: var(--tertiary-bg);
}

.notification-item.unread {
  background: rgba(59, 130, 246, 0.05);
  border-left: 3px solid var(--accent-primary);
}

/* ===== THREADING ENHANCEMENTS ===== */
.replies-container {
  margin-top: 1rem;
}

.reply-wrapper {
  position: relative;
  margin-bottom: 0.75rem;
}

.reply-card {
  position: relative;
  border-left: 2px solid var(--border-color);
  padding-left: 1rem;
  background: var(--secondary-bg);
  border-radius: var(--border-radius);
}

.reply-connector {
  position: absolute;
  left: -2px;
  top: 0;
  width: 2px;
  height: 100%;
  background: var(--accent-primary);
  opacity: 0.3;
}

/* Thread level specific colors */
.reply-card[data-thread-level="1"] {
  border-left-color: #818cf8;
}

.reply-card[data-thread-level="1"] .reply-connector {
  background: #818cf8;
}

.reply-card[data-thread-level="2"] {
  border-left-color: #34d399;
}

.reply-card[data-thread-level="2"] .reply-connector {
  background: #34d399;
}

.reply-card[data-thread-level="3"] {
  border-left-color: #fbbf24;
}

.reply-card[data-thread-level="3"] .reply-connector {
  background: #fbbf24;
}

.reply-card[data-thread-level="4"] {
  border-left-color: #f87171;
}

.reply-card[data-thread-level="4"] .reply-connector {
  background: #f87171;
}

/* Thread level styling */
[data-thread-level="1"] { margin-left: 20px; }
[data-thread-level="2"] { margin-left: 40px; }
[data-thread-level="3"] { margin-left: 60px; }
[data-thread-level="4"] { margin-left: 80px; }

/* ===== SCROLLBAR STYLING ===== */
* {
  scrollbar-width: thin;
  scrollbar-color: var(--border-color) var(--tertiary-bg);
}

*::-webkit-scrollbar {
  width: 8px;
  height: 8px;
}

*::-webkit-scrollbar-track {
  background: var(--tertiary-bg);
  border-radius: var(--border-radius);
}

*::-webkit-scrollbar-thumb {
  background: var(--border-color);
  border-radius: var(--border-radius);
}

*::-webkit-scrollbar-thumb:hover {
  background: var(--accent-primary);
}

*::-webkit-scrollbar-corner {
  background: var(--tertiary-bg);
}

.thin-scrollbar::-webkit-scrollbar {
  width: 4px;
  height: 4px;
}

.no-scrollbar {
  scrollbar-width: none;
}

.no-scrollbar::-webkit-scrollbar {
  display: none;
}

/* Dark theme scrollbars */
:global(.dark) *::-webkit-scrollbar-track {
  background: rgb(51, 65, 85);
}

:global(.dark) *::-webkit-scrollbar-thumb {
  background: rgb(71, 85, 105);
}

:global(.dark) *::-webkit-scrollbar-thumb:hover {
  background: #b4bce1;
}

/* ===== RESPONSIVE DESIGN ===== */
@media (max-width: 768px) {
  .tinkbyte-comment-section {
    padding: 0 0.5rem;
    margin: 1rem auto;
  }

  .thread-header {
    padding: 1rem;
  }

  .thread-header-content {
    flex-direction: column;
    align-items: flex-start;
  }

  .manage-btn {
    width: 100%;
    justify-content: center;
    padding: 0.75rem 1rem;
  }

  .comment-header {
    padding: 0.75rem;
    gap: 0.5rem;
    min-height: 56px;
  }

  .comment-avatar {
    width: 28px;
    height: 28px;
  }

  .username {
    font-size: 0.8125rem;
    max-width: 120px;
  }

  .comment-time-wrapper {
    font-size: 0.6875rem;
  }

  .comment-time-wrapper svg {
    width: 10px;
    height: 10px;
  }

  .comment-footer {
    padding: 0.5rem;
    gap: 0.5rem;
    min-height: 56px;
  }

  .vote-btn,
  .reaction-btn,
  .action-btn {
    min-width: 36px;
    min-height: 36px;
    padding: 0.25rem;
  }

  .dropdown-menu {
    min-width: 120px;
    max-width: calc(100vw - 40px);
    right: 0;
    left: auto;
  }

  .dropdown-item {
    padding: 0.75rem;
    min-height: 44px;
    font-size: 0.8125rem;
  }

  .dropdown-item svg {
    width: 16px;
    height: 16px;
  }

  .reply-card {
    margin-left: 1rem;
  }

  .reply-card[data-thread-level="1"] {
    margin-left: 1rem;
  }

  .reply-card[data-thread-level="2"] {
    margin-left: 2rem;
  }

  .reply-card[data-thread-level="3"] {
    margin-left: 3rem;
  }

  .reply-card[data-thread-level="4"] {
    margin-left: 4rem;
  }

  .form-footer {
    flex-direction: column;
    align-items: flex-start;
  }

  .form-actions {
    width: 100%;
    justify-content: flex-end;
  }

  .inline-form-footer {
    flex-direction: column;
    align-items: flex-start;
  }

  .inline-actions {
    width: 100%;
    justify-content: flex-end;
  }

  .emoji-grid {
    grid-template-columns: repeat(6, 1fr);
  }

  .global-emoji-picker {
    width: 280px;
    max-width: calc(100vw - 40px);
  }

  .global-emoji-picker .emoji-grid {
    grid-template-columns: repeat(6, 1fr);
  }

  .global-emoji-picker .emoji-option {
    width: 28px;
    height: 28px;
    font-size: 1.1rem;
  }

  .modal-container {
    width: 95%;
    margin: 10px;
  }

  .modal-actions {
    flex-direction: column;
  }

  .btn-primary,
  .btn-secondary,
  .btn-danger {
    width: 100%;
    justify-content: center;
  }

  .report-reasons {
    margin: 0.5rem 0;
  }

  .report-reason {
    padding: 0.75rem 0.5rem;
  }

  .history-header {
    flex-direction: column;
    align-items: flex-start;
    gap: 0.25rem;
  }

  .load-more-section {
    padding: 1.5rem 1rem;
  }

  .load-more-btn {
    padding: 0.875rem 1.5rem;
    min-width: auto;
    width: 100%;
    max-width: 280px;
  }

  .load-more-replies {
    margin-left: 1rem;
  }

  *::-webkit-scrollbar {
    width: 6px;
    height: 6px;
  }

  .emoji-categories::-webkit-scrollbar {
    height: 3px;
  }

  .emoji-grid::-webkit-scrollbar {
    width: 4px;
  }
}

@media (max-width: 480px) {
  .comment-header {
    padding: 0.5rem;
    gap: 0.5rem;
    min-height: 52px;
  }

  .comment-avatar {
    width: 24px;
    height: 24px;
  }

  .username {
    font-size: 0.75rem;
    max-width: 100px;
  }

  .comment-time-wrapper {
    font-size: 0.625rem;
  }

  .comment-time-wrapper svg {
    width: 8px;
    height: 8px;
  }

  .comment-footer {
    padding: 0.4rem;
    gap: 0.25rem;
    min-height: 52px;
  }

  .vote-btn,
  .reaction-btn,
  .action-btn {
    min-width: 32px;
    min-height: 32px;
    padding: 0.2rem;
    font-size: 0.6875rem;
  }

  .vote-count,
  .reaction-count {
    font-size: 0.75rem;
  }

  .user-details {
    flex-direction: row;
    flex-wrap: nowrap;
    gap: 0.25rem;
  }

  .reply-card,
  .reply-card[data-thread-level="1"],
  .reply-card[data-thread-level="2"],
  .reply-card[data-thread-level="3"],
  .reply-card[data-thread-level="4"] {
    margin-left: 0.5rem;
  }

  .emoji-grid {
    grid-template-columns: repeat(5, 1fr);
  }

  .global-emoji-picker {
    width: 260px;
    max-width: calc(100vw - 20px);
  }

  .global-emoji-picker .emoji-grid {
    grid-template-columns: repeat(5, 1fr);
  }

  .global-emoji-picker .emoji-option {
    width: 26px;
    height: 26px;
    font-size: 1rem;
  }

  .comment-success-indicator {
    top: 10px;
    right: 10px;
    left: 10px;
    text-align: center;
  }

  *::-webkit-scrollbar {
    width: 4px;
    height: 4px;
  }

  .emoji-categories::-webkit-scrollbar {
    height: 2px;
  }

  .emoji-grid::-webkit-scrollbar {
    width: 3px;
  }
}

@media (max-width: 360px) {
  .comment-header {
    padding: 0.4rem;
  }

  .comment-avatar {
    width: 20px;
    height: 20px;
  }

  .username {
    font-size: 0.7rem;
    max-width: 80px;
  }

  .comment-time {
    font-size: 0.6rem;
  }

  .comment-footer {
    gap: 0.15rem;
    padding: 0.3rem;
  }

  .vote-btn,
  .reaction-btn,
  .action-btn {
    min-width: 28px;
    min-height: 28px;
    padding: 0.15rem;
    font-size: 0.625rem;
  }

  .dropdown-menu {
    left: 0.5rem;
    right: 0.5rem;
    width: auto;
  }
}

/* ===== PERFORMANCE OPTIMIZATIONS ===== */
@media (hover: none) and (pointer: coarse) {
  .vote-btn:hover,
  .reaction-btn:hover,
  .action-btn:hover,
  .format-btn:hover,
  .mention-btn:hover,
  .emoji-btn:hover {
    transform: none;
  }
}

/* Hardware acceleration for key elements */
.comment-card,
.modal-container,
.dropdown-menu,
.global-emoji-picker {
  transform: translateZ(0);
  will-change: transform;
}

/* Reduce motion for users who prefer it */
@media (prefers-reduced-motion: reduce) {
  *,
  *::before,
  *::after {
    animation-duration: 0.01ms !important;
    animation-iteration-count: 1 !important;
    transition-duration: 0.01ms !important;
    scroll-behavior: auto !important;
  }
}

.tinkbyte-comment-section {
  max-width: 100%;
}

.comment-text {
  overflow-wrap: anywhere;
  word-break: break-word;
}

.comment-card, .reply-card {
  padding: 12px;
}

.comment-footer {
  gap: 8px;
  flex-wrap: wrap;
}

@media (max-width: 640px) {
  .comment-reactions {
    flex-wrap: wrap;
  }
  
  .reply-btn {
    padding: 4px 8px;
  }
  
  img {
    max-width: 100%;
    height: auto;
  }
  
  textarea {
    width: 100%;
  }

  .comment-actions {
    flex-wrap: wrap;
  }

  .vote-section {
    flex-direction: column;
    align-items: center;
    gap: 4px;
  }
}