---
// src/layouts/Layout.astro - USING YOUR CONFIG SYSTEM
import { SITE, getAllCategories } from "../config/site";
import { config, isDevelopment, isProduction, shouldLog } from "../lib/config"; //
import Header from "../components/ui/Header.astro";
import Footer from "../components/ui/Footer.astro";
import "../styles/global.css";
import FeedbackWidget from "../components/ui/FeedbackWidget.astro";
import SimpleNewsletterModal from "../components/forms/SimpleNewsletterModal.astro";

// Type-safe window property assignment
declare global {
  interface Window {
    supabase?: any;
    TinkByteAPI?: any;
    AuthState?: any;
    authManager?: any;
    toggleTheme?: () => void;
    currentArticleId?: string;
  }
}

export interface Props {
  title?: string;
  description?: string;
  image?: string;
  canonical?: string;
  noindex?: boolean;
  type?: "website" | "article";
  publishedTime?: string;
  modifiedTime?: string;
  author?: string;
  tags?: string[];
}

const {
  title = SITE.title,
  description = SITE.description,
  image = SITE.defaultImage,
  canonical,
  noindex = false,
  type = "website",
  publishedTime,
  modifiedTime,
  author = SITE.author,
  tags = [],
} = Astro.props;

// Safe URL construction
const getSafeCanonicalURL = () => {
  try {
    if (canonical) {
      return canonical.startsWith("http")
        ? canonical
        : new URL(canonical, Astro.site).toString();
    }
    if (Astro.site) {
      return new URL(Astro.url.pathname, Astro.site).toString();
    }
    return `${Astro.url.origin}${Astro.url.pathname}`;
  } catch (error) {
    //console.warn("Error constructing canonical URL:", error);
    return Astro.url.href;
  }
};

const getSafeSocialImage = () => {
  try {
    if (image.startsWith("http://") || image.startsWith("https://")) {
      return image;
    }
    if (Astro.site) {
      return new URL(image, Astro.site).toString();
    }
    return `${Astro.url.origin}${image}`;
  } catch (error) {
    //console.warn("Error constructing social image URL:", error);
    return `${Astro.url.origin}${SITE.defaultImage}`;
  }
};

const canonicalURL = getSafeCanonicalURL();
const socialImage = getSafeSocialImage();

// Enhanced structured data
const getStructuredData = () => {
  const baseData = {
    "@context": "https://schema.org",
    "@type": type === "article" ? "Article" : "WebSite",
    name: title,
    description: description,
    url: canonicalURL,
    publisher: {
      "@type": "Organization",
      name: SITE.name,
      logo: {
        "@type": "ImageObject",
        url: `${Astro.url.origin}/logo.png`,
      },
      url: SITE.url,
      sameAs: [
        `https://twitter.com/${SITE.social.twitter.replace("@", "")}`,
        `https://linkedin.com/${SITE.social.linkedin}`,
        `https://github.com/${SITE.social.github}`,
        `https://youtube.com/${SITE.social.youtube.replace("@", "")}`,
        `https://instagram.com/${SITE.social.instagram.replace("@", "")}`,
        `https://tiktok.com/${SITE.social.tiktok.replace("@", "")}`,
        `https://substack.com/${SITE.social.substack}`,
        `https://medium.com/${SITE.social.medium}`,
        `https://dev.to/${SITE.social.devto}`,
        `https://hashnode.com/${SITE.social.hashnode}`,
        `https://discord.gg/${SITE.social.discord}`,
        `https://t.me/${SITE.social.telegram}`,
      ],
    },
  };

  if (type === "article") {
    return {
      ...baseData,
      "@type": "Article",
      headline: title,
      image: {
        "@type": "ImageObject",
        url: socialImage,
        width: 1200,
        height: 630,
      },
      datePublished: publishedTime,
      dateModified: modifiedTime || publishedTime,
      author: {
        "@type": "Person",
        name: author,
      },
      mainEntityOfPage: {
        "@type": "WebPage",
        "@id": canonicalURL,
      },
      keywords: tags.join(", "),
    };
  }

  return {
    ...baseData,
    potentialAction: {
      "@type": "SearchAction",
      target: {
        "@type": "EntryPoint",
        urlTemplate: `${SITE.url}/search?q={search_term_string}`,
      },
      "query-input": "required name=search_term_string",
    },
  };
};

const structuredData = getStructuredData();
---

<!doctype html>
<html lang={SITE.locale.split("-")[0]} class="scroll-smooth">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="generator" content={Astro.generator} />
    <!-- Replace your current CSP meta tag with this updated one -->
    <meta
      http-equiv="Content-Security-Policy"
      content="script-src 'self' 'unsafe-inline' https://cdn.jsdelivr.net https://static.cloudflareinsights.com; style-src 'self' 'unsafe-inline'; default-src 'self'; img-src 'self' data: https:; connect-src 'self' https://*.supabase.co;"
    />
    <!-- Performance Optimizations -->
    <link rel="dns-prefetch" href="//images.unsplash.com" />
    <link rel="dns-prefetch" href="//fonts.googleapis.com" />
    <link rel="dns-prefetch" href="//fonts.gstatic.com" />
    <link rel="dns-prefetch" href="//cdnjs.cloudflare.com" />
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />

    <script
      is:inline
      define:vars={{
        supabaseUrl: config.supabase.url,
        supabaseKey: config.supabase.anonKey,
        environment: config.environment,
        isDev: isDevelopment(),
        isProd: isProduction(),
        loggingEnabled: shouldLog(),
      }}
    >
      window.TINKBYTE_CONFIG = {
        supabase: {
          url: supabaseUrl,
          anonKey: supabaseKey,
        },
        environment: environment,
        isDevelopment: isDev,
        isProduction: isProd,
        logging: {
          enabled: loggingEnabled,
        },
      };
    </script>

    <!-- Add this in your head section if not already there -->
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2" is:inline
    ></script>

    <!-- FontAwesome Icons -->
    <script is:inline>
      (function () {
        const link = document.createElement("link");
        link.rel = "stylesheet";
        link.href =
          "https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css";
        link.integrity =
          "sha512-DTOQO9RWCH3ppGqcWaEA1BIZOC6xxalwEsw9c2QQeAIftl+Vegovlnee1c9QX4TctnWMn13TZye+giMm8e2LwA==";
        link.crossOrigin = "anonymous";
        link.referrerPolicy = "no-referrer";
        document.head.appendChild(link);
      })();
    </script>

    <!-- Enhanced Theme CSS Variables -->
    <style is:inline>
      :root {
        /* Light theme colors */
        --color-bg-primary: #ffffff;
        --color-bg-secondary: #f8fafc;
        --color-bg-tertiary: #f1f5f9;
        --color-text-primary: #0f172a;
        --color-text-secondary: #475569;
        --color-text-muted: #64748b;
        --color-border: #e2e8f0;
        --color-border-light: #f1f5f9;
        --color-accent: #2563eb;
        --color-accent-hover: #1e40af;
        --color-success: #059669;
        --color-warning: #d97706;
        --color-error: #dc2626;
        --color-info: #0284c7;

        /* Component specific */
        --card-bg: #ffffff;
        --card-border: #e2e8f0;
        --card-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        --card-hover-shadow: 0 4px 16px rgba(0, 0, 0, 0.15);

        /* Perfect square design - no radius */
        --border-radius: 0px;
        --border-radius-sm: 0px;
        --border-radius-md: 0px;
        --border-radius-lg: 0px;
        --border-radius-xl: 0px;
      }

      .dark {
        /* Dark theme colors */
        --color-bg-primary: #0f172a;
        --color-bg-secondary: #1e293b;
        --color-bg-tertiary: #334155;
        --color-text-primary: #f8fafc;
        --color-text-secondary: #cbd5e1;
        --color-text-muted: #94a3b8;
        --color-border: #374151;
        --color-border-light: #4b5563;
        --color-accent: #3b82f6;
        --color-accent-hover: #2563eb;
        --color-success: #10b981;
        --color-warning: #f59e0b;
        --color-error: #ef4444;
        --color-info: #06b6d4;

        /* Dark theme components */
        --card-bg: #1e293b;
        --card-border: #374151;
        --card-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        --card-hover-shadow: 0 4px 16px rgba(0, 0, 0, 0.4);
      }

      /* Base transitions for all elements */
      *,
      *::before,
      *::after {
        transition:
          background-color 0.2s cubic-bezier(0.4, 0, 0.2, 1),
          color 0.2s cubic-bezier(0.4, 0, 0.2, 1),
          border-color 0.2s cubic-bezier(0.4, 0, 0.2, 1),
          box-shadow 0.2s cubic-bezier(0.4, 0, 0.2, 1);
      }

      /* Perfect square design system */
      .theme-card {
        background: var(--card-bg) !important;
        border: 2px solid var(--card-border) !important;
        color: var(--color-text-primary) !important;
        border-radius: var(--border-radius) !important;
        box-shadow: var(--card-shadow) !important;
      }

      .theme-card:hover {
        box-shadow: var(--card-hover-shadow) !important;
        border-color: var(--color-accent) !important;
      }

      /* Text color utilities */
      .theme-text-primary {
        color: var(--color-text-primary) !important;
      }
      .theme-text-secondary {
        color: var(--color-text-secondary) !important;
      }
      .theme-text-muted {
        color: var(--color-text-muted) !important;
      }

      /* Background utilities */
      .theme-bg-primary {
        background-color: var(--color-bg-primary) !important;
      }
      .theme-bg-secondary {
        background-color: var(--color-bg-secondary) !important;
      }
      .theme-bg-tertiary {
        background-color: var(--color-bg-tertiary) !important;
      }

      /* Border utilities */
      .theme-border {
        border-color: var(--color-border) !important;
      }

      /* Override default rounded corners */
      .bg-white,
      .border-gray-200,
      .border-gray-300,
      button,
      input,
      textarea,
      select,
      .card,
      .btn,
      img {
        border-radius: var(--border-radius) !important;
      }

      /* Ensure proper theme inheritance */
      .bg-white {
        background-color: var(--color-bg-primary) !important;
      }
      .text-gray-900 {
        color: var(--color-text-primary) !important;
      }
      .text-gray-600 {
        color: var(--color-text-secondary) !important;
      }
      .text-gray-500 {
        color: var(--color-text-muted) !important;
      }
      .border-gray-200 {
        border-color: var(--color-border) !important;
      }
      .border-gray-300 {
        border-color: var(--color-border) !important;
      }

      /* Enhanced contrast for better accessibility */
      a {
        color: var(--color-accent);
        text-decoration: none;
      }

      a:hover {
        color: var(--color-accent-hover);
        text-decoration: underline;
      }

      /* Button improvements */
      button {
        cursor: pointer;
        transition: all 0.2s ease;
      }

      button:hover {
        transform: translateY(-1px);
      }

      button:active {
        transform: translateY(0);
      }

      /* Focus states for accessibility */
      button:focus,
      input:focus,
      textarea:focus,
      select:focus,
      a:focus {
        outline: 2px solid var(--color-accent);
        outline-offset: 2px;
      }
    </style>

    <!-- Primary Meta Tags -->
    <title>{title}</title>
    <meta name="title" content={title} />
    <meta name="description" content={description} />
    <meta name="author" content={author} />
    <link rel="canonical" href={canonicalURL} />

    <!-- Robots and SEO -->
    {
      noindex ? (
        <meta name="robots" content="noindex, nofollow" />
      ) : (
        <meta name="robots" content="index, follow" />
      )
    }
    <meta name="language" content="English" />
    {tags.length > 0 && <meta name="keywords" content={tags.join(", ")} />}

    <!-- Open Graph / Facebook -->
    <meta property="og:type" content={type} />
    <meta property="og:url" content={canonicalURL} />
    <meta property="og:title" content={title} />
    <meta property="og:description" content={description} />
    <meta property="og:image" content={socialImage} />
    <meta property="og:image:width" content="1200" />
    <meta property="og:image:height" content="630" />
    <meta property="og:site_name" content={SITE.name} />
    <meta property="og:locale" content={SITE.locale} />

    <!-- Article specific Open Graph tags -->
    {
      publishedTime && (
        <meta property="article:published_time" content={publishedTime} />
      )
    }
    {
      modifiedTime && (
        <meta property="article:modified_time" content={modifiedTime} />
      )
    }
    {author && <meta property="article:author" content={author} />}
    {tags.map((tag) => <meta property="article:tag" content={tag} />)}

    <!-- Twitter Card -->
    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:site" content={SITE.social.twitter} />
    <meta name="twitter:creator" content={SITE.social.twitter} />
    <meta name="twitter:url" content={canonicalURL} />
    <meta name="twitter:title" content={title} />
    <meta name="twitter:description" content={description} />
    <meta name="twitter:image" content={socialImage} />

    <!-- Favicons -->
    <link rel="icon" type="image/svg+xml" href={SITE.favicon} />
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png" />
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png" />
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png" />
    <link rel="manifest" href="/site.webmanifest" />
    <meta name="theme-color" content={SITE.brand.primary} />

    <!-- RSS and Alternate Links -->
    <link
      rel="alternate"
      type="application/rss+xml"
      title={`${SITE.name} RSS Feed`}
      href="/rss.xml"
    />

    <!-- Structured Data -->
    <script
      type="application/ld+json"
      set:html={JSON.stringify(structuredData)}
    />

    <!-- Enhanced Theme Detection Script -->
    <script is:inline>
      (function () {
        function getTheme() {
          if (typeof localStorage !== "undefined") {
            const stored = localStorage.getItem("theme");
            if (stored && (stored === "light" || stored === "dark")) {
              return stored;
            }
          }

          if (
            window.matchMedia &&
            window.matchMedia("(prefers-color-scheme: dark)").matches
          ) {
            return "dark";
          }

          return "light";
        }

        function applyTheme(theme) {
          if (theme === "dark") {
            document.documentElement.classList.add("dark");
          } else {
            document.documentElement.classList.remove("dark");
          }

          // Update theme-aware elements
          setTimeout(function () {
            const themeAwareElements = document.querySelectorAll(
              '.theme-card, [data-theme-aware="true"]'
            );
            themeAwareElements.forEach(function (el) {
              el.style.transition = "all 0.2s ease";
            });
          }, 0);
        }

        const theme = getTheme();
        applyTheme(theme);

        // Store the theme
        if (typeof localStorage !== "undefined") {
          localStorage.setItem("theme", theme);
        }

        // Global theme toggle function
        window.toggleTheme = function () {
          const currentTheme = document.documentElement.classList.contains(
            "dark"
          )
            ? "dark"
            : "light";
          const newTheme = currentTheme === "dark" ? "light" : "dark";

          applyTheme(newTheme);

          if (typeof localStorage !== "undefined") {
            localStorage.setItem("theme", newTheme);
          }
        };
      })();
    </script>
  </head>

  <body
    class="bg-white dark:bg-zinc-900 text-zinc-900 dark:text-zinc-100 font-space-grotesk antialiased"
    style="background-color: var(--color-bg-primary); color: var(--color-text-primary);"
  >
    <!-- Skip Navigation Link -->
    <a
      href="#main-content"
      class="sr-only focus:not-sr-only focus:absolute focus:top-4 focus:left-4 focus:bg-white focus:dark:bg-zinc-900 focus:px-4 focus:py-2 focus:shadow-lg focus:z-50 focus:ring-2 focus:ring-blue-500 focus:outline-none"
      style="border-radius: var(--border-radius) !important;"
    >
      Skip to main content
    </a>

    <div class="min-h-screen flex flex-col">
      <Header />

      <main id="main-content" class="flex-1">
        <slot />
      </main>

      <Footer />
    </div>

    <FeedbackWidget
      position="bottom-right"
      theme="auto"
      hideOnPages={["/admin"]}
    />

    <!-- Smart Newsletter Modal - Site-wide -->
    <SimpleNewsletterModal autoShow={true} showDelay={25000} />

    <script is:inline>
      document.addEventListener("DOMContentLoaded", async function () {
        const config = window.TINKBYTE_CONFIG;
        const isDev = config?.isDevelopment || false;

        try {
          // ✅ CONDITIONAL LOGGING BASED ON YOUR CONFIG
          const log = (...args) => {
            if (config?.logging?.enabled && isDev) {
              console.log(...args);
            }
          };

          const logError = (...args) => {
            if (isDev) {
              console.error(...args);
            }
          };

          log("🔄 Setting up modules...");

          // ✅ WAIT FOR SUPABASE SDK
          let attempts = 0;
          while (!window.supabase && attempts < 100) {
            await new Promise((resolve) => setTimeout(resolve, 50));
            attempts++;
          }

          if (!window.supabase) {
            throw new Error("Supabase SDK not loaded");
          }

          if (!config?.supabase?.url || !config?.supabase?.anonKey) {
            throw new Error("Invalid Supabase configuration");
          }

          // ✅ CREATE SUPABASE CLIENT
          const supabaseClient = window.supabase.createClient(
            config.supabase.url,
            config.supabase.anonKey,
            {
              auth: {
                autoRefreshToken: true,
                persistSession: true,
                detectSessionInUrl: true,
                flowType: "pkce",
                storage: window.localStorage,
                storageKey: `tinkbyte-auth-${config.environment}`,
              },
            }
          );

          // ✅ PRODUCTION-READY TINKBYTE API
          window.TinkByteAPI = {
            async addComment(articleId, content, parentId = null) {
              try {
                const {
                  data: { session },
                } = await supabaseClient.auth.getSession();
                if (!session?.user) throw new Error("Authentication required");

                const commentData = {
                  id: crypto.randomUUID(),
                  content: content,
                  raw_content: content,
                  user_id: session.user.id,
                  article_id: articleId,
                  parent_id: parentId,
                  thread_level: parentId ? 1 : 0,
                  environment: config.environment,
                  moderation_status: "auto_approved",
                  like_count: 0,
                  reply_count: 0,
                  created_at: new Date().toISOString(),
                  updated_at: new Date().toISOString(),
                };

                const { data, error } = await supabaseClient
                  .from("comments")
                  .insert(commentData)
                  .select("*")
                  .single();

                if (error) throw error;
                return { success: true, data };
              } catch (error) {
                return { success: false, error: error.message };
              }
            },

            async toggleCommentBookmark(commentId) {
              try {
                const {
                  data: { session },
                } = await supabaseClient.auth.getSession();
                if (!session?.user) throw new Error("Authentication required");

                const { data: existing } = await supabaseClient
                  .from("comment_bookmarks")
                  .select("id")
                  .eq("user_id", session.user.id)
                  .eq("comment_id", commentId)
                  .eq("environment", config.environment)
                  .single();

                if (existing) {
                  await supabaseClient
                    .from("comment_bookmarks")
                    .delete()
                    .eq("id", existing.id);
                  return { success: true, bookmarked: false };
                } else {
                  await supabaseClient.from("comment_bookmarks").insert({
                    user_id: session.user.id,
                    comment_id: commentId,
                    environment: config.environment,
                    created_at: new Date().toISOString(),
                  });
                  return { success: true, bookmarked: true };
                }
              } catch (error) {
                return { success: false, error: error.message };
              }
            },

            async toggleCommentReaction(commentId, reactionType) {
              try {
                const {
                  data: { session },
                } = await supabaseClient.auth.getSession();
                if (!session?.user) throw new Error("Authentication required");

                const { data: existing } = await supabaseClient
                  .from("comment_reactions")
                  .select("id")
                  .eq("user_id", session.user.id)
                  .eq("comment_id", commentId)
                  .eq("reaction_type", reactionType)
                  .eq("environment", config.environment)
                  .single();

                if (existing) {
                  await supabaseClient
                    .from("comment_reactions")
                    .delete()
                    .eq("id", existing.id);

                  const { count } = await supabaseClient
                    .from("comment_reactions")
                    .select("*", { count: "exact", head: true })
                    .eq("comment_id", commentId)
                    .eq("reaction_type", reactionType)
                    .eq("environment", config.environment);

                  return { success: true, reacted: false, count: count || 0 };
                } else {
                  await supabaseClient.from("comment_reactions").insert({
                    user_id: session.user.id,
                    comment_id: commentId,
                    reaction_type: reactionType,
                    environment: config.environment,
                    created_at: new Date().toISOString(),
                  });

                  const { count } = await supabaseClient
                    .from("comment_reactions")
                    .select("*", { count: "exact", head: true })
                    .eq("comment_id", commentId)
                    .eq("reaction_type", reactionType)
                    .eq("environment", config.environment);

                  return { success: true, reacted: true, count: count || 0 };
                }
              } catch (error) {
                return { success: false, error: error.message };
              }
            },

            // ✅ ADD MISSING ARTICLE TRACKING METHODS
            async recordArticleRead(
              articleId,
              readPercentage = 100,
              timeSpentSeconds = 0
            ) {
              try {
                const {
                  data: { session },
                } = await supabaseClient.auth.getSession();
                if (!session?.user)
                  return { success: false, error: "User not authenticated" };

                log("📖 Recording article read:", {
                  articleId,
                  userId: session.user.id,
                  readPercentage,
                  timeSpentSeconds,
                });

                // ✅ FIRST CHECK IF RECORD EXISTS (USING UPSERT APPROACH)
                const { data, error } = await supabaseClient
                  .from("article_reads")
                  .upsert(
                    {
                      user_id: session.user.id,
                      article_id: articleId,
                      read_percentage: readPercentage,
                      time_spent_seconds: timeSpentSeconds,
                      updated_at: new Date().toISOString(),
                    },
                    {
                      onConflict: "user_id,article_id",
                      ignoreDuplicates: false,
                    }
                  )
                  .select()
                  .single();

                if (error) {
                  logError("❌ Article read recording error:", error);
                  return { success: false, error: error.message };
                }

                log("✅ Article read recorded successfully");
                return { success: true, data };
              } catch (error) {
                logError("❌ Article read recording failed:", error);
                return { success: false, error: error.message };
              }
            },

            async recordActivity(
              activityType,
              entityType,
              entityId,
              metadata = {}
            ) {
              try {
                const {
                  data: { session },
                } = await supabaseClient.auth.getSession();
                if (!session?.user)
                  return { success: false, error: "User not authenticated" };

                let description = "";
                switch (activityType) {
                  case "read":
                    description = `Read an ${entityType}`;
                    break;
                  case "comment":
                    description = `Commented on ${entityType}`;
                    break;
                  case "like":
                    description = `Liked a ${entityType}`;
                    break;
                  default:
                    description = `Performed ${activityType} on ${entityType}`;
                }

                const { data, error } = await supabaseClient
                  .from("user_activities")
                  .insert({
                    user_id: session.user.id,
                    activity_type: activityType,
                    entity_type: entityType,
                    entity_id: entityId,
                    description: description,
                    metadata: metadata,
                    environment: config.environment,
                    created_at: new Date().toISOString(),
                  })
                  .select()
                  .single();

                if (error) throw error;
                return { success: true, data };
              } catch (error) {
                return { success: false, error: error.message };
              }
            },

            async addComment(articleId, content, parentId = null) {
              try {
                const {
                  data: { session },
                } = await supabaseClient.auth.getSession();
                if (!session?.user) throw new Error("Authentication required");

                const commentData = {
                  id: crypto.randomUUID(),
                  content: content,
                  raw_content: content,
                  user_id: session.user.id,
                  article_id: articleId,
                  parent_id: parentId,
                  thread_level: parentId ? 1 : 0,
                  environment: config.environment,
                  moderation_status: "auto_approved",
                  like_count: 0,
                  reply_count: 0,
                  created_at: new Date().toISOString(),
                  updated_at: new Date().toISOString(),
                };

                const { data, error } = await supabaseClient
                  .from("comments")
                  .insert(commentData)
                  .select("*")
                  .single();

                if (error) throw error;
                return { success: true, data };
              } catch (error) {
                return { success: false, error: error.message };
              }
            },

            async toggleCommentLike(commentId) {
              try {
                const {
                  data: { session },
                } = await supabaseClient.auth.getSession();
                if (!session?.user) throw new Error("Authentication required");

                // ✅ NO ENVIRONMENT FILTER FOR LIKES
                const { data: existing } = await supabaseClient
                  .from("comment_likes")
                  .select("id")
                  .eq("user_id", session.user.id)
                  .eq("comment_id", commentId)
                  .single();

                if (existing) {
                  await supabaseClient
                    .from("comment_likes")
                    .delete()
                    .eq("id", existing.id);
                  return { success: true, liked: false };
                } else {
                  await supabaseClient.from("comment_likes").insert({
                    user_id: session.user.id,
                    comment_id: commentId,
                    environment: config.environment,
                    created_at: new Date().toISOString(),
                  });
                  return { success: true, liked: true };
                }
              } catch (error) {
                return { success: false, error: error.message };
              }
            },

            async updateComment(commentId, content, editReason = null) {
              try {
                const {
                  data: { session },
                } = await supabaseClient.auth.getSession();
                if (!session?.user) throw new Error("Authentication required");

                const { data, error } = await supabaseClient
                  .from("comments")
                  .update({
                    content,
                    raw_content: content,
                    edit_reason: editReason,
                    is_edited: true,
                    updated_at: new Date().toISOString(),
                  })
                  .eq("id", commentId)
                  .eq("user_id", session.user.id)
                  .select("*")
                  .single();

                if (error) throw error;
                return { success: true, data };
              } catch (error) {
                return { success: false, error: error.message };
              }
            },

            async deleteComment(commentId) {
              try {
                const {
                  data: { session },
                } = await supabaseClient.auth.getSession();
                if (!session?.user) throw new Error("Authentication required");

                const { error } = await supabaseClient
                  .from("comments")
                  .update({
                    is_deleted: true,
                    deleted_at: new Date().toISOString(),
                    deleted_by: session.user.id,
                  })
                  .eq("id", commentId)
                  .eq("user_id", session.user.id);

                if (error) throw error;
                return { success: true };
              } catch (error) {
                return { success: false, error: error.message };
              }
            },

            async saveCommentDraft(articleId, content) {
              try {
                const {
                  data: { session },
                } = await supabaseClient.auth.getSession();
                if (!session?.user || !content) return { success: false };

                const { data, error } = await supabaseClient
                  .from("comment_drafts")
                  .upsert(
                    {
                      user_id: session.user.id,
                      article_id: articleId,
                      content,
                      environment: config.environment,
                      updated_at: new Date().toISOString(),
                    },
                    {
                      onConflict: "user_id,article_id,environment",
                    }
                  )
                  .select()
                  .single();

                return { success: !error, data };
              } catch (error) {
                return { success: false, error: error.message };
              }
            },

            async getCommentDraft(articleId) {
              try {
                const {
                  data: { session },
                } = await supabaseClient.auth.getSession();
                if (!session?.user) return { success: false };

                const { data, error } = await supabaseClient
                  .from("comment_drafts")
                  .select("*")
                  .eq("user_id", session.user.id)
                  .eq("article_id", articleId)
                  .eq("environment", config.environment)
                  .maybeSingle();

                return { success: !error, data };
              } catch (error) {
                return { success: false, error: error.message };
              }
            },
          };

          // ✅ PRODUCTION-READY AUTH MANAGER
          window.authManager = {
            authState: {
              currentUser: null,
              profile: null,
              isAuthenticated: false,
            },

            async initialize() {
              try {
                const {
                  data: { session },
                } = await supabaseClient.auth.getSession();

                if (session?.user) {
                  this.authState.currentUser = {
                    id: session.user.id,
                    email: session.user.email,
                    user_metadata: session.user.user_metadata, // ✅ PRESERVE USER METADATA
                  };
                  this.authState.isAuthenticated = true;

                  // ✅ SMART PROFILE LOADING WITH FALLBACKS
                  let profile = null;

                  // Try with environment filter first
                  const { data: envProfile } = await supabaseClient
                    .from("profiles")
                    .select("*")
                    .eq("id", session.user.id)
                    .eq("environment", config.environment)
                    .single();

                  if (envProfile) {
                    profile = envProfile;
                  } else {
                    // Fallback without environment filter
                    const { data: fallbackProfile } = await supabaseClient
                      .from("profiles")
                      .select("*")
                      .eq("id", session.user.id)
                      .single();

                    if (fallbackProfile) {
                      profile = fallbackProfile;
                    } else {
                      // Create profile if none exists
                      const displayName =
                        session.user.user_metadata?.display_name ||
                        session.user.user_metadata?.full_name ||
                        session.user.email?.split("@")[0] ||
                        "User";

                      const newProfile = {
                        id: session.user.id,
                        display_name: displayName,
                        first_name:
                          session.user.user_metadata?.given_name || null,
                        last_name:
                          session.user.user_metadata?.family_name || null,
                        avatar_url:
                          session.user.user_metadata?.avatar_url ||
                          session.user.user_metadata?.picture ||
                          null,
                        avatar_type: session.user.user_metadata?.avatar_url
                          ? "google"
                          : "preset",
                        avatar_preset_id: 1,
                        total_reads: 0,
                        total_comments: 0,
                        total_articles: 0,
                        reputation_score: 0,
                        following_count: 0,
                        followers_count: 0,
                        is_public: true,
                        membership_type: "free",
                        is_admin: session.user.email === "tinkbytehq@gmail.com",
                        environment: config.environment,
                        created_at: new Date().toISOString(),
                        updated_at: new Date().toISOString(),
                      };

                      const { data: createdProfile } = await supabaseClient
                        .from("profiles")
                        .insert(newProfile)
                        .select()
                        .single();

                      profile = createdProfile || newProfile;
                    }
                  }

                  this.authState.profile = profile;
                }
              } catch (error) {
                if (config.logging.enabled && isDev) {
                  logError("Auth initialization failed:", error);
                }
              }
            },

            getCurrentUser() {
              return this.authState.currentUser;
            },

            getProfile() {
              return this.authState.profile;
            },

            isUserAuthenticated() {
              return this.authState.isAuthenticated;
            },

            // ✅ ADD MISSING AVATAR HELPER
            getAvatarUrl() {
              const profile = this.authState.profile;
              const user = this.authState.currentUser;

              if (profile?.avatar_type === "uploaded" && profile?.avatar_url) {
                return profile.avatar_url;
              }

              if (profile?.avatar_type === "google" && profile?.avatar_url) {
                return profile.avatar_url;
              }

              // ✅ FALLBACK TO USER METADATA FOR GOOGLE USERS
              if (user?.user_metadata?.avatar_url) {
                return user.user_metadata.avatar_url;
              }

              if (user?.user_metadata?.picture) {
                return user.user_metadata.picture;
              }

              return `/images/avatars/preset-${profile?.avatar_preset_id || 1}.svg`;
            },

            // ✅ ADD MISSING DISPLAY NAME HELPER
            getDisplayName() {
              const profile = this.authState.profile;
              const user = this.authState.currentUser;

              return (
                profile?.display_name ||
                user?.user_metadata?.display_name ||
                user?.user_metadata?.full_name ||
                user?.user_metadata?.name ||
                user?.email?.split("@")[0] ||
                "User"
              );
            },

            onAuthStateChange(callback) {
              const {
                data: { subscription },
              } = supabaseClient.auth.onAuthStateChange(
                async (event, session) => {
                  log("🔄 Auth state changed:", event);

                  if (event === "SIGNED_IN" && session?.user) {
                    this.authState.currentUser = {
                      id: session.user.id,
                      email: session.user.email,
                      user_metadata: session.user.user_metadata, // ✅ PRESERVE METADATA
                    };
                    this.authState.isAuthenticated = true;
                    await this.initialize();
                    callback(
                      this.authState.currentUser,
                      this.authState.profile
                    );
                  } else if (event === "SIGNED_OUT") {
                    this.authState.currentUser = null;
                    this.authState.profile = null;
                    this.authState.isAuthenticated = false;
                    callback(null, null);
                  }
                }
              );
              return () => subscription.unsubscribe();
            },
          };

          // ✅ SET GLOBAL REFERENCES
          window.supabase = supabaseClient;
          await window.authManager.initialize();

          log("✅ Modules initialized successfully");

          // ✅ DISPATCH READY EVENT
          window.dispatchEvent(
            new CustomEvent("authReady", {
              detail: {
                supabase: supabaseClient,
                TinkByteAPI: window.TinkByteAPI,
                authManager: window.authManager,
              },
            })
          );
        } catch (error) {
          logError("❌ Module setup failed:", error);

          // ✅ SHOW USER-FRIENDLY ERROR
          const commentSections =
            document.querySelectorAll("#comments-section");
          commentSections.forEach((section) => {
            if (section) {
              section.innerHTML = `
                <div style="padding: 2rem; text-align: center; background: #fee2e2; border: 1px solid #fecaca; border-radius: 8px; margin: 1rem 0;">
                  <h3 style="color: #dc2626; margin-bottom: 0.5rem;">Comments Temporarily Unavailable</h3>
                  <p style="color: #991b1b; margin-bottom: 1rem;">Please refresh the page or try again later.</p>
                  <button onclick="window.location.reload()" style="background: #dc2626; color: white; border: none; padding: 0.5rem 1rem; border-radius: 4px; cursor: pointer;">
                    Retry
                  </button>
                </div>
              `;
            }
          });
        }
      });
    </script>

    <!-- Enhanced Theme and Functionality Script -->
    <script is:inline>
      document.addEventListener("DOMContentLoaded", function () {
        // Minimal Smart Loader - Brand Style
        let loader, loadTimeout;

        function showLoader() {
          if (loader) return;
          loader = document.createElement("div");
          loader.innerHTML = `
      <div style="
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        z-index: 9999;
        padding: 12px;
        background: var(--color-bg-primary);
        border: 2px solid var(--color-border);
        box-shadow: var(--card-shadow);
      ">
        <div style="
          width: 6px;
          height: 6px;
          background: var(--color-accent);
          animation: tinkbyte-pulse 1.2s ease-in-out infinite;
        "></div>
      </div>
      <style>
        @keyframes tinkbyte-pulse {
          0%, 100% { opacity: 0.3; transform: scale(1); }
          50% { opacity: 1; transform: scale(1.2); }
        }
      </style>
    `;
          document.body.appendChild(loader);
        }

        function hideLoader() {
          if (loader) {
            loader.remove();
            loader = null;
          }
          clearTimeout(loadTimeout);
        }

        // Apply theme to all elements
        const applyThemeToAllElements = () => {
          // Apply theme classes to cards and components
          const cards = document.querySelectorAll(
            ".bg-white, .border-gray-200, .border-gray-300"
          );
          cards.forEach((card) => {
            card.classList.add("theme-card");
            card.setAttribute("data-theme-aware", "true");
          });

          // Force repaint for theme consistency
          document.body.style.display = "none";
          document.body.offsetHeight; // Trigger reflow
          document.body.style.display = "";
        };

        // Apply theme immediately
        applyThemeToAllElements();

        // Enhanced theme toggle functionality
        const themeToggle = document.querySelector("#theme-toggle");
        if (themeToggle) {
          themeToggle.addEventListener("click", () => {
            if (window.toggleTheme) {
              window.toggleTheme();
            }

            // Force update all elements after theme change
            setTimeout(() => {
              applyThemeToAllElements();
            }, 50);
          });
        }

        // Smart loader for navigation - only when needed
        document.addEventListener("click", function (e) {
          const link = e.target.closest("a");
          if (
            link &&
            link.href &&
            link.href.startsWith(window.location.origin)
          ) {
            // Wait 400ms before showing - if page loads fast, loader never appears
            loadTimeout = setTimeout(showLoader, 400);
          }
        });

        // Show loader on connection issues
        window.addEventListener("offline", showLoader);
        window.addEventListener("online", hideLoader);

        // Hide loader when page loads
        window.addEventListener("load", hideLoader);
        window.addEventListener("beforeunload", hideLoader);

        // Smooth scroll for anchor links
        document.querySelectorAll('a[href^="#"]').forEach((anchor) => {
          anchor.addEventListener("click", function (e) {
            e.preventDefault();
            const target = document.querySelector(this.getAttribute("href"));
            if (target) {
              target.scrollIntoView({
                behavior: "smooth",
                block: "start",
              });
            }
          });
        });

        // Add this to your Layout.astro script section
        window.addEventListener("unhandledrejection", (event) => {
          if (
            event.reason?.message?.includes("message channel closed") ||
            event.reason?.message?.includes(
              "listener indicated an asynchronous response"
            )
          ) {
            event.preventDefault();
            console.log("🔇 Suppressed extension-related error");
          }
        });

        // External link handling
        document.querySelectorAll('a[href^="http"]').forEach((link) => {
          if (!link.href.includes(window.location.hostname)) {
            link.setAttribute("target", "_blank");
            link.setAttribute("rel", "noopener noreferrer");
          }
        });

        // Mobile menu toggle
        const mobileMenuToggle = document.querySelector("#mobile-menu-toggle");
        const mobileMenu = document.querySelector("#mobile-menu");

        if (mobileMenuToggle && mobileMenu) {
          mobileMenuToggle.addEventListener("click", () => {
            const isHidden = mobileMenu.classList.contains("hidden");
            mobileMenu.classList.toggle("hidden", !isHidden);
            mobileMenuToggle.setAttribute(
              "aria-expanded",
              isHidden ? "true" : "false"
            );
          });

          // Close mobile menu when clicking outside
          document.addEventListener("click", (e) => {
            if (
              !mobileMenuToggle.contains(e.target) &&
              !mobileMenu.contains(e.target)
            ) {
              mobileMenu.classList.add("hidden");
              mobileMenuToggle.setAttribute("aria-expanded", "false");
            }
          });
        }

        // Watch for dynamic content and apply theme
        const mutationObserver = new MutationObserver((mutations) => {
          mutations.forEach((mutation) => {
            if (mutation.type === "childList") {
              mutation.addedNodes.forEach((node) => {
                if (node.nodeType === 1) {
                  const element = node;
                  if (
                    element.classList &&
                    (element.classList.contains("bg-white") ||
                      element.classList.contains("border-gray-200"))
                  ) {
                    element.classList.add("theme-card");
                    element.setAttribute("data-theme-aware", "true");
                  }
                }
              });
            }
          });
        });

        mutationObserver.observe(document.body, {
          childList: true,
          subtree: true,
        });

        // Intersection Observer for animations
        const observerOptions = {
          threshold: 0.1,
          rootMargin: "0px 0px -50px 0px",
        };

        const observer = new IntersectionObserver((entries) => {
          entries.forEach((entry) => {
            if (entry.isIntersecting) {
              entry.target.classList.add("animate-in");
              observer.unobserve(entry.target);
            }
          });
        }, observerOptions);

        // Observe elements with fade-in class
        document.querySelectorAll(".fade-in").forEach((el) => {
          observer.observe(el);
        });

        // Enhanced keyboard navigation
        document.addEventListener("keydown", (e) => {
          // Escape key to close modals/dropdowns
          if (e.key === "Escape") {
            document
              .querySelectorAll(".modal, .dropdown-menu")
              .forEach((el) => {
                el.classList.add("hidden");
              });
            // Also hide loader on escape
            hideLoader();
          }

          // Tab navigation improvements
          if (e.key === "Tab") {
            document.body.classList.add("keyboard-navigation");
          }
        });

        // Remove keyboard navigation class on mouse use
        document.addEventListener("mousedown", () => {
          document.body.classList.remove("keyboard-navigation");
        });
      });
    </script>

    <!-- Keyboard navigation styles -->
    <style is:inline>
      .keyboard-navigation *:focus {
        outline: 2px solid var(--color-accent) !important;
        outline-offset: 2px !important;
      }

      /* Hide focus outline when not using keyboard */
      body:not(.keyboard-navigation) *:focus {
        outline: none !important;
      }

      /* Ensure good contrast for focus states */
      .keyboard-navigation button:focus,
      .keyboard-navigation a:focus,
      .keyboard-navigation input:focus,
      .keyboard-navigation textarea:focus {
        box-shadow: 0 0 0 2px var(--color-accent) !important;
      }
    </style>
  </body>
</html>
