---
// src/components/blog/TinkByteCommentsEnhanced.astro
export interface Props {
  postSlug: string;
  postTitle: string;
}

const { postSlug, postTitle } = Astro.props;
---

<div
  class="tinkbyte-comments-enhanced"
  data-post-slug={postSlug}
  data-post-title={postTitle}
>
  <!-- Comments Header -->
  <div class="comments-header-enhanced">
    <div class="comments-stats">
      <h3 class="comments-title">
        <svg
          width="20"
          height="20"
          viewBox="0 0 24 24"
          fill="none"
          stroke="currentColor"
        >
          <path
            d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"
          ></path>
        </svg>
        THREAD
        <span class="comment-count">1</span>
      </h3>
      <div class="header-actions">
        <button class="manage-btn">
          Manage Your <span class="highlight">TINKBYTE</span> Account
          <svg
            width="16"
            height="16"
            viewBox="0 0 24 24"
            fill="none"
            stroke="currentColor"
          >
            <path d="M20 21v-2a4 4 0 0 0-4-4H8a4 4 0 0 0-4 4v2"></path>
            <circle cx="12" cy="7" r="4"></circle>
          </svg>
        </button>
      </div>
    </div>
    <div class="thread-description">
      We want to hear from you! Share your opinions in the thread below and
      remember to keep it respectful.
    </div>
  </div>

  <!-- User Status Bar -->
  <div class="user-status-bar" id="user-status-bar">
    <!-- Will be populated by JavaScript -->
  </div>

  <!-- Comment Form -->
  <div class="comment-form-container" style="display: none;">
    <form class="comment-form-enhanced">
      <!-- Reply Context -->
      <div class="reply-context" id="reply-context" style="display: none;">
        <div class="reply-header">
          <svg
            width="16"
            height="16"
            viewBox="0 0 24 24"
            fill="none"
            stroke="currentColor"
          >
            <polyline points="9,17 4,12 9,7"></polyline>
            <path d="M20 18v-2a4 4 0 0 0-4-4H4"></path>
          </svg>
          <span>Replying to <strong id="reply-author"></strong></span>
          <button type="button" class="cancel-reply-btn" id="cancel-reply"
            >×</button
          >
        </div>
        <div class="reply-preview" id="reply-preview"></div>
      </div>

      <!-- User Info -->
      <div class="user-info-enhanced">
        <div class="user-avatar-container">
          <div class="user-avatar-display" id="user-avatar-display">
            <!-- Will be populated by JavaScript -->
          </div>
        </div>
        <div class="user-inputs" id="user-inputs">
          <!-- Will be populated based on auth status -->
        </div>
      </div>

      <!-- Comment Editor -->
      <div class="comment-editor-enhanced">
        <div class="editor-toolbar">
          <div class="formatting-tools">
            <button
              type="button"
              class="format-btn"
              data-format="**bold**"
              title="Bold"
            >
              <strong>B</strong>
            </button>
            <button
              type="button"
              class="format-btn"
              data-format="_italic_"
              title="Italic"
            >
              <em>I</em>
            </button>
            <button
              type="button"
              class="format-btn"
              data-format="`code`"
              title="Code"
            >
              <code>&lt;/&gt;</code>
            </button>

            <button type="button" class="emoji-btn" title="Add Emoji">
              <svg
                width="16"
                height="16"
                viewBox="0 0 24 24"
                fill="none"
                stroke="currentColor"
              >
                <circle cx="12" cy="12" r="10"></circle>
                <path d="M8 14s1.5 2 4 2 4-2 4-2"></path>
                <line x1="9" y1="9" x2="9.01" y2="9"></line>
                <line x1="15" y1="9" x2="15.01" y2="9"></line>
              </svg>
            </button>
          </div>
          <div class="editor-info">
            <span class="character-count" id="character-count">0/1000</span>
          </div>
        </div>

        <textarea
          class="comment-textarea-enhanced"
          placeholder="Share your thoughts"
          rows="4"
          maxlength="1000"
          required></textarea>

        <div class="form-footer">
          <div class="community-notice">
            Please respect our <a
              href="/terms#community-guidelines"
              target="_blank">community guidelines</a
            >. No links, inappropriate language, or spam.
          </div>
          <div class="form-actions">
            <button type="button" class="cancel-btn">
              <svg
                width="16"
                height="16"
                viewBox="0 0 24 24"
                fill="none"
                stroke="currentColor"
              >
                <line x1="18" y1="6" x2="6" y2="18"></line>
                <line x1="6" y1="6" x2="18" y2="18"></line>
              </svg>
            </button>
            <button type="submit" class="submit-btn">
              <svg
                width="16"
                height="16"
                viewBox="0 0 24 24"
                fill="none"
                stroke="currentColor"
              >
                <line x1="22" y1="2" x2="11" y2="13"></line>
                <polygon points="22,2 15,22 11,13 2,9 22,2"></polygon>
              </svg>
            </button>
          </div>
        </div>
      </div>
    </form>
  </div>

  <!-- Comments List -->
  <div class="comments-list-enhanced">
    <div class="loading-state">
      <div class="loading-spinner"></div>
      <p>Loading discussion...</p>
    </div>
  </div>

  <!-- Empty State -->
  <div class="empty-state" style="display: none;">
    <div class="empty-icon">
      <svg
        width="64"
        height="64"
        viewBox="0 0 24 24"
        fill="none"
        stroke="currentColor"
      >
        <path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"
        ></path>
        <path d="M8 9h8"></path>
        <path d="M8 13h6"></path>
      </svg>
    </div>
    <h4>Start the conversation</h4>
    <p>Be the first to share your thoughts on this article.</p>
    <button class="start-discussion-btn">
      <svg
        width="20"
        height="20"
        viewBox="0 0 24 24"
        fill="none"
        stroke="currentColor"
      >
        <line x1="12" y1="5" x2="12" y2="19"></line>
        <line x1="5" y1="12" x2="19" y2="12"></line>
      </svg>
      Start Discussion
    </button>
  </div>

  <!-- Footer Links -->
  <div class="comments-footer">
    <div class="footer-links">
      <a href="/terms">Terms</a>
      <a href="/privacy">Privacy</a>
      <a href="/contact">Feedback</a>
    </div>
    <div class="recommended-section">
      <h4>
        <svg
          width="16"
          height="16"
          viewBox="0 0 24 24"
          fill="none"
          stroke="currentColor"
        >
          <polygon
            points="12,2 15.09,8.26 22,9.27 17,14.14 18.18,21.02 12,17.77 5.82,21.02 7,14.14 2,9.27 8.91,8.26 12,2"
          ></polygon>
        </svg>
        RECOMMENDED
      </h4>
    </div>
  </div>
</div>

<style>
  /* TinkByte Comments - Square Design System */
  .tinkbyte-comments-enhanced {
    background: var(--color-bg-primary);
    border: 1px solid var(--color-border);
    margin: 2rem 0;
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
    color: var(--color-text-primary);
    overflow: hidden;
  }
  
  :global(.dark) .tinkbyte-comments-enhanced {
    background: #1a1a1a;
    border-color: #333;
    color: #e0e0e0;
  }
  
  /* Global Square Design Enforcement */
  .tinkbyte-comments-enhanced *,
  .tinkbyte-comments-enhanced *::before,
  .tinkbyte-comments-enhanced *::after {
    border-radius: 0 !important;
  }
  
  /* Exception for loading spinner */
  .loading-spinner {
    border-radius: 50% !important;
  }
  
  /* ===== HEADER SECTION ===== */
  .comments-header-enhanced {
    background: var(--color-bg-secondary);
    border-bottom: 1px solid var(--color-border);
    padding: 1rem 1.5rem;
  }
  
  :global(.dark) .comments-header-enhanced {
    background: #2a2a2a;
    border-color: #333;
  }
  
  .comments-stats {
    display: flex;
    align-items: center;
    justify-content: space-between;
    margin-bottom: 0.75rem;
  }
  
  .comments-title {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    margin: 0;
    font-size: 1.125rem;
    font-weight: 700;
    color: var(--color-text-primary);
    text-transform: uppercase;
    letter-spacing: 0.05em;
  }
  
  .comment-count {
    background: var(--color-accent);
    color: white;
    padding: 0.25rem 0.5rem;
    font-size: 0.875rem;
    font-weight: 600;
    min-width: 1.5rem;
    text-align: center;
  }
  
  .manage-btn {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    background: none;
    border: 1px solid var(--color-border);
    color: var(--color-text-secondary);
    padding: 0.5rem 1rem;
    cursor: pointer;
    transition: all 0.2s ease;
    font-size: 0.875rem;
  }
  
  .manage-btn:hover {
    background: var(--color-bg-primary);
    color: var(--color-text-primary);
  }
  
  .highlight {
    color: var(--color-accent);
    font-weight: 700;
  }
  
  .thread-description {
    color: var(--color-text-secondary);
    font-size: 0.875rem;
    line-height: 1.4;
  }
  
  /* ===== USER STATUS BAR ===== */
  .user-status-bar {
    background: var(--color-bg-secondary);
    border-bottom: 1px solid var(--color-border);
    padding: 1rem 1.5rem;
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: 1rem;
  }
  
  :global(.dark) .user-status-bar {
    background: #2a2a2a;
    border-color: #333;
  }
  
  .user-status-info {
    display: flex;
    align-items: center;
    gap: 0.75rem;
  }
  
  .user-status-avatar {
    width: 40px;
    height: 40px;
    background: var(--color-accent);
    color: white;
    display: flex;
    align-items: center;
    justify-content: center;
    font-weight: 700;
    font-size: 0.875rem;
    overflow: hidden;
    border: 2px solid var(--color-border);
  }
  
  .user-status-avatar-guest {
    background: var(--color-bg-primary);
    color: var(--color-text-muted);
  }
  
  .user-status-text {
    flex: 1;
    min-width: 0;
  }
  
  .user-status-main {
    font-size: 0.875rem;
    color: var(--color-text-secondary);
    line-height: 1.4;
  }
  
  .user-status-actions {
    display: flex;
    gap: 0.5rem;
  }
  
  .status-btn {
    padding: 0.5rem 1rem;
    background: none;
    border: 1px solid var(--color-border);
    color: var(--color-text-secondary);
    cursor: pointer;
    transition: all 0.2s ease;
    font-size: 0.875rem;
    text-decoration: none;
    display: inline-flex;
    align-items: center;
    gap: 0.375rem;
  }
  
  .status-btn:hover {
    background: var(--color-bg-primary);
    color: var(--color-text-primary);
  }
  
  .status-btn.primary {
    background: var(--color-accent);
    color: white;
    border-color: var(--color-accent);
  }
  
  .status-btn.primary:hover {
    background: var(--color-accent-hover);
  }
  
  /* ===== COMMENT FORM ===== */
  .comment-form-container {
    background: var(--color-bg-primary);
    border-bottom: 1px solid var(--color-border);
    padding: 1.5rem;
  }
  
  :global(.dark) .comment-form-container {
    background: #1a1a1a;
    border-color: #333;
  }
  
  .reply-context {
    background: var(--color-bg-secondary);
    border: 2px solid var(--color-accent);
    border-left: 4px solid var(--color-accent);
    padding: 1rem;
    margin-bottom: 1rem;
  }
  
  .reply-header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    margin-bottom: 0.75rem;
    font-size: 0.875rem;
    color: var(--color-accent);
    font-weight: 600;
  }
  
  .cancel-reply-btn {
    margin-left: auto;
    background: none;
    border: none;
    color: var(--color-text-muted);
    cursor: pointer;
    font-size: 1.25rem;
    padding: 0.25rem;
  }
  
  .reply-preview {
    background: var(--color-bg-primary);
    border-left: 4px solid var(--color-accent);
    padding: 0.75rem;
    font-size: 0.875rem;
    color: var(--color-text-secondary);
    font-style: italic;
  }
  
  .user-info-enhanced {
    display: flex;
    align-items: flex-start;
    gap: 1rem;
    margin-bottom: 1rem;
  }
  
  .user-avatar-display {
    width: 48px;
    height: 48px;
    background: var(--color-accent);
    color: white;
    display: flex;
    align-items: center;
    justify-content: center;
    font-weight: 700;
    font-size: 1rem;
    flex-shrink: 0;
    overflow: hidden;
    border: 2px solid var(--color-border);
  }
  
  .user-avatar-display.guest {
    background: var(--color-bg-secondary);
    color: var(--color-text-muted);
  }
  
  .user-inputs,
  .guest-user-inputs {
    flex: 1;
    display: flex;
    flex-direction: column;
    gap: 0.75rem;
  }
  
  .user-name,
  .user-email {
    width: 100%;
    padding: 0.75rem;
    border: 1px solid var(--color-border);
    background: var(--color-bg-primary);
    color: var(--color-text-primary);
    font-size: 0.875rem;
    transition: border-color 0.2s ease;
  }
  
  .user-name:focus,
  .user-email:focus {
    outline: none;
    border-color: var(--color-accent);
  }
  
  .user-info-authenticated {
    background: var(--color-bg-secondary);
    padding: 1rem;
    border: 1px solid var(--color-border);
  }
  
  .user-name-display {
    font-weight: 600;
    color: var(--color-text-primary);
    font-size: 0.9375rem;
  }
  
  .user-badges-container {
    display: flex;
    gap: 0.375rem;
    margin-top: 0.25rem;
  }
  
  .user-badge {
    padding: 0.125rem 0.5rem;
    font-size: 0.6875rem;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 0.025em;
    line-height: 1.2;
  }
  
  .user-badge.verified {
    background: #dbeafe;
    color: #1e40af;
    border: 1px solid #bfdbfe;
  }
  
  .user-badge.admin {
    background: #fef3c7;
    color: #d97706;
    border: 1px solid #fed7aa;
  }
  
  :global(.dark) .user-badge.verified {
    background: #1e3a8a;
    color: #bfdbfe;
    border-color: #3b82f6;
  }
  
  :global(.dark) .user-badge.admin {
    background: #92400e;
    color: #fbbf24;
    border-color: #f59e0b;
  }
  
  /* ===== COMMENT EDITOR ===== */
  .comment-editor-enhanced {
    background: var(--color-bg-primary);
    border: 1px solid var(--color-border);
    overflow: hidden;
  }
  
  .editor-toolbar {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 0.75rem;
    background: var(--color-bg-secondary);
    border-bottom: 1px solid var(--color-border);
  }
  
  .formatting-tools {
    display: flex;
    gap: 0.25rem;
    align-items: center;
  }
  
  .format-btn,
  .emoji-btn {
    display: flex;
    align-items: center;
    justify-content: center;
    width: 32px;
    height: 32px;
    background: var(--color-bg-primary);
    border: 1px solid var(--color-border);
    color: var(--color-text-secondary);
    cursor: pointer;
    transition: all 0.2s ease;
    font-size: 0.875rem;
  }
  
  .format-btn:hover,
  .emoji-btn:hover {
    background: var(--color-accent);
    border-color: var(--color-accent);
    color: white;
  }
  
  .format-btn:active {
    background: var(--color-accent);
    color: white;
    transform: scale(0.95);
  }
  
  .character-count {
    font-size: 0.75rem;
    color: var(--color-text-muted);
  }
  
  .character-count.warning {
    color: #f59e0b;
  }
  
  .character-count.error {
    color: #ef4444;
  }
  
  .comment-textarea-enhanced {
    width: 100%;
    min-height: 120px;
    padding: 1rem;
    border: none;
    font-size: 0.9375rem;
    line-height: 1.6;
    background: var(--color-bg-primary);
    color: var(--color-text-primary);
    resize: vertical;
    font-family: inherit;
  }
  
  .comment-textarea-enhanced:focus {
    outline: none;
  }
  
  .comment-textarea-enhanced::placeholder {
    color: var(--color-text-muted);
  }
  
  .form-footer {
    padding: 1rem;
    background: var(--color-bg-secondary);
    border-top: 1px solid var(--color-border);
    display: flex;
    justify-content: space-between;
    align-items: center;
    gap: 1rem;
  }
  
  .community-notice {
    font-size: 0.75rem;
    color: var(--color-text-muted);
    line-height: 1.4;
  }
  
  .community-notice a {
    color: var(--color-accent);
    text-decoration: underline;
  }
  
  .form-actions {
    display: flex;
    gap: 0.5rem;
  }
  
  .cancel-btn,
  .submit-btn {
    display: flex;
    align-items: center;
    justify-content: center;
    width: 40px;
    height: 40px;
    border: 1px solid var(--color-border);
    cursor: pointer;
    transition: all 0.2s ease;
  }
  
  .cancel-btn {
    background: var(--color-bg-primary);
    color: var(--color-text-secondary);
  }
  
  .cancel-btn:hover {
    background: var(--color-bg-secondary);
    color: var(--color-text-primary);
  }
  
  .submit-btn {
    background: var(--color-accent);
    color: white;
    border-color: var(--color-accent);
  }
  
  .submit-btn:hover {
    background: var(--color-accent-hover);
  }
  
  .submit-btn:disabled {
    opacity: 0.6;
    cursor: not-allowed;
  }
  
  /* ===== COMMENTS LIST ===== */
  .comments-list-enhanced {
    background: var(--color-bg-primary);
  }
  
  .comment-item-enhanced {
    padding: 1.5rem;
    border-bottom: 1px solid var(--color-border);
    background: var(--color-bg-primary);
    transition: background-color 0.2s ease;
  }
  
  .comment-item-enhanced:hover {
    background: var(--color-bg-secondary);
  }
  
  .comment-item-enhanced:last-child {
    border-bottom: none;
  }
  
  .comment-item-enhanced.flagged {
    border-left: 4px solid #f59e0b;
    background: rgba(245, 158, 11, 0.03);
  }
  
  .comment-item-enhanced.deleted {
    opacity: 0.6;
    background: rgba(239, 68, 68, 0.03);
  }
  
  .comment-header {
    display: flex;
    align-items: flex-start;
    gap: 0.75rem;
    margin-bottom: 1rem;
  }
  
  .comment-avatar {
    width: 48px;
    height: 48px;
    overflow: hidden;
    border: 2px solid var(--color-border);
    flex-shrink: 0;
  }
  
  .comment-avatar img {
    width: 100%;
    height: 100%;
    object-fit: cover;
  }
  
  .comment-avatar-initials {
    width: 100%;
    height: 100%;
    background: linear-gradient(135deg, var(--color-accent), #8b5cf6);
    color: white;
    font-weight: 700;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 0.875rem;
  }
  
  .comment-meta {
    flex: 1;
    min-width: 0;
    display: flex;
    flex-direction: column;
    justify-content: center;
  }
  
  .comment-author-info {
    display: flex;
    align-items: center;
    gap: 0.75rem;
    margin-bottom: 0.25rem;
    flex-wrap: wrap;
  }
  
  .comment-author {
    font-weight: 600;
    color: var(--color-text-primary);
    font-size: 0.9375rem;
    line-height: 1.2;
  }
  
  .comment-badges {
    display: flex;
    gap: 0.375rem;
    align-items: center;
    flex-wrap: wrap;
  }
  
  .comment-badge {
    padding: 0.125rem 0.5rem;
    font-size: 0.6875rem;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 0.025em;
    line-height: 1.2;
  }
  
  .comment-badge.verified {
    background: #dbeafe;
    color: #1e40af;
    border: 1px solid #bfdbfe;
  }
  
  .comment-badge.admin {
    background: #fef3c7;
    color: #d97706;
    border: 1px solid #fed7aa;
  }
  
  .comment-badge.guest {
    background: var(--color-bg-secondary);
    color: var(--color-text-muted);
    border: 1px solid var(--color-border);
  }
  
  .comment-date {
    font-size: 0.8125rem;
    color: var(--color-text-muted);
    line-height: 1.2;
  }
  
  .comment-content {
    margin-bottom: 1.25rem;
    line-height: 1.6;
    color: var(--color-text-primary);
    font-size: 0.9375rem;
    white-space: pre-wrap;
    word-wrap: break-word;
  }
  
  .comment-content strong {
    font-weight: 700;
    color: var(--color-text-primary);
  }
  
  .comment-content em {
    font-style: italic;
    color: var(--color-text-secondary);
  }
  
  .comment-content code {
    background: var(--color-bg-secondary);
    padding: 0.125rem 0.375rem;
    font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
    font-size: 0.875em;
    color: var(--color-text-primary);
  }
  
  .comment-content.deleted-content {
    font-style: italic;
    color: var(--color-text-muted);
  }
  
  /* ===== COMMENT ACTIONS (CRITICAL SECTION) ===== */
  .comment-actions {
    display: flex;
    align-items: center;
    gap: 0.75rem;
    flex-wrap: wrap;
    margin-top: 1rem;
    padding-top: 0.75rem;
    border-top: 1px solid var(--color-border);
  }
  
  .reaction-group {
    display: flex;
    align-items: center;
    gap: 0.5rem;
  }
  
  .reaction-btn {
    display: flex;
    align-items: center;
    gap: 0.375rem;
    padding: 0.375rem 0.75rem;
    background: var(--color-bg-secondary);
    border: 1px solid var(--color-border);
    font-size: 0.8125rem;
    cursor: pointer;
    transition: all 0.2s ease;
    color: var(--color-text-secondary);
    font-weight: 500;
  }
  
  .reaction-btn:hover {
    background: var(--color-bg-primary);
    border-color: var(--color-accent);
    color: var(--color-accent);
  }
  
  .reaction-btn.active {
    background: var(--color-accent);
    border-color: var(--color-accent);
    color: white;
  }
  
  .comment-action {
    display: inline-flex;
    align-items: center;
    gap: 0.375rem;
    padding: 0.5rem 0.75rem;
    background: var(--color-bg-secondary);
    border: 1px solid var(--color-border);
    color: var(--color-text-secondary);
    cursor: pointer;
    transition: all 0.2s ease;
    font-size: 0.875rem;
    font-weight: 500;
    text-decoration: none;
  }
  
  .comment-action:hover {
    background: var(--color-bg-primary);
    border-color: var(--color-accent);
    color: var(--color-accent);
  }
  
  :global(.dark) .comment-action:hover {
    background: rgba(255, 255, 255, 0.05);
  }
  
  .comment-action.danger:hover {
    background: rgba(239, 68, 68, 0.05);
    color: #ef4444;
    border-color: rgba(239, 68, 68, 0.1);
  }
  
  /* ===== NESTED REPLIES ===== */
  .replies-container {
    margin-top: 1.5rem;
    padding-left: 2rem;
    border-left: 3px solid var(--color-accent);
    background: var(--color-bg-secondary);
    padding: 1rem;
  }
  
  :global(.dark) .replies-container {
    background: rgba(255, 255, 255, 0.02);
    border-left-color: #444;
  }
  
  .replies-container .comment-item-enhanced {
    background: transparent;
    border-bottom: 1px solid rgba(0, 0, 0, 0.05);
    margin-bottom: 0;
    padding: 1rem 0;
  }
  
  :global(.dark) .replies-container .comment-item-enhanced {
    border-bottom-color: rgba(255, 255, 255, 0.05);
  }
  
  .replies-container .comment-item-enhanced:last-child {
    border-bottom: none;
  }
  
  .reply-toggle {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    font-size: 0.8125rem;
    color: var(--color-text-muted);
    background: var(--color-bg-secondary);
    border: 1px solid var(--color-border);
    padding: 0.5rem 0.75rem;
    cursor: pointer;
    margin-bottom: 1rem;
    transition: all 0.2s ease;
    font-weight: 500;
  }
  
  .reply-toggle:hover {
    color: var(--color-accent);
    border-color: var(--color-accent);
    background: var(--color-bg-primary);
  }
  
  /* ===== EMPTY STATE ===== */
  .empty-state {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    padding: 4rem 2rem;
    text-align: center;
    background: var(--color-bg-primary);
  }
  
  .empty-icon {
    color: var(--color-text-muted);
    margin-bottom: 1.5rem;
    opacity: 0.6;
  }
  
  .empty-state h4 {
    font-size: 1.25rem;
    font-weight: 700;
    color: var(--color-text-primary);
    margin-bottom: 0.75rem;
  }
  
  .empty-state p {
    color: var(--color-text-secondary);
    margin-bottom: 2rem;
    max-width: 400px;
    line-height: 1.6;
  }
  
  .start-discussion-btn {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    padding: 0.75rem 1.5rem;
    background: var(--color-accent);
    color: white;
    border: 1px solid var(--color-accent);
    font-weight: 600;
    cursor: pointer;
    transition: all 0.2s ease;
    font-size: 0.875rem;
  }
  
  .start-discussion-btn:hover {
    background: var(--color-accent-hover);
    border-color: var(--color-accent-hover);
  }
  
  /* ===== LOADING STATE ===== */
  .loading-state {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    padding: 3rem;
    color: var(--color-text-muted);
  }
  
  .loading-spinner {
    width: 32px;
    height: 32px;
    border: 3px solid var(--color-border);
    border-top: 3px solid var(--color-accent);
    animation: spin 1s linear infinite;
    margin-bottom: 1rem;
  }
  
  @keyframes spin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
  }
  
  /* ===== FOOTER ===== */
  .comments-footer {
    background: var(--color-bg-secondary);
    border-top: 1px solid var(--color-border);
    padding: 1.5rem;
  }
  
  :global(.dark) .comments-footer {
    background: #2a2a2a;
    border-color: #333;
  }
  
  .footer-links {
    display: flex;
    gap: 1rem;
    margin-bottom: 1.5rem;
  }
  
  .footer-links a {
    color: var(--color-text-secondary);
    text-decoration: none;
    font-size: 0.875rem;
    transition: color 0.2s ease;
  }
  
  .footer-links a:hover {
    color: var(--color-accent);
  }
  
  .recommended-section h4 {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    margin: 0;
    font-size: 1rem;
    font-weight: 700;
    color: var(--color-text-primary);
    text-transform: uppercase;
    letter-spacing: 0.05em;
  }
  
  /* ===== UTILITY CLASSES ===== */
  .format-btn[data-format="[link](url)"] {
    display: none !important;
  }
  
  .comment-content * {
    max-width: 100%;
  }
  
  .comment-content img {
    display: none;
  }
  
  .comment-content script {
    display: none;
  }

      /* Enhanced nested comment styling */
    .comment-item-enhanced {
      background: var(--color-bg-primary);
      border: 1px solid var(--color-border);
      margin-bottom: 1rem;
      padding: 1.25rem;
      position: relative;
    }

    .replies-container {
      margin-top: 1rem;
      padding-left: 2rem;
      border-left: 3px solid var(--color-accent);
      background: var(--color-bg-secondary);
      padding: 1rem 0;
      position: relative;
    }

    .replies-container::before {
      content: '';
      position: absolute;
      left: -3px;
      top: 0;
      bottom: 0;
      width: 3px;
      background: var(--color-accent);
      opacity: 0.3;
    }

    .replies-container .comment-item-enhanced {
      background: transparent;
      border: none;
      border-bottom: 1px solid rgba(0, 0, 0, 0.05);
      margin-bottom: 0;
      padding: 1rem 1rem 1rem 0;
    }

    .replies-container .comment-item-enhanced:last-child {
      border-bottom: none;
    }

    /* Deeper nesting for replies to replies */
    .replies-container .replies-container {
      padding-left: 1.5rem;
      border-left: 2px solid var(--color-accent);
      background: rgba(0, 0, 0, 0.01);
    }

    @media (max-width: 768px) {
      .replies-container {
        padding-left: 1rem;
        margin-left: 0.5rem;
      }
    }
  
  /* ===== RESPONSIVE DESIGN ===== */
  @media (max-width: 768px) {
    .tinkbyte-comments-enhanced {
      margin: 1rem 0;
    }
  
    .comments-header-enhanced {
      padding: 1rem;
    }
  
    .comments-stats {
      flex-direction: column;
      align-items: stretch;
      gap: 1rem;
    }
  
    .manage-btn {
      align-self: flex-start;
    }
  
    .comment-item-enhanced {
      padding: 1rem;
    }
  
    .comment-header {
      flex-direction: column;
      align-items: flex-start;
      gap: 0.5rem;
    }
  
    .comment-avatar,
    .user-avatar-display,
    .user-status-avatar {
      width: 36px;
      height: 36px;
    }
  
    .comment-actions {
      flex-direction: column;
      align-items: stretch;
      gap: 0.75rem;
    }
  
    .comment-action {
      justify-content: center;
      padding: 0.75rem;
    }
  
    .reaction-group {
      justify-content: flex-start;
    }
  
    .replies-container {
      padding-left: 1rem;
      margin-left: 0.5rem;
    }
  
    .comment-form-container {
      padding: 1rem;
    }
  
    .user-info-enhanced {
      flex-direction: column;
      gap: 0.75rem;
    }
  
    .form-footer {
      flex-direction: column;
      gap: 1rem;
      align-items: stretch;
    }
  
    .form-actions {
      align-self: flex-end;
    }
  
    .comment-author-info {
      width: 100%;
    }
  }
  
  @media (max-width: 480px) {
    .comment-item-enhanced {
      padding: 0.75rem;
    }
  
    .comments-header-enhanced {
      padding: 0.75rem;
    }
  
    .comment-form-container {
      padding: 0.75rem;
    }
  
    .formatting-tools {
      gap: 0.125rem;
    }
  
    .format-btn,
    .emoji-btn {
      width: 28px;
      height: 28px;
    }
  
    .footer-links {
      flex-wrap: wrap;
      gap: 0.75rem;
    }
  }
</style>



<script>
  // Import Supabase
  import { supabase } from "../../lib/supabase.js";

  // XDA-Style TinkByte Comments Enhanced
  class TinkByteCommentsEnhanced {
    private container: HTMLElement | null;
    private postSlug: string;
    private postTitle: string;
    private storageKey: string;
    private draftKey: string;
    private comments: any[];
    private currentUser: any | null;
    private isSubmitting: boolean;
    private replyingTo: string | null;
    private isAdmin: boolean;

    constructor() {
      this.container = document.querySelector(".tinkbyte-comments-enhanced");
      if (!this.container) return;

      this.postSlug = this.container.dataset.postSlug || "";
      this.postTitle = this.container.dataset.postTitle || "";
      this.storageKey = `tinkbyte-comments-${this.postSlug}`;
      this.draftKey = `tinkbyte-draft-${this.postSlug}`;

      this.comments = [];
      this.currentUser = null;
      this.isSubmitting = false;
      this.replyingTo = null;
      this.isAdmin = false;

      this.init();
    }

    async init(): Promise<void> {
      console.log("=== COMMENTS COMPONENT INIT ===");
      console.log("Post Slug:", this.postSlug);
      console.log("Post Title:", this.postTitle);

      if (!this.postSlug || this.postSlug === "no-slug") {
        console.error("Invalid post slug provided");
        this.showArticleNotFoundError();
        return;
      }

      await this.checkAuth();
      this.setupEventListeners();
      await this.loadComments();
      this.loadDraft();
      this.renderUserStatus();
    }

    showArticleNotFoundError(): void {
      if (!this.container) return;

      const commentsContainer = this.container.querySelector(
        ".comments-list-enhanced"
      );
      if (commentsContainer) {
        commentsContainer.innerHTML = `
          <div style="padding: 2rem; text-align: center; background: #fef2f2; border: 1px solid #fecaca; border-radius: 8px;">
            <h3 style="color: #dc2626; margin-bottom: 1rem;">Configuration Error</h3>
            <p style="color: #7f1d1d; margin-bottom: 1rem;">
              No article slug provided to comments component.
            </p>
            <p style="font-size: 0.875rem; color: #991b1b;">
              Slug: "${this.postSlug}"
            </p>
          </div>
        `;
      }
    }

    async checkAuth(): Promise<void> {
      try {
        const {
          data: { user },
          error,
        } = await supabase.auth.getUser();

        if (user && !error) {
          const { data: profile } = await supabase
            .from("profiles")
            .select("*")
            .eq("id", user.id)
            .maybeSingle();

          this.currentUser = {
            id: user.id,
            email: user.email || "",
            name:
              profile?.display_name ||
              user.user_metadata?.full_name ||
              user.email?.split("@")[0] ||
              "Anonymous",
            avatar: profile?.avatar_url || null,
            avatarType: profile?.avatar_type || "preset",
            avatarPresetId: profile?.avatar_preset_id || 1,
            isVerified: profile?.email_verified || false,
            isAdmin: user.user_metadata?.role === "admin" || false,
          };

          this.isAdmin = this.currentUser.isAdmin;
        }
      } catch (error) {
        console.error("Auth check failed:", error);
      }
    }

    async loadComments(): Promise<void> {
      try {
        console.log("Loading comments for slug:", this.postSlug);

        // Show loading state
        const commentsContainer = this.container?.querySelector(
          ".comments-list-enhanced"
        );
        if (commentsContainer) {
          commentsContainer.innerHTML = `
            <div class="loading-state">
              <div class="loading-spinner"></div>
              <p>Loading comments...</p>
            </div>
          `;
        }

        const supabaseComments = await this.loadFromSupabase();

        if (supabaseComments && supabaseComments.length > 0) {
          console.log(
            `Loaded ${supabaseComments.length} comments from Supabase`
          );
          this.comments = supabaseComments;
        } else {
          console.log("No comments found in Supabase, checking localStorage");
          const localComments = localStorage.getItem(this.storageKey);
          this.comments = localComments ? JSON.parse(localComments) : [];
          console.log(
            `Loaded ${this.comments.length} comments from localStorage`
          );
        }

        this.renderComments();
        this.updateStats();
      } catch (error: any) {
        console.error("Error loading comments:", error);
        this.showCommentsError(error.message);
      }
    }

    buildCommentHierarchy(flatComments: any[]): any[] {
  const commentMap = new Map();
  const rootComments: any[] = [];

  // First pass: Transform and map all comments
  const transformedComments = flatComments.map((comment) => ({
    id: comment.id,
    author: this.getAuthorName(comment),
    email: comment.guest_email || "",
    content: comment.content,
    date: comment.created_at,
    reactions: {},
    userReaction: null,
    replies: [],
    userId: comment.user_id,
    userAvatar: this.getProfileAvatar(comment.user_profile),
    isVerified: !!comment.user_id,
    isAdmin: comment.user_profile?.is_admin || false,
    isGuest: !comment.user_id,
    flagged: comment.is_flagged || false,
    deleted: comment.is_deleted,
    parentId: comment.parent_id, // Critical for hierarchy
  }));

  // Create lookup map
  transformedComments.forEach(comment => {
    commentMap.set(comment.id, comment);
  });

  // Second pass: Build hierarchy
  transformedComments.forEach(comment => {
    if (comment.parentId) {
      // This is a reply
      const parent = commentMap.get(comment.parentId);
      if (parent) {
        parent.replies.push(comment);
      } else {
        // Orphaned reply, treat as root
        rootComments.push(comment);
      }
    } else {
      // Root comment
      rootComments.push(comment);
    }
  });

  // Sort replies within each comment (oldest first for natural flow)
  const sortReplies = (comment: any) => {
    if (comment.replies?.length > 0) {
      comment.replies.sort((a, b) => new Date(a.date).getTime() - new Date(b.date).getTime());
      comment.replies.forEach(sortReplies);
    }
  };

  // Sort root comments (newest first)
  rootComments.sort((a, b) => new Date(b.date).getTime() - new Date(a.date).getTime());
  rootComments.forEach(sortReplies);

  return rootComments;
}

    showCommentsError(message: string): void {
      if (!this.container) return;

      const commentsContainer = this.container.querySelector(
        ".comments-list-enhanced"
      );
      if (commentsContainer) {
        commentsContainer.innerHTML = `
          <div style="padding: 2rem; text-align: center; background: #fef2f2; border: 1px solid #fecaca; border-radius: 8px;">
            <h3 style="color: #dc2626; margin-bottom: 1rem;">Failed to Load Comments</h3>
            <p style="color: #7f1d1d; margin-bottom: 1rem;">${message}</p>
            <button onclick="window.location.reload()" 
                    style="background: #dc2626; color: white; padding: 0.5rem 1rem; border: none; border-radius: 4px; cursor: pointer;">
              Retry
            </button>
          </div>
        `;
      }
    }

    async loadFromSupabase(): Promise<any[] | null> {
      try {
        console.log("Loading comments for article:", this.postSlug);

        // First verify the article exists
        const { data: article, error: articleError } = await supabase
          .from("articles")
          .select("slug, title")
          .eq("slug", this.postSlug)
          .single();

        if (articleError || !article) {
          console.error("Article not found:", this.postSlug, articleError);
          return null;
        }

        console.log("Article found:", article);

        // Load comments without profile join first (simpler approach)
        const { data, error } = await supabase
          .from("comments")
          .select("*")
          .eq("article_id", this.postSlug)
          .eq("is_deleted", false)
          .order("created_at", { ascending: true });

        if (error) {
          console.error("Comments query failed:", error);
          throw error;
        }

        console.log(`Loaded ${data?.length || 0} comments`);

        // For each comment with user_id, fetch profile separately
        const commentsWithProfiles = await Promise.all(
          (data || []).map(async (comment) => {
            let profile: any = null;

            if (comment.user_id) {
              try {
                const { data: profileData, error: profileError } =
                  await supabase
                    .from("profiles")
                    .select(
                      "display_name, first_name, last_name, avatar_url, avatar_type, avatar_preset_id"
                    )
                    .eq("id", comment.user_id)
                    .maybeSingle();

                if (!profileError && profileData) {
                  profile = profileData;
                }
              } catch (profileError) {
                console.warn(
                  `Profile not found for user ${comment.user_id}:`,
                  profileError
                );
              }
            }

            return {
              ...comment,
              user_profile: profile,
            };
          })
        );

        return this.transformComments(commentsWithProfiles);
      } catch (error) {
        console.error("Supabase load error:", error);
        return null;
      }
    }

    transformComments(comments: any[]): any[] {
      return comments.map((comment) => ({
        id: comment.id,
        author: this.getAuthorName(comment),
        email: comment.guest_email || "",
        content: comment.content,
        date: comment.created_at,
        reactions: {},
        userReaction: null,
        replies: [],
        userId: comment.user_id,
        userAvatar: this.getProfileAvatar(comment.user_profile),
        isVerified: !!comment.user_id,
        isAdmin: false,
        isGuest: !comment.user_id,
        flagged: false,
        deleted: comment.is_deleted,
      }));
    }

    getAuthorName(comment: any): string {
      if (comment.guest_name) {
        return comment.guest_name;
      }

      if (comment.user_profile && comment.user_profile.display_name) {
        return comment.user_profile.display_name;
      }

      if (
        comment.user_profile &&
        (comment.user_profile.first_name || comment.user_profile.last_name)
      ) {
        return `${comment.user_profile.first_name || ""} ${comment.user_profile.last_name || ""}`.trim();
      }

      return "Anonymous User";
    }

    getProfileAvatar(profile: any): string | null {
      if (!profile) return null;

      if (profile.avatar_type === "uploaded" && profile.avatar_url) {
        return profile.avatar_url;
      }

      return `/images/avatars/preset-${profile.avatar_preset_id || 1}.svg`;
    }

    getUserInitials(name: string): string {
      if (!name) return "U";
      const words = name.trim().split(" ");
      if (words.length === 1) {
        return words[0].charAt(0).toUpperCase();
      }
      return (
        words[0].charAt(0) + words[words.length - 1].charAt(0)
      ).toUpperCase();
    }

    async handleSignOut(): Promise<void> {
      try {
        await supabase.auth.signOut();
        window.location.reload();
      } catch (error) {
        console.error("Sign out failed:", error);
      }
    }

    renderUserStatus(): void {
      const statusBar = this.container?.querySelector(
        "#user-status-bar"
      ) as HTMLElement;
      if (!statusBar) return;

      if (this.currentUser) {
        const initials = this.getUserInitials(this.currentUser.name);
        const avatarHtml = this.currentUser.avatar
          ? `<img src="${this.currentUser.avatar}" alt="${this.currentUser.name}" style="width: 100%; height: 100%; object-fit: cover;">`
          : initials;

        statusBar.innerHTML = `
          <div class="user-status-info">
            <div class="user-status-avatar">
              ${avatarHtml}
            </div>
            <div class="user-status-text">
              <div class="user-status-main">
                Signed in as <strong>${this.currentUser.name}</strong>
                <div class="user-status-badges">
                  ${this.currentUser.isVerified ? '<span class="user-badge verified">Verified</span>' : ""}
                  ${this.isAdmin ? '<span class="user-badge admin">Admin</span>' : ""}
                </div>
              </div>
            </div>
          </div>
          <div class="user-status-actions">
            ${this.isAdmin ? '<button class="status-btn" id="moderation-btn">Moderate</button>' : ""}
            <a href="/profile" class="status-btn">Profile</a>
            <button class="status-btn" id="signout-btn">Sign Out</button>
          </div>
        `;

        // Setup event listeners for status bar
        const signoutBtn = statusBar.querySelector("#signout-btn");
        if (signoutBtn) {
          signoutBtn.addEventListener("click", () => this.handleSignOut());
        }
      } else {
        statusBar.innerHTML = `
          <div class="user-status-info">
            <div class="user-status-avatar user-status-avatar-guest">
              <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor">
                <path d="M20 21v-2a4 4 0 0 0-4-4H8a4 4 0 0 0-4 4v2"/>
                <circle cx="12" cy="7" r="4"/>
              </svg>
            </div>
            <div class="user-status-text">
              <div class="user-status-main">
                Commenting as <strong>guest</strong>
              </div>
            </div>
          </div>
          <div class="user-status-actions">
            <a href="/auth/signin" class="status-btn primary">Sign In</a>
            <a href="/auth/signup" class="status-btn">Sign Up</a>
          </div>
        `;
      }
    }

    setupEventListeners(): void {
      if (!this.container) return;

      // Header manage button
      const manageBtn = this.container.querySelector(".manage-btn");
      if (manageBtn) {
        manageBtn.addEventListener("click", () => this.showCommentForm());
      }

      // Start discussion button
      const startDiscussionBtn = this.container.querySelector(
        ".start-discussion-btn"
      );
      if (startDiscussionBtn) {
        startDiscussionBtn.addEventListener("click", () =>
          this.showCommentForm()
        );
      }

      // Form buttons
      const cancelBtn = this.container.querySelector(".cancel-btn");
      const form = this.container.querySelector(".comment-form-enhanced");
      const cancelReplyBtn = this.container.querySelector("#cancel-reply");

      if (cancelBtn) {
        cancelBtn.addEventListener("click", () => this.hideCommentForm());
      }

      if (cancelReplyBtn) {
        cancelReplyBtn.addEventListener("click", () =>
          this.clearReplyContext()
        );
      }

      if (form) {
        form.addEventListener("submit", (e) => this.handleSubmit(e));
      }

      // Format buttons
      const formatBtns = this.container.querySelectorAll('.format-btn');
      formatBtns.forEach((btn) => {
        btn.addEventListener('click', (e) => {
          e.preventDefault();
          const format = (btn as HTMLElement).dataset.format;
          if (format) this.insertFormat(format);
        });
      });

      // Emoji button
      const emojiBtn = this.container.querySelector(".emoji-btn");
      if (emojiBtn) {
        emojiBtn.addEventListener("click", (e) => {
          e.preventDefault();
          this.toggleEmojiPicker();
        });
      }

      // Auto-save draft and character count
      const textarea = this.container.querySelector(
        ".comment-textarea-enhanced"
      ) as HTMLTextAreaElement;
      if (textarea) {
        textarea.addEventListener("input", () => {
          this.saveDraft();
          this.updateCharacterCount();
        });
      }
    }

    async handleSubmit(e: Event): Promise<void> {
      e.preventDefault();

      if (this.isSubmitting || !this.container) return;

      const contentInput = this.container.querySelector(
        ".comment-textarea-enhanced"
      ) as HTMLTextAreaElement;

      const content = contentInput?.value.trim();

      if (!content) {
        this.showError("Please enter a comment.");
        return;
      }

      // Content validation
      const validation = this.validateContent(content);
      if (!validation.isValid) {
        this.showError(validation.message);
        return;
      }

      let authorName: string, authorEmail: string;
      let commentData: any;

      if (this.currentUser) {
        // Authenticated user
        authorName = this.currentUser.name;
        authorEmail = this.currentUser.email;

        commentData = {
          article_id: this.postSlug,
          user_id: this.currentUser.id,
          parent_id: this.replyingTo || null,
          content: content,
          guest_name: null,
          guest_email: null,
          is_edited: false,
          is_deleted: false,
        };
      } else {
        // Guest user
        const nameInput = this.container.querySelector(
          ".user-name"
        ) as HTMLInputElement;
        const emailInput = this.container.querySelector(
          ".user-email"
        ) as HTMLInputElement;

        authorName = nameInput?.value.trim() || "";
        authorEmail = emailInput?.value.trim() || "";

        if (!authorName) {
          this.showError("Please enter your name.");
          return;
        }

        commentData = {
          article_id: this.postSlug,
          user_id: null,
          parent_id: this.replyingTo || null,
          content: content,
          guest_name: authorName,
          guest_email: authorEmail || null,
          is_edited: false,
          is_deleted: false,
        };
      }

      this.isSubmitting = true;
      this.updateSubmitButton(true);

      try {
        console.log("Comment data being sent:", commentData);

        // First verify the article exists
        const { data: article, error: articleError } = await supabase
          .from("articles")
          .select("slug, title")
          .eq("slug", this.postSlug)
          .single();

        if (articleError) {
          console.error("Article verification failed:", articleError);
          throw new Error("Article not found. Please refresh the page.");
        }

        console.log("Article verified:", article);

        // Save comment to database (simple insertion without joins)
        const { data: savedComment, error: commentError } = await supabase
          .from("comments")
          .insert(commentData)
          .select("*")
          .single();

        if (commentError) {
          console.error("Comment insertion failed:", commentError);

          if (commentError.code === "23503") {
            throw new Error(
              "Article reference error. Please refresh the page."
            );
          } else if (
            commentError.code === "42501" ||
            commentError.message.includes("policy")
          ) {
            throw new Error(
              "Permission denied. Please check your authentication status."
            );
          } else {
            throw new Error(`Failed to save comment: ${commentError.message}`);
          }
        }

        if (!savedComment) {
          throw new Error("Comment was not saved properly.");
        }

        console.log("Comment saved successfully:", savedComment);

        // Load profile separately if needed
        let userProfile: any = null;
        if (savedComment.user_id) {
          try {
            const { data: profileData } = await supabase
              .from("profiles")
              .select(
                "display_name, first_name, last_name, avatar_url, avatar_type, avatar_preset_id"
              )
              .eq("id", savedComment.user_id)
              .maybeSingle();

            if (profileData) {
              userProfile = profileData;
            }
          } catch (profileError) {
            console.warn("Profile not found for user:", savedComment.user_id);
          }
        }

        // Create local comment object for immediate UI update
        const newComment = {
        id: savedComment.id.toString(),
        author: userProfile?.display_name || authorName,
        email: authorEmail,
        content: content,
        date: savedComment.created_at,
        reactions: {},
        userReaction: null,
        replies: [],
        userId: savedComment.user_id,
        userAvatar: this.getProfileAvatar(userProfile),
        isVerified: !!savedComment.user_id,
        isAdmin: this.isAdmin,
        isGuest: !savedComment.user_id,
        flagged: false,
        deleted: false,
        parentId: this.replyingTo,
        };

        // Add to comments array and update UI
        if (this.replyingTo) {
        // Add reply to correct parent
        const addReplyToParent = (comments: any[]): any[] => {
          return comments.map(comment => {
            if (comment.id === this.replyingTo) {
              return {
                ...comment,
                replies: [...(comment.replies || []), newComment]
              };
            }
            if (comment.replies?.length > 0) {
              return {
                ...comment,
                replies: addReplyToParent(comment.replies)
              };
            }
            return comment;
          });
        };

        this.comments = addReplyToParent(this.comments);
        this.clearReplyContext();
        } else {
          this.comments.unshift(newComment);
        }

        await this.saveComments();
        this.renderComments();
        this.updateStats();
        this.clearForm();
        this.hideCommentForm();
        this.clearDraft();
        this.showSuccess("Comment posted successfully!");
      } catch (error: any) {
        console.error("Error posting comment:", error);
        this.showError(
          error.message || "Failed to post comment. Please try again."
        );
      } finally {
        this.isSubmitting = false;
        this.updateSubmitButton(false);
      }
    }

    validateContent(content: string): { isValid: boolean; message: string } {
      // Check for URLs (no links allowed)
      const urlRegex = /https?:\/\/[^\s]+/gi;
      if (urlRegex.test(content)) {
        return {
          isValid: false,
          message: "Links are not allowed in comments.",
        };
      }

      // Basic profanity filter
      const inappropriateWords = ["spam", "scam", "buy now", "click here"];
      const hasInappropriateContent = inappropriateWords.some((word) =>
        content.toLowerCase().includes(word.toLowerCase())
      );

      if (hasInappropriateContent) {
        return {
          isValid: false,
          message: "Your comment contains inappropriate language.",
        };
      }

      // Check for spam patterns
      const spamPatterns = [
        /(.)\\1{10,}/gi, // Repeated characters
        /[A-Z]{20,}/g, // Excessive caps
      ];

      const hasSpamPattern = spamPatterns.some((pattern) =>
        pattern.test(content)
      );

      if (hasSpamPattern) {
        return {
          isValid: false,
          message: "Your comment appears to be spam.",
        };
      }

      return { isValid: true, message: "" };
    }

    renderComments(): void {
      if (!this.container) return;

      const commentsList = this.container.querySelector(
        ".comments-list-enhanced"
      ) as HTMLElement;
      const emptyState = this.container.querySelector(
        ".empty-state"
      ) as HTMLElement;
      const loadingState = this.container.querySelector(
        ".loading-state"
      ) as HTMLElement;

      if (loadingState) loadingState.style.display = "none";

      if (this.comments.length === 0) {
        if (commentsList) commentsList.style.display = "none";
        if (emptyState) emptyState.style.display = "flex";
        return;
      }

      if (emptyState) emptyState.style.display = "none";
      if (commentsList) {
        commentsList.style.display = "block";
        commentsList.innerHTML = this.comments
          .map((comment) => this.renderComment(comment))
          .join("");
        this.setupCommentHandlers();
      }
    }

      renderComment(comment: any, depth: number = 0): string {
      if (comment.deleted && !this.isAdmin) {
        return `
          <div class="comment-item-enhanced deleted" data-comment-id="${comment.id}">
            <div class="comment-content deleted-content">
              <em>This comment has been deleted.</em>
            </div>
          </div>
        `;
      }

    const avatarSrc = comment.userAvatar;
    const initials = this.getUserInitials(comment.author);
    const avatarHtml = avatarSrc 
      ? `<img src="${avatarSrc}" alt="${comment.author}" style="width: 100%; height: 100%; object-fit: cover;">`
      : `<div class="comment-avatar-initials">${initials}</div>`;

    const date = new Date(comment.date).toLocaleDateString('en-US', {
      year: 'numeric', month: 'short', day: 'numeric',
      hour: '2-digit', minute: '2-digit'
    });

    const content = this.parseMarkdown(comment.content);

    const badges: string[] = [];
    if (comment.isVerified) badges.push('<span class="comment-badge verified">Verified</span>');
    if (comment.isAdmin) badges.push('<span class="comment-badge admin">Admin</span>');
    if (comment.isGuest) badges.push('<span class="comment-badge guest">Guest</span>');

    const adminActions = this.isAdmin ? `
      <button class="comment-action danger" data-action="flag" data-comment-id="${comment.id}">
        ${comment.flagged ? 'Unflag' : 'Flag'}
      </button>
      <button class="comment-action danger" data-action="delete" data-comment-id="${comment.id}">
        Delete
      </button>
    ` : '';

    // CRITICAL: Proper nested replies rendering
    const repliesHtml = comment.replies?.length > 0 ? `
      <div class="replies-container">
        ${comment.replies.map((reply: any) => this.renderComment(reply, depth + 1)).join('')}
      </div>
    ` : '';

    return `
      <div class="comment-item-enhanced ${comment.flagged ? 'flagged' : ''}" data-comment-id="${comment.id}">
        <div class="comment-header">
          <div class="comment-avatar">${avatarHtml}</div>
          <div class="comment-meta">
            <div class="comment-author-info">
              <span class="comment-author">${comment.author}</span>
              <div class="comment-badges">${badges.join('')}</div>
            </div>
            <div class="comment-date">${date}</div>
          </div>
        </div>
        <div class="comment-content">${content}</div>
        <div class="comment-actions">
          <div class="reaction-group">
            <button class="comment-action add-reaction-btn" data-comment-id="${comment.id}">
              <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor">
                <circle cx="12" cy="12" r="10"/>
                <path d="M8 14s1.5 2 4 2 4-2 4-2"/>
                <line x1="9" y1="9" x2="9.01" y2="9"/>
                <line x1="15" y1="9" x2="15.01" y2="9"/>
              </svg>
              React
            </button>
          </div>
          <button class="comment-action reply-btn" data-comment-id="${comment.id}">
            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor">
              <polyline points="9,17 4,12 9,7"/>
              <path d="M20 18v-2a4 4 0 0 0-4-4H4"/>
            </svg>
            Reply
          </button>
          ${adminActions}
        </div>
        ${repliesHtml}
      </div>
    `;
  }

    parseMarkdown(text: string): string {
      let result = text;

      // Apply markdown formatting FIRST
      result = result.replace(/\*\*([^\*]+?)\*\*/g, '<strong>$1</strong>');
      result = result.replace(/\b_([^_]+?)_\b/g, '<em>$1</em>');
      result = result.replace(/`([^`]+?)`/g, '<code>$1</code>');
      result = result.replace(/\n/g, '<br>');

      // Basic sanitization AFTER markdown conversion
      result = result.replace(/<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi, '');
      result = result.replace(/<img\b[^>]*>/gi, '');
      result = result.replace(/(onload|onerror|onclick)=["']?[^"'>]*["']?/gi, '');

      return result;
    }

    showCommentForm(): void {
      if (!this.container) return;

      const formContainer = this.container.querySelector(
        ".comment-form-container"
      ) as HTMLElement;
      if (formContainer) {
        formContainer.style.display = "block";
        this.renderUserInputs();
        const textarea = this.container.querySelector(
          ".comment-textarea-enhanced"
        ) as HTMLTextAreaElement;
        if (textarea) textarea.focus();
      }
    }

    hideCommentForm(): void {
      if (!this.container) return;

      const formContainer = this.container.querySelector(
        ".comment-form-container"
      ) as HTMLElement;
      if (formContainer) {
        formContainer.style.display = "none";
      }
      this.clearReplyContext();
    }

    renderUserInputs(): void {
      if (!this.container) return;

      const userInputs = this.container.querySelector(
        "#user-inputs"
      ) as HTMLElement;
      const avatarDisplay = this.container.querySelector(
        "#user-avatar-display"
      ) as HTMLElement;

      if (!userInputs || !avatarDisplay) return;

      if (this.currentUser) {
        const initials = this.getUserInitials(this.currentUser.name);

        if (this.currentUser.avatar) {
          avatarDisplay.innerHTML = `<img src="${this.currentUser.avatar}" alt="${this.currentUser.name}" style="width: 100%; height: 100%; object-fit: cover;">`;
        } else {
          avatarDisplay.innerHTML = initials;
        }

        avatarDisplay.className = "user-avatar-display authenticated";

        userInputs.innerHTML = `
          <div class="user-info-authenticated">
            <div class="authenticated-user">
              <div class="user-details">
                <div class="user-name-display">${this.currentUser.name}</div>
                <div class="user-badges-container">
                  ${this.currentUser.isVerified ? '<span class="user-badge verified">Verified</span>' : ""}
                  ${this.isAdmin ? '<span class="user-badge admin">Admin</span>' : ""}
                </div>
              </div>
            </div>
          </div>
        `;
      } else {
        avatarDisplay.innerHTML = `
          <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor">
            <path d="M20 21v-2a4 4 0 0 0-4-4H8a4 4 0 0 0-4 4v2"/>
            <circle cx="12" cy="7" r="4"/>
          </svg>
        `;
        avatarDisplay.className = "user-avatar-display guest";

        userInputs.innerHTML = `
          <div class="guest-user-inputs">
            <input type="text" placeholder="Your name *" class="user-name" required>
            <input type="email" placeholder="Email (optional)" class="user-email">
          </div>
        `;
      }
    }

    setupCommentHandlers(): void {
      if (!this.container) return;

      // Reply buttons
      const replyBtns = this.container.querySelectorAll(".reply-btn");
      replyBtns.forEach((btn) => {
        btn.addEventListener("click", (e) => {
          const commentId = (btn as HTMLElement).dataset.commentId;
          if (commentId) this.handleReply(commentId);
        });
      });

      // Admin action buttons
      if (this.isAdmin) {
        const actionBtns = this.container.querySelectorAll("[data-action]");
        actionBtns.forEach((btn) => {
          btn.addEventListener("click", (e) => {
            const action = (btn as HTMLElement).dataset.action;
            const commentId = (btn as HTMLElement).dataset.commentId;
            if (action && commentId) this.handleAdminAction(action, commentId);
          });
        });
      }

      // Improved reply toggles
      const replyToggles = this.container.querySelectorAll('.reply-toggle');
      replyToggles.forEach((btn) => {
        btn.addEventListener('click', (e) => {
          e.preventDefault();
          const repliesContainer = btn.closest('.replies-container');
          const repliesList = repliesContainer?.querySelector('.replies-list') as HTMLElement;
          const icon = btn.querySelector('svg');
          
          if (repliesList && icon) {
            const isVisible = repliesList.style.display !== 'none';
            repliesList.style.display = isVisible ? 'none' : 'block';
            
            // Rotate icon
            icon.style.transform = isVisible ? 'rotate(-90deg)' : 'rotate(0deg)';
            icon.style.transition = 'transform 0.2s ease';
            
            // Update button text
            const currentText = btn.textContent?.trim() || '';
            const replyCount = currentText.match(/\d+/)?.[0] || '0';
            const replyWord = replyCount === '1' ? 'reply' : 'replies';
            
            btn.innerHTML = `
              <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" style="transform: ${isVisible ? 'rotate(-90deg)' : 'rotate(0deg)'}; transition: transform 0.2s ease;">
                <polyline points="6,9 12,15 18,9"/>
              </svg>
              ${isVisible ? 'Show' : 'Hide'} ${replyCount} ${replyWord}
            `;
          }
        });
      });
    }

    handleReply(commentId: string): void {
      const comment = this.findComment(commentId);
      if (!comment) return;

      this.replyingTo = commentId;
      this.showCommentForm();

      if (!this.container) return;

      const replyContext = this.container.querySelector(
        "#reply-context"
      ) as HTMLElement;
      const replyAuthor = this.container.querySelector(
        "#reply-author"
      ) as HTMLElement;
      const replyPreview = this.container.querySelector(
        "#reply-preview"
      ) as HTMLElement;

      if (replyContext && replyAuthor && replyPreview) {
        replyContext.style.display = "block";
        replyAuthor.textContent = comment.author;
        replyPreview.innerHTML = this.parseMarkdown(
          comment.content.substring(0, 100) +
            (comment.content.length > 100 ? "..." : "")
        );
      }

      const formContainer = this.container.querySelector(
        ".comment-form-container"
      ) as HTMLElement;
      if (formContainer) {
        formContainer.scrollIntoView({ behavior: "smooth", block: "center" });
      }
    }

    clearReplyContext(): void {
      this.replyingTo = null;
      if (!this.container) return;

      const replyContext = this.container.querySelector(
        "#reply-context"
      ) as HTMLElement;
      if (replyContext) replyContext.style.display = "none";
    }

    findComment(commentId: string): any | null {
      let found: any = null;
      this.traverseComments(this.comments, (comment) => {
        if (comment.id === commentId) {
          found = comment;
        }
        return comment;
      });
      return found;
    }

    traverseComments(comments: any[], callback: (comment: any) => any): any[] {
      return comments.map((comment) => {
        const processedComment = callback(comment);
        if (processedComment.replies?.length > 0) {
          return {
            ...processedComment,
            replies: this.traverseComments(processedComment.replies, callback),
          };
        }
        return processedComment;
      });
    }

    handleAdminAction(action: string, commentId: string): void {
      switch (action) {
        case "flag":
          this.toggleFlag(commentId);
          break;
        case "delete":
          this.deleteComment(commentId);
          break;
      }
    }

    toggleFlag(commentId: string): void {
      this.comments = this.traverseComments(this.comments, (comment) => {
        if (comment.id === commentId) {
          return { ...comment, flagged: !comment.flagged };
        }
        return comment;
      });

      this.saveComments();
      this.renderComments();
      this.showSuccess(
        `Comment ${this.comments.find((c) => c.id === commentId)?.flagged ? "flagged" : "unflagged"}`
      );
    }

    deleteComment(commentId: string): void {
      if (!confirm("Are you sure you want to delete this comment?")) return;

      this.comments = this.traverseComments(this.comments, (comment) => {
        if (comment.id === commentId) {
          return {
            ...comment,
            deleted: true,
            content: "[Deleted by moderator]",
          };
        }
        return comment;
      });

      this.saveComments();
      this.renderComments();
      this.showSuccess("Comment deleted");
    }

    updateCharacterCount(): void {
      if (!this.container) return;

      const textarea = this.container.querySelector(
        ".comment-textarea-enhanced"
      ) as HTMLTextAreaElement;
      const counter = this.container.querySelector(
        "#character-count"
      ) as HTMLElement;

      if (textarea && counter) {
        const length = textarea.value.length;
        const maxLength = 1000;

        counter.textContent = `${length}/${maxLength}`;

        counter.classList.remove("warning", "error");
        if (length > maxLength * 0.8) {
          counter.classList.add("warning");
        }
        if (length >= maxLength) {
          counter.classList.add("error");
        }
      }
    }

    updateSubmitButton(isSubmitting: boolean): void {
      if (!this.container) return;

      const submitBtn = this.container.querySelector(
        ".submit-btn"
      ) as HTMLButtonElement;
      if (submitBtn) {
        submitBtn.disabled = isSubmitting;
        submitBtn.innerHTML = isSubmitting
          ? `
          <svg class="animate-spin" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor">
            <line x1="12" y1="2" x2="12" y2="6"/>
            <line x1="12" y1="18" x2="12" y2="22"/>
            <line x1="4.93" y1="4.93" x2="7.76" y2="7.76"/>
            <line x1="16.24" y1="16.24" x2="19.07" y2="19.07"/>
            <line x1="2" y1="12" x2="6" y2="12"/>
            <line x1="18" y1="12" x2="22" y2="12"/>
            <line x1="4.93" y1="19.07" x2="7.76" y2="16.24"/>
            <line x1="16.24" y1="7.76" x2="19.07" y2="4.93"/>
          </svg>
        `
          : `
          <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor">
            <line x1="22" y1="2" x2="11" y2="13"/>
            <polygon points="22,2 15,22 11,13 2,9 22,2"/>
          </svg>
        `;
      }
    }

    updateStats(): void {
      if (!this.container) return;

      const commentCount = this.container.querySelector(
        ".comment-count"
      ) as HTMLElement;
      if (commentCount) {
        const totalComments = this.getTotalCommentCount();
        commentCount.textContent = totalComments.toString();
      }
    }

    getTotalCommentCount(): number {
      let count = 0;
      const countComments = (comments: any[]) => {
        comments.forEach((comment) => {
          if (!comment.deleted) count++;
          if (comment.replies) countComments(comment.replies);
        });
      };
      countComments(this.comments);
      return count;
    }

    async saveComments(): Promise<void> {
      localStorage.setItem(this.storageKey, JSON.stringify(this.comments));
    }

    saveDraft(): void {
      if (!this.container) return;

      const contentInput = this.container.querySelector(
        ".comment-textarea-enhanced"
      ) as HTMLTextAreaElement;
      if (contentInput && contentInput.value.trim()) {
        localStorage.setItem(this.draftKey, contentInput.value);
      }
    }

    async loadDraft(): Promise<void> {
      if (!this.container) return;

      const savedDraft = localStorage.getItem(this.draftKey);
      if (savedDraft) {
        const contentInput = this.container.querySelector(
          ".comment-textarea-enhanced"
        ) as HTMLTextAreaElement;
        if (contentInput) {
          contentInput.value = savedDraft;
          this.updateCharacterCount();
        }
      }
    }

    async clearDraft(): Promise<void> {
      localStorage.removeItem(this.draftKey);
    }

    clearForm(): void {
      if (!this.container) return;

      const nameInput = this.container.querySelector(
        ".user-name"
      ) as HTMLInputElement;
      const emailInput = this.container.querySelector(
        ".user-email"
      ) as HTMLInputElement;
      const contentInput = this.container.querySelector(
        ".comment-textarea-enhanced"
      ) as HTMLTextAreaElement;

      if (nameInput) nameInput.value = "";
      if (emailInput) emailInput.value = "";
      if (contentInput) contentInput.value = "";

      this.updateCharacterCount();
    }

    insertFormat(format: string): void {
      if (!this.container) return;

      const textarea = this.container.querySelector('.comment-textarea-enhanced') as HTMLTextAreaElement;
      if (!textarea) return;

      const start = textarea.selectionStart;
      const end = textarea.selectionEnd;
      const selectedText = textarea.value.substring(start, end);

      let replacement: string;
      let cursorOffset = 0;

      switch (format) {
        case '**bold**':
          if (selectedText) {
            replacement = `**${selectedText}**`;
            cursorOffset = replacement.length;
          } else {
            replacement = '**bold text**';
            cursorOffset = 2; // Position cursor between asterisks
          }
          break;
        case '_italic_':
          if (selectedText) {
            replacement = `_${selectedText}_`;
            cursorOffset = replacement.length;
          } else {
            replacement = '_italic text_';
            cursorOffset = 1; // Position cursor after first underscore
          }
          break;
        case '`code`':
          if (selectedText) {
            replacement = `\`${selectedText}\``;
            cursorOffset = replacement.length;
          } else {
            replacement = '`code`';
            cursorOffset = 1; // Position cursor after first backtick
          }
          break;
        default:
          replacement = format;
          cursorOffset = replacement.length;
      }

      textarea.value = textarea.value.substring(0, start) + replacement + textarea.value.substring(end);
      
      // Set cursor position
      const newPos = selectedText ? start + cursorOffset : start + cursorOffset;
      textarea.focus();
      textarea.setSelectionRange(newPos, newPos);

      this.saveDraft();
      this.updateCharacterCount();

      // Visual feedback
      const btn = this.container.querySelector(`[data-format="${format}"]`) as HTMLElement;
      if (btn) {
        btn.style.background = 'var(--color-accent)';
        btn.style.color = 'white';
        setTimeout(() => {
          btn.style.background = '';
          btn.style.color = '';
        }, 150);
      }
    }

    toggleEmojiPicker(): void {
      if (!this.container) return;

      const emojiBtn = this.container.querySelector(
        ".emoji-btn"
      ) as HTMLButtonElement;
      if (!emojiBtn) return;

      const emojis = [
        "😀",
        "😂",
        "😍",
        "🤔",
        "👍",
        "👎",
        "❤️",
        "🔥",
        "💯",
        "🎉",
        "👏",
        "🚀",
      ];

      // Remove existing picker
      const existingPicker = document.querySelector(".emoji-picker-simple");
      if (existingPicker) {
        existingPicker.remove();
        return;
      }

      // Create emoji picker
      const picker = document.createElement("div");
      picker.className = "emoji-picker-simple";
      picker.style.cssText = `
        position: absolute;
        background: var(--color-bg-primary);
        border: 2px solid var(--color-border);
        padding: 0.75rem;
        display: grid;
        grid-template-columns: repeat(6, 1fr);
        gap: 0.5rem;
        z-index: 1000;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
      `;

      emojis.forEach((emoji) => {
        const emojiOption = document.createElement("button");
        emojiOption.textContent = emoji;
        emojiOption.style.cssText = `
          border: none;
          background: none;
          font-size: 1.25rem;
          padding: 0.5rem;
          cursor: pointer;
          transition: background-color 0.2s ease;
        `;

        emojiOption.addEventListener("click", () => {
          this.insertEmoji(emoji);
          picker.remove();
        });

        emojiOption.addEventListener("mouseenter", () => {
          emojiOption.style.backgroundColor = "var(--color-bg-secondary)";
        });

        emojiOption.addEventListener("mouseleave", () => {
          emojiOption.style.backgroundColor = "transparent";
        });

        picker.appendChild(emojiOption);
      });

      // Position picker
      const rect = emojiBtn.getBoundingClientRect();
      picker.style.top = `${rect.bottom + window.scrollY + 8}px`;
      picker.style.left = `${rect.left + window.scrollX}px`;

      document.body.appendChild(picker);

      // Close picker when clicking outside
      setTimeout(() => {
        const closeHandler = (e: Event) => {
          if (!picker.contains(e.target as Node)) {
            picker.remove();
            document.removeEventListener("click", closeHandler);
          }
        };
        document.addEventListener("click", closeHandler);
      }, 100);
    }

    insertEmoji(emoji: string): void {
      if (!this.container) return;

      const textarea = this.container.querySelector(
        ".comment-textarea-enhanced"
      ) as HTMLTextAreaElement;
      if (!textarea) return;

      const start = textarea.selectionStart;
      const end = textarea.selectionEnd;

      textarea.value =
        textarea.value.substring(0, start) +
        emoji +
        textarea.value.substring(end);

      textarea.focus();
      const newPos = start + emoji.length;
      textarea.setSelectionRange(newPos, newPos);

      this.saveDraft();
      this.updateCharacterCount();
    }

    showError(message: string): void {
      this.showNotification(message, "error");
    }

    showSuccess(message: string): void {
      this.showNotification(message, "success");
    }

    showNotification(message: string, type: string = "info"): void {
      const notification = document.createElement("div");
      notification.className = `tinkbyte-notification tinkbyte-notification-${type}`;

      const bgColor =
        type === "error"
          ? "#fee2e2"
          : type === "success"
            ? "#dcfce7"
            : "#dbeafe";

      const textColor =
        type === "error"
          ? "#dc2626"
          : type === "success"
            ? "#16a34a"
            : "#2563eb";

      const borderColor =
        type === "error"
          ? "#fecaca"
          : type === "success"
            ? "#bbf7d0"
            : "#bfdbfe";

      notification.style.cssText = `
        position: fixed;
        top: 2rem;
        right: 2rem;
        background: ${bgColor};
        color: ${textColor};
        border: 2px solid ${borderColor};
        padding: 1rem 1.5rem;
        font-weight: 600;
        z-index: 1001;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        animation: slideInRight 0.3s ease;
        max-width: 400px;
      `;

      notification.innerHTML = `
        <div style="display: flex; align-items: center; gap: 0.5rem;">
          <span>${message}</span>
          <button onclick="this.parentElement.parentElement.remove()" style="background: none; border: none; cursor: pointer; padding: 0.25rem; opacity: 0.7;">
            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor">
              <line x1="18" y1="6" x2="6" y2="18"/>
              <line x1="6" y1="6" x2="18" y2="18"/>
            </svg>
          </button>
        </div>
      `;

      document.body.appendChild(notification);

      setTimeout(() => {
        if (notification.parentElement) {
          notification.style.animation = "slideOutRight 0.3s ease";
          setTimeout(() => notification.remove(), 300);
        }
      }, 5000);
    }
  }

  // Animation styles
  if (!document.getElementById("tinkbyte-animations")) {
    const style = document.createElement("style");
    style.id = "tinkbyte-animations";
    style.textContent = `
      @keyframes slideInRight {
        from {
          transform: translateX(100%);
          opacity: 0;
        }
        to {
          transform: translateX(0);
          opacity: 1;
        }
      }
      @keyframes slideOutRight {
        from {
          transform: translateX(0);
          opacity: 1;
        }
        to {
          transform: translateX(100%);
          opacity: 0;
        }
      }
      @keyframes spin {
        from {
          transform: rotate(0deg);
        }
        to {
          transform: rotate(360deg);
        }
      }
      .animate-spin {
        animation: spin 1s linear infinite;
      }
    `;
    document.head.appendChild(style);
  }

  // Initialize when DOM is ready
  document.addEventListener("DOMContentLoaded", () => {
    new TinkByteCommentsEnhanced();
  });
</script>